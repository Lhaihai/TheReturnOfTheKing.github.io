<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SQL注入笔记（3）：MySQL-information_schema介绍]]></title>
    <url>%2F2018%2F04%2F26%2FSQL%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%EF%BC%9AMySQL-information-schema%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[一、information_schema是什么information_schema是MySQL自带的一个信息数据库，其保存着关于MySQL服务器所维护的所有其他数据库的信息，如数据库名，数据库的表，表栏的数据类型与访问权限等。 也就是说当你建立一个新的数据库，或者在已有的数据库中增删改表的话，都会记录在information_schema库中。 它提供了访问数据库元数据的方式。什么是元数据呢。元数据是关于数据的数据，如数据库名或表名，列的数据类型，或访问权限等。有些时候用于表述该信息的其他术语包括“数据词典”和“系统目录”。 在MySQL中，把 information_schema 看作是一个数据库，确切说是信息数据库。其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权 限等。在INFORMATION_SCHEMA中，有数个只读表。它们实际上是视图，而不是基本表，因此，你将无法看到与之相关的任何文件。 例如下面就可以把全部数据库select出来 12345678910111213mysql&gt; select schema_name from information_schema.schemata;+--------------------+| schema_name |+--------------------+| information_schema || learning || mysql || performance_schema || sakila || sys || t2 || test |+--------------------+ 把数据库的表select出来 12345678910111213141516mysql&gt; SELECT * FROM `TABLE_CONSTRAINTS`limit 10;+--------------------+-------------------+-----------------+--------------+---------------+-----------------+| CONSTRAINT_CATALOG | CONSTRAINT_SCHEMA | CONSTRAINT_NAME | TABLE_SCHEMA | TABLE_NAME | CONSTRAINT_TYPE |+--------------------+-------------------+-----------------+--------------+---------------+-----------------+| def | auroralab | PRIMARY | auroralab | user | PRIMARY KEY || def | day06 | PRIMARY | day06 | users | PRIMARY KEY || def | dvwa | PRIMARY | dvwa | guestbook | PRIMARY KEY || def | dvwa | PRIMARY | dvwa | users | PRIMARY KEY || def | mysql | PRIMARY | mysql | columns_priv | PRIMARY KEY || def | mysql | PRIMARY | mysql | db | PRIMARY KEY || def | mysql | PRIMARY | mysql | engine_cost | PRIMARY KEY || def | mysql | PRIMARY | mysql | event | PRIMARY KEY || def | mysql | PRIMARY | mysql | func | PRIMARY KEY || def | mysql | PRIMARY | mysql | gtid_executed | PRIMARY KEY |+--------------------+-------------------+-----------------+--------------+---------------+-----------------+10 rows in set (0.47 sec) 二、information_schema数据库主要表说明SCHEMATA表：提供了当前MySQL实例中所有数据库的信息。是show databases的结果取之此表。 TABLES表：提供了关于数据库中的表的信息（包括视图）。详细表述了某个表属于哪个schema，表类型，表引擎，创建时间等信息。是show tables from schemaname的结果取之此表。 COLUMNS表：提供了表中的列信息。详细表述了某张表的所有列以及每个列的信息。是show columns from schemaname.tablename的结果取之此表。 STATISTICS表：提供了关于表索引的信息。是show index from schemaname.tablename的结果取之此表。 USER_PRIVILEGES（用户权限）表：给出了关于全程权限的信息。该信息源自mysql.user授权表。是非标准表。 SCHEMA_PRIVILEGES（方案权限）表：给出了关于方案（数据库）权限的信息。该信息来自mysql.db授权表。是非标准表。 TABLE_PRIVILEGES（表权限）表：给出了关于表权限的信息。该信息源自mysql.tables_priv授权表。是非标准表。 COLUMN_PRIVILEGES（列权限）表：给出了关于列权限的信息。该信息源自mysql.columns_priv授权表。是非标准表。 CHARACTER_SETS（字符集）表：提供了mysql实例可用字符集的信息。是SHOW CHARACTER SET结果集取之此表。 COLLATIONS表：提供了关于各字符集的对照信息。 COLLATION_CHARACTER_SET_APPLICABILITY表：指明了可用于校对的字符集。这些列等效于SHOW COLLATION的前两个显示字段。 TABLE_CONSTRAINTS表：描述了存在约束的表。以及表的约束类型。 KEY_COLUMN_USAGE表：描述了具有约束的键列。 ROUTINES表：提供了关于存储子程序（存储程序和函数）的信息。此时，ROUTINES表不包含自定义函数（UDF）。名为“mysql.proc name”的列指明了对应于INFORMATION_SCHEMA.ROUTINES表的mysql.proc表列。 VIEWS表：给出了关于数据库中的视图的信息。需要有show views权限，否则无法查看视图信息。 TRIGGERS表：提供了关于触发程序的信息。必须有super权限才能查看该表。 参考链接：mysql information_schema介绍十分钟了结MySQL information_schema]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滥用 MySQL LOCAL INFILE 读取客户端文件]]></title>
    <url>%2F2018%2F04%2F25%2F%E6%BB%A5%E7%94%A8%20MySQL%20LOCAL%20INFILE%20%E8%AF%BB%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[LOAD DATA INFILEMySQL 中提供了LOAD DATA INFILE语句来插入数据。 以下实例中将从当前目录中读取文件 dump.txt ，将该文件中的数据插入到当前数据库的 mytbl 表中。 1mysql&gt; LOAD DATA LOCAL INFILE &apos;dump.txt&apos; INTO TABLE mytbl; 如果指定LOCAL关键词，则表明从客户主机上按路径读取文件。如果没有指定，则文件在服务器上按路径读取文件。 你能明确地在LOAD DATA语句中指出列值的分隔符和行尾标记，但是默认标记是定位符和换行符。 两个命令的 FIELDS 和 LINES 子句的语法是一样的。两个子句都是可选的，但是如果两个同时被指定，FIELDS 子句必须出现在 LINES 子句之前。 如果用户指定一个 FIELDS 子句，它的子句 （TERMINATED BY、[OPTIONALLY] ENCLOSED BY 和 ESCAPED BY) 也是可选的，不过，用户必须至少指定它们中的一个。 123mysql&gt; LOAD DATA LOCAL INFILE &apos;dump.txt&apos; INTO TABLE mytbl -&gt; FIELDS TERMINATED BY &apos;:&apos; -&gt; LINES TERMINATED BY &apos;\r\n&apos;; LOAD DATA 默认情况下是按照数据文件中列的顺序插入数据的，如果数据文件中的列与插入表中的列不一致，则需要指定列的顺序。 如，在数据文件中的列顺序是 a,b,c，但在插入表的列顺序为b,c,a，则数据导入语法如下： 12mysql&gt; LOAD DATA LOCAL INFILE &apos;dump.txt&apos; -&gt; INTO TABLE mytbl (b, c, a); 浅谈MySQL load data local infile细节 – 从源码层面mysql 的load data local infile命令如果在使用过程中出现提示： 1ERROR 1148 (42000): The used command is not allowed with this MySQL version 这种情况一般是由于MySQL限制了客户端导入本地文件的权限， 解决方案： MySQL远程导入数据LOAD DATA LOCAL INFILE …关于命令load data local infile 配置MySQL安全配置正餐一道CTF题目的学习 滥用 MySQL LOCAL INFILE 读取客户端文件: https://w00tsec.blogspot.co.uk/2018/04/abusing-mysql-local-infile-to-read.html]]></content>
      <categories>
        <category>Web安全</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo的Next主题实现二级categories]]></title>
    <url>%2F2018%2F04%2F25%2FHexo%E7%9A%84Next%E4%B8%BB%E9%A2%98%E5%AE%9E%E7%8E%B0%E4%BA%8C%E7%BA%A7categories%2F</url>
    <content type="text"><![CDATA[just like this 123categories: - 一级分类- 二级分类 注意一下-后面还有个空格]]></content>
      <categories>
        <category>GitHub hexo建站</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DDL、DML、DCL的区别和理解]]></title>
    <url>%2F2018%2F04%2F25%2FDDL%E3%80%81DML%E3%80%81DCL%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[DML DML（data manipulation language）数据操纵语言： 数据操作语言，SQL中处理数据等操作统称为数据操纵语言 123456789101112131.SELECT - retrieve data from the a database 查询 2.INSERT - insert data into a table添加 3.UPDATE - updates existing data within a table 更新 4.DELETE - deletes all records from a table, the space for the records remain 删除 5.CALL - call a PL/SQL or Java subprogram 6.EXPLAIN PLAN - explain access path to data 7.LOCK TABLE - control concurrency 锁，用于控制并发 1234SELECT 列名称 FROM 表名称UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....)DELETE FROM 表名称 WHERE 列名称 = 值 DDL DDL（data definition language）数据库定义语言： 数据定义语言，用于定义和管理 SQL 数据库中的所有对象的语言 1234567891011121314151.CREATE - to create objects in the database 创建 2.ALTER - alters the structure of the database 修改 3.DROP - delete objects from the database 删除 4.TRUNCATE - remove all records from a table, including all spaces allocated for the records are removed TRUNCATE TABLE [Table Name]。 5.COMMENT - add comments to the data dictionary 注释 6.GRANT - gives user&apos;s access privileges to database 授权 7.REVOKE - withdraw access privileges given with the GRANT command 收回已经授予的权限 12345678910111213CREATE TABLE 表名称(列名称1 数据类型,列名称2 数据类型,列名称3 数据类型,....)ALTER TABLE table_nameALTER COLUMN column_name datatypeDROP TABLE 表名称DROP DATABASE 数据库名称 DCL DCL（Data Control Language）数据库控制语言： 是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。这个比较少用到。 12345671.COMMIT - save work done 提交 2.SAVEPOINT - identify a point in a transaction to which you can later roll back 保存点 3.ROLLBACK - restore database to original since the last COMMIT 回滚 4.SET TRANSACTION - Change transaction options like what rollback segment to use 设置当前事务的特性，它对后面的事务没有影响 ​]]></content>
      <categories>
        <category>数据库</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入笔记（2）：MySQL长字符截断]]></title>
    <url>%2F2018%2F04%2F24%2FSQL%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%EF%BC%9AMySQL%E9%95%BF%E5%AD%97%E7%AC%A6%E6%88%AA%E6%96%AD%2F</url>
    <content type="text"><![CDATA[介绍：转载来自MySQL 字符截断攻击 先创建一张表 12345CREATE table users(id int(11) not NULL primary key auto_increment,username char(8) not NULL,password char(10) not NULL); 正常插入 admin ; admin insert into users(username,password) values(&#39;admin&#39;,&#39;admin&#39;); 超出字符限制插入(用户名长度为8): insert into users(username,password) values(&#39;admin &#39;,&#39;admin&#39;); insert into users(username,password) values(&#39;admin 1&#39;,&#39;admin&#39;); 超过位数的用户名会被截断 ,所以 ,admin 1 与 admin共存于一张表 select username from users where username = &#39;admin&#39;; 发现两个用户都被select出来 如果管理员的登录界面是这样判断的 : $sql = &quot;select count(*) from users where username = &#39;admin&#39; and password=&#39;任意&#39; &quot;; 那我们只需要注册一个账号为admin 1,password = &quot;任意&quot;, 就可以用admin登录 题目：https://ringzer0team.com/challenges/171 随手试了一下二次注入，发现有点不像于是进行长度截断注册 12username=admin 1#password=1 登录 12username=adminpassword=1 ####]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>web安全，SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入笔记（1）：注释]]></title>
    <url>%2F2018%2F04%2F24%2FSQL%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9A%E6%B3%A8%E9%87%8A%2F</url>
    <content type="text"><![CDATA[各个数据库的注释： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576OracleREM单行注释-- 单行注释/*多行注释*/ MS SQL Server-- 单行注释/*多行注释*/ MySQL#单行注释-- 单行注释（特别注意，-- 后有个空格！！！）/*多行注释*/ 总结：/*多行注释*/ 和-- 单行注释都差不多，MySQL要注意。非标准的#和REM最好还是不要用了为了兼容-- 后面最好都加空格MySQL注释的说明－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－‘--’作为注释起始标记一些其他SQL数据库采用“--”作为注释开始标志。MySQL服务器采用“#”作为注释起始字符。对于MySQL服务器，也能使用C风格的注释：/*该处为注释*/。请参见9.5节，“注释语法”。MySQL服务器3.23.3和更高版本支持“--”注释风格，但要求注释后面跟1空格（或控制字符，如新行）。之所以要求使用空格，是为了防止与自动生成SQL查询有关的问题，它采用了类似下面的代码，其中，自动为“!payment!”插入“payment”的值：UPDATE account SET credit=credit-!payment!考虑一下，如果“payment”的值为负数如“-1”时会出现什么情况：UPDATE account SET credit=credit--1在SQL中“credit--1”是合法的表达式，但是，如果“--1”被解释为注释开始，部分表达式将被舍弃。其结果是，表达式的意义与预期的意义完全不同。UPDATE account SET credit=credit该语句不会对值作任何更改！这表明，允许注释以“--”开始会产生严重后果。采用MySQL服务器3.23.3和更高版本中的这类注释方法，“credit--1”实际上很安全。另一个安全特性是，mysql命令行客户端将删除所有以“--”开头的行。仅当使用高于3.23.3的MySQL时，下述信息才有意义：如果有1个文本文件形式的SQL程序，该文件包含“--”注释，应按下述方式使用replace实用工具，将其转换为使用“#”字符的注释：shell&gt; replace &quot; --&quot; &quot; #&quot; &lt; text-file-with-funny-comments.sql \ | mysql db_name而不是通常的：shell&gt; mysql db_name &lt; text-file-with-funny-comments.sql你也可以编辑注释文件，将“--”注释更改为“#”注释：shell&gt; replace &quot; --&quot; &quot; #&quot; -- text-file-with-funny-comments.sql使用下述命令将其改回去：shell&gt; replace &quot; #&quot; &quot; --&quot; -- text-file-with-funny-comments.sql 题目：Most basic SQLi pattern.(point 1)12username: admin&apos;#password: 1 签到题，注释后面的password语句 解释： 如果后台的数据库语句是这样子的 1select * from user where username = '$username' and password = '$password' 输入之后，后面的password就被注释掉了，如果有admin的用户，就可以登录成功 1select * from user where username = 'admin'# and password = '1' ACL rulezzz the world.(point 2)随手测试 1username=admin&apos; 得到 1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;&apos;admin&apos;&apos;&apos; at line 4 随手闭合一下 1username=admin&apos; or 1# ###]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>转载,SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python合并Excel表格]]></title>
    <url>%2F2018%2F04%2F23%2FPython%E5%90%88%E5%B9%B6Excel%E8%A1%A8%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[前言：因为有个同学问我有没有快速合并二十多个表格的方法，我说用Python，，， 然后，就有了下面的代码 #### 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#!/usr/bin/python3# -*- coding: utf-8 -*-# @Time : 2018/4/22 0:40# @Author : Lhaihai# @File : CombinedForm.py# @Software: PyCharm# @Blog : http://blog.Lhaihai.wang""" Description : 合并文件夹的二十多个Excel"""import openpyxlimport openpyxl.cellfrom openpyxl.utils import get_column_letterimport osdef main(file_dir): for root, dirs, files in os.walk(file_dir): if(root != file_dir): continue print(root) #当前目录路径 print(dirs) #当前路径下所有子目录 print(files) #当前路径下所有非目录子文件 path = "xxxxxxxxxxx" wbmain = openpyxl.load_workbook(path + '数据导入模板.xlsx') sheetmain1 = wbmain['1.学生本人基本信息'] sheetmain2 = wbmain['2.学生家庭成员基本信息'] try: sheetmain3 = wbmain['3.学生本人干部任职信息'] except: print('Worksheet 3.学生本人干部任职信息 does not exist.') try: sheetmain4 = wbmain['4.论文'] # print(sheetmain4) except: print('Worksheet 4.论文 does not exist.') sheetmain5 = wbmain['5.评优'] try: sheetmain6 = wbmain['6.实习数据'] # print(sheetmain6) except: print('Worksheet 6.实习数据 does not exist.') sheetmain7 = wbmain['7.学生活动'] indexrow = [2,2,2,2,2,2,2] for file in files: if(file == '数据导入模板.xlsx'): continue print(path+file) wb = openpyxl.load_workbook(path+file) sheet1 = wb['1.学生本人基本信息'] print(sheet1.max_row) for i in range(2,int(sheet1.max_row)+1): if(not sheet1['A'+str(i)].value): continue for j in range(1,20): letter = get_column_letter(j) sheetmain1[letter+str(indexrow[0])] = sheet1[letter+str(i)].value print(sheetmain1[letter+str(indexrow[0])].value) indexrow[0]+=1 # sheet2 = wb['2.学生家庭成员基本信息'] # for i in range(2,int(sheet2.max_row)+1): # for j in range(1,14): # letter = get_column_letter(j) # sheetmain2[letter+str(indexrow[1])] = sheet2[letter+str(i)].value # print(sheetmain2[letter+str(indexrow[1])].value) # indexrow[1]+=1 try: sheet3 = wb['3.学生本人干部任职信息'] for i in range(2, int(sheet3.max_row) + 1): if (not sheet3['A' + str(i)].value): continue for j in range(1, 10): letter = get_column_letter(j) sheetmain3[letter + str(indexrow[2])] = sheet3[letter + str(i)].value print(sheetmain3[letter + str(indexrow[2])].value) indexrow[2] += 1 except: print(file+'Worksheet 3.学生本人干部任职信息 does not exist') try: sheet4 = wb['4.论文'] for i in range(2, int(sheet4.max_row) + 1): if (not sheet4['A' + str(i)].value): continue for j in range(1, 8): letter = get_column_letter(j) sheetmain4[letter + str(indexrow[3])] = sheet4[letter + str(i)].value print(sheetmain4[letter + str(indexrow[3])].value) indexrow[3] += 1 except: print('Worksheet 4.论文 does not exist.') try: sheet5 = wb['5.评优'] for i in range(2, int(sheet5.max_row) + 1): if (not sheet5['A' + str(i)].value): continue for j in range(1, 8): letter = get_column_letter(j) sheetmain5[letter + str(indexrow[4])] = sheet5[letter + str(i)].value print(sheetmain5[letter + str(indexrow[4])].value) indexrow[4] += 1 except: print(file+'Worksheet 5.评优 does not exist.') try: sheet6 = wb['6.实习数据'] for i in range(2, int(sheet6.max_row) + 1): if (not sheet6['A' + str(i)].value): continue for j in range(1, 9): letter = get_column_letter(j) sheetmain6[letter + str(indexrow[5])] = sheet6[letter + str(i)].value print(sheetmain6[letter + str(indexrow[5])].value) indexrow[5] += 1 except: print('Worksheet 6.实习数据 does not exist.') sheet7 = wb['7.学生活动'] for i in range(2, int(sheet7.max_row) + 1): if (not sheet7['A' + str(i)].value): continue for j in range(1, 9): letter = get_column_letter(j) sheetmain7[letter + str(indexrow[6])] = sheet7[letter + str(i)].value print(sheetmain7[letter + str(indexrow[6])].value) indexrow[6]+=1 wbmain.save(path+'example2.xlsx')if __name__ == '__main__': path= r'xxxxxx' main(path)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Postman使用]]></title>
    <url>%2F2018%2F04%2F23%2FPostman%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[介绍： 模拟各种HTTP requests 从常用的 GET、POST 到 RESTful 的 PUT 、 DELETE …等等。 甚至还可以发送文件、送出额外的 header。 Collection 功能（测试集合） Collection 是 requests的集合，在做完一個测试的時候， 你可以把這次的 request 存到特定的 Collection 里面，如此一來，下次要做同样的测试时，就不需要重新输入。而且一个collection可以包含多条request，如果我们把一个request当成一个test case，那collection就可以看成是一个test suite。通过collection的归类，我们可以良好的分类测试软件所提供的API.而且 Collection 还可以 Import 或是 Share 出來，让团队里面的所有人共享你建立起來的 Collection。 人性化的Response整理 一般在用其他工具來测试的時候，response的内容通常都是纯文字的 raw， 但如果是 JSON ，就是塞成一整行的 JSON。这会造成阅读的障碍 ，而 Postman 可以针对response内容的格式自动美化。 JSON、 XML 或是 HTML 都會整理成我们可以阅读的格式 内置测试脚本语言 Postman支持编写测试脚本，可以快速的检查request的结果，并返回测试结果 设定变量与环境 Postman 可以自由 设定变量与Environment，一般我们在编辑request，校验response的时候，总会需要重复输入某些字符，比如url，postman允许我们设定变量来保存这些值。并且把变量保存在不同的环境中。比如，我們可能会有多种环境， development 、 staging 或 local， 而这几种环境中的 request URL 也各不相同，但我们可以在不同的环境中设定同样的变量，只是变量的值不一样，这样我们就不用修改我们的测试脚本，而测试不同的环境。 下载地址：因为2018年初Chrome禁止了Postman，但我刚才使用的时候是可以再Chrome浏览器使用的。然而还是有个提示建议用本地客户端。 所以放出官网下载链接 https://www.getpostman.com/postman 可以使用google账号直接登录 使用： 官方文档https://www.getpostman.com/docs/v6/]]></content>
      <categories>
        <category>CTF工具</category>
      </categories>
      <tags>
        <tag>web,tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3实现hetianlab自动签到并且发短信到手机]]></title>
    <url>%2F2018%2F04%2F17%2Fhetianlab%E8%87%AA%E5%8A%A8%E7%AD%BE%E5%88%B0%E5%B9%B6%E4%B8%94%E5%8F%91%E7%9F%AD%E4%BF%A1%E5%88%B0%E6%89%8B%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[首发合天，禁止转载0x00 前言​ 这几天学了学python爬虫，就想用python实现一下自动签到领取积分，毕竟我比较懒，能不动手就让代码去做吧，☺。 0x01 安装环境python 需要用到的库12pip install selenium #模拟浏览器行为的库pip install twilio #发送短信 安装ChromeDriverChromeDriver是Chrome浏览器的自动化测试工具 1、先查看Chrome浏览器的版本 点击 Chrome 的菜单，帮助-&gt;关于 Chrome，即可查看 Chrome 的版本号 这里我的版本号是65.0 2、下载ChromeDriver 官方下载链接： https://sites.google.com/a/chromium.org/chromedriver/downloads 这里我就下载 ChromeDriver 2.37 3、配置环境变量 Windows下，直接把ChromeDriver .exe 放在Python的 Scripts目录下 Linux和Mac也是一样把文件移动到属于环境变量的目录里或者将可执行文件配置到环境变量。 例如下面移动文件到 /usr/bin 目录，首先进入其所在路径，然后将其移动到 /usr/bin： 1sudo mv chromedriver /usr/bin 4、测试一下哈 在命令行输入 chromedriver ，如果有类似输出就说明chromedriver 的环境变量配置好了 然后再写代码测试一下 12from selenium import webdriverbrowser = webdriver.Chrome() 运行，会弹出Chrome浏览器，就可以开始写登录代码了。 0x02 登录hetianlabselenium是什么官方的话：selenium一个Web应用程序测试的工具，而且Selenium测试直接运行在浏览器中，就像真正的用户在操作一样 简单的说，就是我们可以用selenium来控制浏览器然后完成一系列操作，比如打开某个网页，点击超链接、按钮，在文本框输入字符，获取网页的内容，模拟鼠标操作（右键，双击） Selenium 支持非常多的浏览器，如 Chrome、Firefox、Edge等，最新版本的Selenium已经不支持无界面浏览器PhantomJS，但是Chrome和Firefox已经支持无界面。 我们可以用下面的方式初始化一个浏览器对象 1234567from selenium import webdriverbrowser = webdriver.Chrome()browser = webdriver.Firefox()browser = webdriver.Edge()browser = webdriver.PhantomJS()browser = webdriver.Safari() 设置Chrome浏览器无界面： 1234567from selenium import webdriverfrom selenium.webdriver.chrome.options import Options #导入Optionschrome_options = Options()chrome_options.add_argument('--headless') #无界面模式chrome_options.add_argument('--disable-gpu') #Windows平台需要加上browser = webdriver.Chrome(chrome_options=chrome_options) #把无界面设置导入 想要了解更多，可以查看官方文档：https://developers.google.cn/web/updates/2017/04/headless-chrome 打开一个网页Selenium提供了get()方法来访问网页 123456from selenium import webdriverbrowser = webdriver.Chrome()browser.get('https://www.baidu.com') #打开百度print(browser.page_source)browser.close() selenium怎么获取网页信息获取节点selenium获取节点（节点可以理解是网页的按钮，输入框等，学过HTML的同学知道其实它就是一个标签或者标签里面的内容、属性）的方法很多，下面是获取单个节点的方法，返回的是WebElement 类型 12345678find_element_by_idfind_element_by_namefind_element_by_xpathfind_element_by_link_textfind_element_by_partial_link_textfind_element_by_tag_namefind_element_by_class_namefind_element_by_css_selector 想获取多个节点的话，就是element后面加上s 例如：find_elements_by_id 查找多个节点函数返回的结果是一个列表，列表的每个节点是WebElement 类型 节点交互输入文字用 send_keys() 方法，清空文字用 clear() 方法，另外按钮点击用 click() 方法。例如： 12phonenumber = browser.find_element_by_id('userEmail') #通过id捕获到用户名输入框phonenumber.send_keys(Username) #在用户名文本框输入用户名 获取节点信息WebElement 类型有相关的方法和属性来直接提取节点信息，如属性、文本等等 123456input = browser.find_element_by_by_id('userEmail')print(input.get_attribute('class') #获取class的名字print(input.id) #获取idprint(input.location) #location 可以获取该节点在页面中的相对位置 print(input.tag_name) #tag_name 可以获取标签名称print(input.size) #size 可以获取节点的大小 知识点介绍好了，开始实战，打开我们要签到的首页，F12 -&gt;点一下左边的小箭头-&gt;再点输入手机的文本框-&gt;就会显示出文本框的信息来。查看发现它的id是userEmail，就可以通过id来获取这个节点。 密码框和登录按钮也是如此，类似操作拿到密码框的id是 passwordIn，登录按钮的id是registButIn。 于是我们初步的代码已经出来了。 version 1.0这是第一个版本， 12345678910111213141516from selenium import webdriverimport timeUsername = 'xxxxxxxxx' #登录的手机号码Password = 'xxxxxxxxxx' #密码loginUrl = 'http://www.xxxxxx.com/loginLab.do' #xxxxxx登录网址browser = webdriver.Chrome()browser.maximize_window() #浏览器最大化browser.get(loginUrl) #Chrome浏览器打开登录页面phonenumber = browser.find_element_by_id('userEmail') #通过id捕获到用户名输入框phonenumber.send_keys(Username) #在用户名文本框输入用户名password = browser.find_element_by_id('passwordIn') #通过id捕获到密码输入框password.send_keys(Password) #在密码框输入密码siginbutton = browser.find_element_by_id('registButIn') #捕获到登录按钮 siginbutton.click() #点击登录按钮time.sleep(3) #暂停3sbrowser.close() #关闭浏览器 运行，试了几次竟然都成功登录了 :-( 我之前测试的时候，老是没有登录成功，原因是 登录按钮没有获取到，就算暂停了程序(time.sleep())等一等还是有这个问题。所以我就写了个函数来检查登录按钮是否获取成功 1234567891011121314151617def isFindElement(element): # print('check:') # print(element) if element: #如果捕获到元素，就返回true，否则返回false return True else: return False def SignIn() #略略略 #----- siginbutton = browser.find_element_by_id('registButIn') while(not isFindElement(siginbutton)): #循环判断登录按钮是否获取成功，成功就退出 time.sleep(0.5) print('signin-false') siginbutton = browser.find_element_by_id('registButIn') siginbutton.click() 之前测试的时候，check起码打印两次 :-( ， 但是想到这个方法的估计也就像我一样是个不怎么了解selenium的新手 后来了解到 selenium的等待，赶紧优化一下 version 2.0介绍两个新概念 selenium 的隐性等待和显性等待 隐性等待隐形等待是设置了一个最长等待时间，如果在规定时间内网页加载完成，则执行下一步，否则一直等到时间截止，然后执行下一步。 1implicitly_wait(10) #等待10s 温馨提示：隐性等待在整个driver的周期都起作用，所以只要设置一次即可显性等待WebDriverWait，配合该类的until()和until_not()方法，就可以根据判断条件而进行灵活地等待了。 它主要的意思就是：程序每隔xx秒看一眼，如果条件成立了，则执行下一步，否则继续等待，直到超过设置的最长时间，然后抛出TimeoutException。 代码具体什么意思可以去看一下手册，这里我们只要会调用就好了。 123456789101112131415from selenium.webdriver.support.wait import WebDriverWait #导入了新的库from selenium.webdriver.support import expected_conditions as EC #导入了新的库from selenium.webdriver.common.by import By #导入了新的库 def SignIn() #省略十万行代码 locator = (By.ID, 'registButIn') #通过id发现的登录按钮 try: #等待30s，默认0.5s检查一次是否捕获到登录按钮 WebDriverWait(browser,30).until(EC.presence_of_element_located(locator)) siginbutton = browser.find_element_by_id('registButIn') siginbutton.click() print('登录按钮点击成功') except: print("registButIn can't find") 温馨提示：最长等待时间取决于隐性等待和显性等待的最大值。上面例子为30s，如果隐性等待时间大于显性等待时间，那么最长等待时间就是隐性等待时间 顺便包装为函数方便调用，添加上获取合氏币的代码，前面为了方便测试就没有设置为无界面模式，现在可以设置为无界面模式了version 2.0 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/python3# -*- coding: utf-8 -*-# @Time : 2018/4/17 12:55# @Author : Lhaihai# @File : # @Software: PyCharm""" Description : 自动登录，签到一下，并且拿到自己当前积分有多少，最后发送短信给手机"""from selenium import webdriver from selenium.webdriver.chrome.options import Options from selenium.webdriver.support.wait import WebDriverWait from selenium.webdriver.support import expected_conditions as EC from selenium.webdriver.common.by import By import timechrome_options = Options()chrome_options.add_argument('--headless')chrome_options.add_argument('--disable-gpu')def SignIn(Username,Password): loginUrl='http://www.xxxxxxx.com/loginLab.do' browser = webdriver.Chrome(chrome_options=chrome_options) #设置为无界面模式 browser.maximize_window() browser.implicitly_wait(10) #隐性等待10s browser.get(loginUrl) phonenumber = browser.find_element_by_id('userEmail') phonenumber.send_keys(Username) password = browser.find_element_by_id('passwordIn') password.send_keys(Password) locator = (By.ID, 'registButIn') try: WebDriverWait(browser,30).until(EC.presence_of_element_located(locator)) #显性等待30s siginbutton = browser.find_element_by_id('registButIn') siginbutton.click() print('登录按钮点击成功') except: print("registButIn can't find") time.sleep(3) #signImg捕获用户头像，没错就是头像，其实把鼠标放到头像上就会显示我的主页，selenium也有模拟鼠标操作的，那就是ActionChains，这里简单起见就直接使用.click()了 signImg = browser.find_element_by_class_name('siLg-img') signImg.click() #点击 myindex = browser.find_element_by_link_text('我的主页') myindex.click() #点击我的主页 heshibi = browser.find_elements_by_class_name('allNum') #获得登录次数和积分数量 Msg = '签到成功\n登录次数:' + heshibi[0].text + ',积分：' + heshibi[1].text print(Msg) browser.close() if __name__ == '__main__': SignIn('username','password') #填写你的用户名和密码 0x03 发送短信​ 这时候我们已经可以成功登录并且拿到自己账号积分的数量。接下来我们进行最后一步，发送短信到自己手机上。 1、注册Twilio账号访问http://twilio.com/（需要自备梯子）填写注册表单。注册了新账户后，你需要验证一个手机号码，短信将发给该号码（这项验证是必要的，防止有人利用该服务向任意的手机号码发送垃圾短信）。收到验证号码短信后，在Twilio网站上输入它，证明你拥有要验证的手机。 现在，就可以用twilio模块向这个电话号码发送短信了。 2、获取一个Twilio电话号码：我在Dashboard找了好久没发现Phone的选项，后来翻了翻官方教程https://support.twilio.com/hc/en-us/articles/223136107-How-does-Twilio-s-Free-Trial-work-/，然后点里面的链接打开 :-( 。 其实你可以用右上角的UPGRADE搜索框搜索，或者直接打开这个网址 https://www.twilio.com/console/phone-numbers/getting-started 挑一个地区和号码，确定。恭喜你，获得一个免费的电话号码了。 3、要验证接收短信的手机号码，要不然就会出现下面的报错1twilio.base.exceptions.TwilioRestException: HTTP 400 error: Unable to create record: The number +8613xxxxxx30 is unverified. Trial accounts cannot send messages to unverified numbers; verify +8613xxxxxx30 at twilio.com/user/account/phone-numbers/verified, or purchase a Twilio number to send messages to unverified numbers. 在Verified 验证手机号码 可以发送短信验证码或者接受电话获得验证码 4、正式发送短信从官方文档 https://www.twilio.com/docs/libraries/python 拿到下面代码 123456789101112131415from twilio.rest import Client# Your Account SID from twilio.com/consoleaccount_sid = "AC9810ae2342f0014cd05e338bce9be8cb"# Your Auth Token from twilio.com/consoleauth_token = "your_auth_token"client = Client(account_sid, auth_token)message = client.messages.create( to="+15558675309", #接收短信的手机 from_="+15017250604", #自己twilio的号码 body="Hello from Python!") #短信的内容print(message.sid) 只需要把 auth_tocken 和from_换成自己的，再修改一下to和body auth_tocken : 打开Dashboard，加密的就是你的auth_tocken message 的from_ 填上你的twilio手机号码，虽然你选择号码的时候看起来是这样子：+1(855) 912-6770 (这个号码是我重新去twilio买电话号码那随机拿的一个，并不是我的:） )但是最后你会获得一个号码：类似+15017250604 ， 运行一下，就可以收到短信了，短信的号码是会换了，玩多了你就发现自己手机一大片都是twilio的短信 最后封装一下函数，类似下方， 12345678910111213141516from twilio.rest import Clientdef sendMessage(toPhoneNumber,Msg): # Your Account SID from twilio.com/console account_sid = "AC9810ae2342f0014cd05e338bce9be8cb" # Your Auth Token from twilio.com/console auth_token = "your_auth_token" client = Client(account_sid, auth_token) message = client.messages.create( to='+86'+toPhoneNumber, #接收短信的手机 from_="+15017250604", #自己twilio的号码 body=Msg) #短信的内容 print(message.sid) 我保存为twilioToMyPhone.py，放到python.exe 当前目录下 以后想发送短信就直接调用： 12import twilioToMyPhonetwilioToMyPhone.sendMessage('phonenumber',Msg) 5、在version 2.0 加上发送短信的代码在开头导入库 1import twilioToMyPhone 在browser.close() 之前，Msg = &#39;&#39;签到成功......&#39;之后加上发送短信的一句代码 123Msg = '签到成功\n登录次数:' + heshibi[0].text + ',积分：' + heshibi[1].texttwilioToMyPhone.sendMessage('phonenumber',Msg)browser.close() 差不多大功告成了，就算可以一键登录，不用手动打开浏览器，我还是想跟懒一点 :） 最后一步，设置每天自动启动py tip1:to=”+15558675309” to的值是接收短信的手机号码，注意的是，中国大陆的电话号码要在前面加上+86 tip2：python文件的命名不能是twilio.py 如果你像我一样给它这样命名，在import twilio库的时候会失败， 哈哈，宛如一个智障（自我嘲讽一波） 找找stackoverflow.com发现下面这个： https://stackoverflow.com/questions/41013556/importerror-cannot-import-name-twiliorestclient tip3：github项目 https://github.com/twilio/twilio-python/ 0x04 设置每天自动启动python.bat 运行python问题来了，想要运行python代码，总不能启动pycharm然后点击运行吧 ，所以使用DOS命令来运行python代码 而.bat 是 windows的批处理文件，可以双击.bat文件来运行我们的python代码 具体什么意思么，.py文件不能像exe一样双击运行，但是.bat文件可以，这是为了方便我们下一步的任务启动器 类似下图， 这里有个坑，当你原原本本按照上图打好了每一个字符，双击.bat ，却发现没有成功运行（收到短信） 然后复制python F:\CodeDevelopment\PythonDevelopment\hetianLabSignin.py 到DOS，发现有个方框在 F:\前面，去掉方框，再从DOS复制这条代码到.bat文件，就可以运行了。或者直接先在DOS敲好这句代码，然后复制到.bat。 当然，顺便运行看看能不能正常启动，类似下图就是成功了，但DOS会跳出一些INFO，目前还不知道为什么 任务计划程序当当当，最最后一步，设置自动启动 不同操作系统都有自己的任务计划程序 Windows ：任务计划程序， Linux： Cron Mac ： Launchd 以Windows 10 为例子： 1、打开任务计划程序，直接搜索就好了，win+s弹出搜索框(开着小娜的话电脑CPU利用率一直挺高，关了就好很多了)，然后输入任务计划程序 2、点击右边的创建任务 3、名字自己随便取吧，触发器-&gt;新建-&gt; 设置每天某个时候启动， 但是如果我那个时候电脑没有开启呢？可以在设置勾上 ‘如果过了计划开始时间，立即启动任务’ 4、最重要的操作来了，新建操作-&gt;浏览选上测试好的bat 5、乖巧等待它自动运行 0x05 后记或许有大佬想问了，为啥不用request，而这么麻烦的用selenium。 我是学习了selenium后，想要练练手，仅此而用。 简单尝试了下request 123456789import requestsdatas=&#123; 'username':'xxxxxxxxxxx', 'password':'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'&#125;r= requests.get('http://www.xxxxx.com/loginLab.do',data=datas)print(r.text) 直接在登录页面post没成功，抓包发现 先是Post一个去/getRsaOfKey.action 返回一些字符串 接着 才是真的 POST /Login.action 发现它post过去的密码是经过加密了的，而且还POST了两个认证参数 1&amp;validateCode=&amp;rtnJson=true 所以我们构造POST的data为 123456datas=&#123; &apos;username&apos;:&apos;xxxxxxxxxxxx&apos;, &apos;password&apos;:&apos;xxxxxxxxxxxxxxxxxxxxxxxxx&apos;, &apos;validateCode&apos;:&apos;true&apos;, &apos;rtnJson&apos;:&apos;true&apos;,&#125; 因为是先POST去 /getRsaOfKey.action拿到加密后的password，然后POST /Login.action 所以我直接request请求/Login.action 然后再request一下自己的主页看看登录次数 检查一下当前的登录次数：264 运行代码： 再运行一次： 登录成功了，以后登录就只需要运行下面短短20行左右代码，感谢合天小姐姐提醒我填了这个坑 123456789101112131415161718192021222324252627282930313233#!/usr/bin/python3# -*- coding: utf-8 -*-# @Time : 2018/4/24 13:02# @Author : Lhaihai# @File : Request模拟登陆xxxx.py# @Software: PyCharm""" Description : 使用request来登陆"""import requestsfrom bs4 import BeautifulSoupdatas=&#123; 'username':'xxxxxxxxxxxxx', 'password':'xxxxxxxxxxxxxxxxxxxxxxxxx', 'validateCode':'true', 'rtnJson':'true',&#125;url = 'http://www.xxxxxxx.com/Login.action'myindexUrl = 'http://www.xxxxxxxx.com/profile.do?u=xxxxxxxxxxxx' #我的主页urlsession = requests.session()#模拟登陆r = session.post(url,data=datas)#输出响应报文状态码print(r.status_code)#请求访问主页r2 = session.get(myindexUrl)bs = BeautifulSoup(r2.text,'lxml')for Msg in bs.find_all(class_='logoRight'): for ms in Msg.find_all(name='p'): print(ms.string) 写得挺长的，或许有些错误。虚心请教各位大表哥，如果发现错误，请指点一下小弟。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬取ichunqiu的课程列表]]></title>
    <url>%2F2018%2F04%2F16%2F%E7%88%AC%E5%8F%96ichunqiu%E7%9A%84%E8%AF%BE%E7%A8%8B%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[0x00 模拟浏览器登录0x01 爬取课程数据0x02 把课程数据保存在Excel表格爬取了ichunqiu的全部课程，把课程名字，费用，课程时间，学习人数保存到Excel表格里 最后统计了一下，如果购买ichunqiu的全部360门课程，需要 13835 元，好贵，可恶。还好强网杯送了VIP 每门课的学习人数加起来有 ： 20338110 对你没看错，两千多万，:-( 看来很多大表哥都在认真学习，我需要继续加油 现在有点晚了，有空再详细写一下 把代码奉上:） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#!/usr/bin/python3# -*- coding: utf-8 -*-# @Time : 2018/4/16 20:04# @Author : Lhaihai# @File : 爬取ichunqiu的课程.py# @Software: PyCharm# @Blog : http://blog.Lhaihai.wang""" Description : 看了ADO大哥的Python视频，特来练练手"""import timefrom selenium import webdriverfrom selenium.webdriver.chrome.options import Optionsimport openpyxldef main(): url = 'https://user.ichunqiu.com/login?r=https%3A%2F%2Fwww.ichunqiu.com%2F' chrome_options = Options() chrome_options.add_argument('--headless') chrome_options.add_argument('--disable-gpu') browser = webdriver.Edge() browser.maximize_window() browser.implicitly_wait(10) browser.get(url) phonenumber = browser.find_element_by_id('username') phonenumber.send_keys('132xxxxxxxx') #ichunqiu用户名 password = browser.find_element_by_id('password') password.send_keys('xxxxxxxx') #密码 siginbutton = browser.find_elements_by_tag_name('button') siginbutton[1].click() zhishitixi = browser.find_element_by_link_text('知识体系') zhishitixi.click() pagesizetext = browser.find_element_by_class_name('paginmsg') pagesize = int(pagesizetext.text[1:3]) print(pagesize) time.sleep(5) fileName = 'ichunqiuCourse.xlsx' wb = openpyxl.load_workbook(fileName) sheet = wb['Sheet1'] coursenum = 1 for i in range(pagesize): print('第%s页：'%(i+1)) try: courses = browser.find_elements_by_class_name('coursedesc') except: courses = browser.find_elements_by_class_name('coursedesc') for course in courses: coursenum += 1 temp = str(course.text).split('\n') q = 0 for k in ['A','B','C','D']: sheet[k+str(coursenum)]=temp[q] q +=1 print(temp[0]+' '+temp[1]+' '+temp[2]+' '+temp[3]) time.sleep(30) forward = browser.find_element_by_link_text('下一页') forward.click() wb.save(fileName) time.sleep(10) browser.close() # headers = &#123; # 'Host': 'www.ichunqiu.com', # 'Upgrade-Insecure - Requests': '1', # 'User-Agent': 'Mozilla / 5.0(Windows NT 10.0; WOW64) AppleWebKit / 537.36(KHTML, like Gecko) Chrome / 65.0 .3325 .162 Safari / 537.36', # 'Cookie':'jsluid = db12a88242060be7332ceb595406d146; UM_distinctid = 160 f2bab2de3e - 075 c93693782be - 5 a442916 - 144000 - 160 f2bab2df60c; pgv_pvi = 3608032256; chkphone = acWxNpxhQpDiAchhNuSnEqyiQuDIO0O0O; bdshare_firstime = 1523760890619; CNZZDATA1262179648 = 1767882761 - 1515897679 - https % 253 A % 252 F % 252 Fwww.baidu.com % 252 F % 7 C1523878517; pgv_si = s8916923392; Hm_lvt_2d0601bd28de7d49818249cf35d95943 = 1523684986, 1523758601, 1523780794, 1523879628; robot = 1; Hm_lvt_9104989ce242a8e03049eaceca950328 = 1523512155, 1523544753, 1523758659, 1523879645; Hm_lpvt_9104989ce242a8e03049eaceca950328 = 1523879645; Hm_lvt_1a32f7c660491887db0960e9c314b022 = 1523512155, 1523544754, 1523758659, 1523879645; Hm_lpvt_1a32f7c660491887db0960e9c314b022 = 1523879645; browse = CFlZTVQKAE9cU1FMW0oaT1haUldcQVhNRFNbWFxBSUdaWVxAVEBbV1IKUkBYQFxGUhBSRFdLS0dZUlBYXkJER1lDWkZURVxPWldKTgdLXE1dUV9OHUtYTFNBWkVfSURFXU5YTU5BUE9dW1JEXVNSHFNWWUVYSFIGU1JRT0xDWURRTlhGQ0NQVVlTUkVdS1tDS1gBT1tGUUJQWBtPX0hTV1tTWU1DQV1YWFRIRFdLXEFTV1xXVRhTQFhXWEBVAlNEUFlKR15AUVhZV0VFVlFbRFNWUU9fQ0tOAFldRlpCXk4aWVlMVFNbRVhbRUVaXFhCSVFYT15EU0FfQVMcVERdRVBQUwZUQFBPS1FYRFZcWUFEUl5VX0FTQF1ZWkVMSgBPXFVRRF9KGk9YWlJXXEFYTURTXFheSElEWllbRVRFXVdSClJAVkJaRlIQUkRXS0tHWVJQWF5FRERYQ1pFVEBQT1hWSk4HS1xNXlpRTh1LWExTQVpFX0lERV1OWUVOQFxPWFZSQFdTUhxTVFBOHUtYTFNBWkVfSURFXU5ZRU5AXE9YVVJBWFNSHFNXX0BVAlNEUFlKR15AUVhZV0VEXlFbRFNWXk9eQUtOAFldQVlCXE4aWVlMVFNbRVhbRUVaXFhFSVFZT1tHU0VdQVMcVERRQVhWUwZUQFBPS1FYRFZcWUFEUllVX0NTRl1ZWkVMSgBPX1JbTV1KGk9YWlJXXEFYTURTXFhfQ0lEXVlZRFRFXVdSClJDX0ReQlIQUkRXS0tHWVJQWF5FRERaQ1lGVEVQT1tWSk4HS19EX1dRTh1LWExTQVpFX0lERV1OWUNOQFlPWlZSRFhTUgg; ci_session = 61 ef25a31707ca2e4aca5c072f778ef4068bcd64; Hm_lpvt_2d0601bd28de7d49818249cf35d95943 = 1523880868' # &#125; # # r = requests.get(url) # r.status_code # r.encoding = 'utf-8' # print(r.text)if __name__ == '__main__': main()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA['python操作Excel']]></title>
    <url>%2F2018%2F04%2F16%2Fpython%E6%93%8D%E4%BD%9CExcel%2F</url>
    <content type="text"><![CDATA[0x00 安装openpyxlpip install openpyxl 我直接使用pycharm在当前项目安装了 0x01 读写Excel打开Excel文档1wb = openpyxl.load_workbook('ichunqiuCourse.xlsx') 取得工作表123wb.sheetnames #获得Excel每个表的名字sheet = wb['Sheet1'] #获得工作表，对工作表进行操作print(sheet['A1'].value) #获得Sheet1表格A1单元格的值 测试下面代码 12345678import openpyxlwb = openpyxl.load_workbook(&apos;ichunqiuCourse.xlsx&apos;)print(&apos;Excle的工作表有：&apos;+str(wb.sheetnames))sheet = wb[&apos;Sheet1&apos;]for i in [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;]: print(sheet[str(i)+&apos;1&apos;].value+&apos;:&apos;+sheet[str(i)+&apos;2&apos;].value) 向Excel写入数据12345sheet['A3']= '社工情报侦察神器——Maltego'sheet['B3']= '免费'sheet['C3']= '7课时174分钟'sheet['D3']= '25651人学习'wb.save('ichunqiuCourse.xlsx') 成功写入数据 0x02完整代码 123456789101112131415161718192021222324#!/usr/bin/python3# -*- coding: utf-8 -*-# @Time : 2018/4/16 22:08# @Author : Lhaihai# @File : controlExcel.py# @Software: PyCharm# @Blog : http://blog.Lhaihai.wang""" Description : 使用python读写Excel"""import openpyxlwb = openpyxl.load_workbook('ichunqiuCourse.xlsx')print('Excle的工作表有：'+str(wb.sheetnames))sheet = wb['Sheet1']for i in ['A','B','C','D']: print(sheet[str(i)+'1'].value+':'+sheet[str(i)+'2'].value)sheet['A3']= '社工情报侦察神器——Maltego'sheet['B3']= '免费'sheet['C3']= '7课时174分钟'sheet['D3']= '25651人学习'wb.save('ichunqiuCourse.xlsx') 注意：我看的《Python编程快速上手——让繁琐工作自动化》这本书，也许是这本书有点旧了，里面刚开始用的是 get_sheet_names 和get_sheet_by_name ，但是PyCharm会warning，提示建议使用 wb.sheetnames和wb[sheetname] 123DeprecationWarning: Call to deprecated function get_sheet_names (Use wb.sheetnames)DeprecationWarning: Call to deprecated function get_sheet_by_name (Use wb[sheetname]). 我搜到有人使用xlrd、xlwt包来操作Excel，但http://www.python-excel.org/推荐使用`openpyxl` 我也推荐用openpyxl ，因为它比那两个包方便很多。 至于一些字体大小也颜色也是可以设置的，就不写了，如果要用到就翻书吧。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA['小米路由器开机自动登录Dr.COM']]></title>
    <url>%2F2018%2F04%2F16%2F%E5%B0%8F%E7%B1%B3%E8%B7%AF%E7%94%B1%E5%99%A8%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95Dr-COM%2F</url>
    <content type="text"><![CDATA[0x00 小米路由开启SSH访问1.检查是否为开发版 2.如果不是开发版，到下面网址下在rom升级http://www1.miwifi.com/miwifi_download.html next 3.然后网页打开http://miwifi.com/cgi-bin/luci/web 进入管理页面手动升级 4.给小米路由安装SSH管理工具，具体看下面这篇百度经验，还是挺容易的https://jingyan.baidu.com/article/a24b33cd1080f719fe002b8e.html 注意：​ 在用SSH连接小米路由器时，不同路由器的IP地址可能不同，查看小米路由器的，下图圈起来来的IP地址就是SSH登录时的服务器IP，用户名是：root，密码：下载小米路由器SSH工具的页面有 0x01 测试Dr.com具体步骤查看下方网址： https://github.com/drcoms/drcom-generic/wiki/d%E7%89%88%E7%AE%80%E7%95%A5%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E 1.使用wireshark在官方客户端登录前开始截包，做一次完整的截包动作然后登出，保存为 wireshark截包文件, 比如 dr.pcapng (扩展名为pcapng)。 2.下载 d版配置生成器, 将其与第一步的截包文件放到同一个目录下，并且将第17行的 filename = &#39;3.pcapng&#39; 中的 dr.pcapng 改为第一步保存的文件名。 3.进入命令提示符(或shell)进入 drcom_d_config.py 所在目录，输入 python drcom_d_config.py &gt; config.txt ，打开 config.txt 根据提示，新建drcom.conf文件，复制类在似下方段落保存在drcom.conf文件中 123456789101112131415server = &apos;119.39.119.2&apos; //服务器ip地址username=&apos;02xxxxxxxxx@zndx&apos; //xxx是你的学号password=&apos;&apos;CONTROLCHECKSTATUS = &apos;\x20&apos;ADAPTERNUM = &apos;\x08&apos;host_ip = &apos;10.0.7.24&apos; //小米路由器的ip地址IPDOG = &apos;\x01&apos;host_name = &apos;GILIGILIEYE&apos;PRIMARY_DNS = &apos;192.168.31.1&apos;dhcp_server = &apos;0.0.0.0&apos;AUTH_VERSION = &apos;\x2d\x00&apos;mac = 0x000000000000host_os = &apos;NOTE7&apos;KEEP_ALIVE_VERSION = &apos;\xd8\x02&apos;ror_version = True 4.在自己电脑测试 保存https://github.com/drcoms/drcom-generic项目的latest-wired.py 到自己电脑（发现原来有python3版本的呀，苦逼的我为了用python2特地修改了下系统环境变量） 注意latest-wired.py使用python2执行，latest-wired-python3.py应该可以用python3执行，看官可以自己试一下，我没有测试。 傻傻的我直接打在windows打linux命令了 改一改绑定的端口就可以了，在73行 看到类似提示，那就是可以用了，这时候并没有成功连接Dr.com的服务器，因为我这是候还没有在drcom.conf配置文件的password打上我联通账号的密码。将 latest-wired.py 改名为 drcom.py 接下来就到小米路由器上测试了。 0x02设置小米路由器开机启动Dr.com下方网址的大哥写得很详细了，我就补充一下一些需要注意的地方： http://bbs.xiaomi.cn/t-12871940 1.配置开机自动运行 Dr. COM 登录脚本/etc/inittab可以使用WinSCP直接操作，不熟悉vim命令的话 使用vim的过程十分痛苦（有点反人类）,复制::respawn:/data/python/usr/bin/python /data/python/usr/bin/drcom.py 到inittab最后一行，Ctrl+S保存，退出 2.放配置文件 0x03 效果reboot路由器后，ps查看。等个几秒钟，就连上网了 0x04 后记昨晚弄好没有问题，早上起来用手机连上WiFi又弹出联通页面了。 putty连接小米路由器（小强root@XiaoQiang:~#)，刚开始我以为是联通服务器有问题掉线了，我偶尔遇到过Dr.com客户端断开连接，然后reboot重启下路由器。 再ps查看一下，咦，怎么没有我可爱的python进程（登录哆点的脚本） 最后检查了etc/inittab，没错就是添加 ::respawn:/data/python/usr/bin/python /data/python/usr/bin/drcom.py 这条语句的文件，发现这条语句没了，emmmm 加上去，再reboot一下就连上网了。 我猜可能是路由器自动恢复？还是刚好被我遇到了这个奇葩bug？ 后续想着设置一下每天自动执行 killall python，Linux是有cron个工具，类似于windows的task scheduler，可以设置定时启动某任务。]]></content>
      <categories>
        <category>趣味玩耍</category>
      </categories>
      <tags>
        <tag>小米路由器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python识别验证码]]></title>
    <url>%2F2018%2F04%2F15%2Fpython%E8%AF%86%E5%88%AB%E9%AA%8C%E8%AF%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[0x00 安装环境OCR(Optical Character Recognition): 光学字符识别,是指对图片文件中的文字进行分析识别，获取的过程。 Tesseract： 开源的OCR识别引擎，初期Tesseract引擎由HP实验室研发，后来贡献给了开源软件业，后经由Google进行改进，消除bug，优化，重新发布。当前版本为4.0 (安装教程是从这复制来的：http://www.inimei.cn/archives/297.html) 首先需要安装pytesseract库还有图像处理的PILLOW库了 12pip install pytesseractpip install PILLOW 然后要安装一个Tesseract-OCR软件。这个软件是由Google维护的开源的OCR软件。下载地址：百度网盘（密码：5m3d）。再在Windows下配置一下环境变量。 0x01报错：FileNotFoundError: [WinError 2] 系统找不到指定的文件。https://blog.csdn.net/jacke121/article/details/75443785 1pytesseract.pytesseract.tesseract_cmd = r&apos;C:\Program Files (x86)\Tesseract-OCR\tesseract.exe&apos; 0x02 报错：pytesseract.pytesseract.TesseractError: (1, ‘Error opening data file \Program Files (x86)\Tesseract-OCR\eng.traineddata1pytesseract.pytesseract.TesseractError: (1, &apos;Error opening data file \\Program Files (x86)\\Tesseract-OCR\\eng.traineddata Please make sure the TESSDATA_PREFIX environment variable is set to your &quot;tessdata&quot; directory. Failed loading language \&apos;eng\&apos; Tesseract couldn\&apos;t load any languages! Could not initialize tesseract.&apos;) 在.py 文件配置中指定 tessdata-dir 12tessdata_dir_config = '--tessdata-dir "D:\\Program Files (x86)\\Tesseract-OCR\\tessdata"'text = pytesseract.image_to_string(image,lang='chi_sim',config=tessdata_dir_config) 0x03 供上代码12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/env python3# -*- coding: utf-8 -*-# @Date : 2018-04-15 13:18:36# @Author : Lhaihai ($&#123;email&#125;)# @Link : http://blog.Lhaihai.wang# @Version : $Id$import pytesseractfrom PIL import Imagedef get_bin_table(threshold = 230): # 获取灰度转二值的映射table table = [] for i in range(256): if i &lt; threshold: table.append(0) else: table.append(1) return tabledef main(): pytesseract.pytesseract.tesseract_cmd = r'D:\Program Files (x86)\Tesseract-OCR\tesseract.exe' image = Image.open('1.jpg') # image.show() #打开图片1.jpg #imgry = image.convert('L') # 转化为灰度图，虽然说转为灰度图识别更好的一点，但随你喜欢用不用 #table = get_bin_table() #out = imgry.point(table, '1') tessdata_dir_config = '--tessdata-dir "D:\\Program Files (x86)\\Tesseract-OCR\\tessdata"' text = pytesseract.image_to_string(image,lang='eng',config=tessdata_dir_config) # fil = filter(str.isdigit, text) # new_text = '' # for i in fil: # new_text += i print(text)if __name__ == '__main__': main() 有时候可以识别出来，有时候识别不了，时好时坏吧 参考地址： https://blog.csdn.net/Sioon_XUX/article/details/78617160 http://www.cnblogs.com/zhongtang/tag/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/ https://blog.csdn.net/kiramario/article/details/53781369 https://github.com/tesseract-ocr/tesseract/wiki/4.0-with-LSTM#400-alpha-for-windows https://github.com/tesseract-ocr/tesseract/wiki/Data-Files https://github.com/madmaze/pytesseract https://github.com/tesseract-ocr/tesseract https://github.com/tesseract-ocr/tesseract/wiki]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python+twilio发送短信]]></title>
    <url>%2F2018%2F04%2F14%2Fpython-twilio%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[注册Twilio账号访问http://twilio.com/并填写注册表单。注册了新账户后，你需要验证一个手机号码，短信将发给该号码（这项验证是必要的，防止有人利用该服务向任意的手机号码发送垃圾短信）。收到验证号码短信后，在Twilio网站上输入它，证明你拥有要验证的手机。现在，就可以用twilio模块向这个电话号码发送短信了。 1、获取一个Twilio电话号码：https://support.twilio.com/hc/en-us/articles/223136107-How-does-Twilio-s-Free-Trial-work-/ 2、要验证接收短信的手机号码，要不然就会报错1twilio.base.exceptions.TwilioRestException: HTTP 400 error: Unable to create record: The number +8613xxxxxx30 is unverified. Trial accounts cannot send messages to unverified numbers; verify +8613xxxxxx30 at twilio.com/user/account/phone-numbers/verified, or purchase a Twilio number to send messages to unverified numbers. 到这个网址验证手机号码：https://www.twilio.com/console/phone-numbers/verified 可以发送短信验证码或者打电话输入验证码 3、官方文档https://www.twilio.com/docs/libraries/python 发送短信123456789101112131415from twilio.rest import Client# Your Account SID from twilio.com/consoleaccount_sid = "AC9810ae2342f0014cd05e338bce9be8cb"# Your Auth Token from twilio.com/consoleauth_token = "your_auth_token"client = Client(account_sid, auth_token)message = client.messages.create( to="+15558675309", from_="+15017250604", body="Hello from Python!")print(message.sid) 效果如下： tip1:to=”+15558675309” to的值是接收短信的手机号码，注意的是，中国大陆的电话号码要在前面加上+86 tip2：python文件的命名不能是twilio.py 如果你像我一样给它这样命名，在导入twilio库的时候会失败，提示unuseful rest 哈哈，宛如一个智障（自我嘲讽一波） 找找stackoverflow.com发现下面这个： https://stackoverflow.com/questions/41013556/importerror-cannot-import-name-twiliorestclient tip3:封装一下函数，（并且放在python.exe当前目录，方便其它python文件调用），就方便使用了 1sendMessage('tophonenumber','Happy to do this') tip4：github项目 https://github.com/twilio/twilio-python/ 打电话12345678910from twilio.rest import Clientaccount = "ACXXXXXXXXXXXXXXXXX"token = "YYYYYYYYYYYYYYYYYY"client = Client(account, token)call = client.calls.create(to="9991231234", from_="9991231234", url="http://twimlets.com/holdmusic?Bucket=com.twilio.music.ambient")print(call.sid) 只能打电话过来，说几句英语，不能沟通 Handling a call using TwiML（偷个懒直接从github复制） To control phone calls, your application needs to output TwiML. Use twilio.twiml.Response to easily create such responses. 12345from twilio.twiml.voice_response import VoiceResponser = VoiceResponse()r.say("Welcome to twilio!")print(str(r)) 最后还是不知道怎么实现打电话双向通话(；へ：) 参考链接： https://baijiahao.baidu.com/s?id=1593431889367189831&amp;wfr=spider&amp;for=pc]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 学习笔记]]></title>
    <url>%2F2018%2F04%2F13%2Fhexo-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[参考链接： Hexo博客教程(一):Hexo的前期部署：https://www.jianshu.com/p/9f04ee6371ce Hexo博客教程(二):基本功能和网站优化：https://www.jianshu.com/p/2a70262295e4 Hexo博客教程(三):参考资料https://www.jianshu.com/p/8f727b4c3cd1 设置访问次数统计不蒜子统计 http://theme-next.iissnan.com/third-party-services.html#analytics-busuanzi]]></content>
      <categories>
        <category>GitHub hexo建站</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>good</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网站目录结构扫描器]]></title>
    <url>%2F2018%2F03%2F13%2F%E7%BD%91%E7%AB%99%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E6%89%AB%E6%8F%8F%E5%99%A8%2F</url>
    <content type="text"><![CDATA[0x00 cansinaInstall12345pip install --user requests[security](try removing --user and install with sudo in case of errors)git clone --depth=1 https://github.com/deibit/cansina Fast useUse Python 3 (works on Python 2 too, but 3 is advisable) 1$ python3 cansina.py -u &lt;site_url&gt; -p &lt;payload_file&gt; 0x01 dirsearchinstall(need Python 3.X)Linux: 123git clone https://github.com/maurosoria/dirsearch.gitcd dirsearch/./dirsearch.py -u 目标网址 -e * Windows: https://github.com/maurosoria/dirsearch/archive/master.zip Fast use12./dirsearch.py -u 目标网址 -e *./dirsearch.py -u 目标网址 -e php| grep 200 !dirsearch]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>python Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N1CTF笔记]]></title>
    <url>%2F2018%2F03%2F11%2FN1CTF%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[https://3wapp.github.io/ http://blog.csdn.net/lacoucou/article/details/72355346 Dockerfile easy php substr(md5(?), 0, 5)=== de426 substr() 函数返回字符串的一部分。 注释：如果 start 参数是负数且 length 小于或等于 start，则 length 为 0。 语法12substr(string,start,length) 参数 描述 string 必需。规定要返回其中一部分的字符串。 start 必需。规定在字符串的何处开始。正数 - 在字符串的指定位置开始负数 - 在从字符串结尾开始的指定位置开始0 - 在字符串中的第一个字符处开始 length 可选。规定被返回字符串的长度。默认是直到字符串的结尾。正数 - 从 start 参数所在的位置返回的长度负数 - 从字符串末端返回的长度 http://www.beesfun.com/2017/03/21/CTF%E4%B9%8BMD5%E6%88%AA%E6%96%AD%E6%AF%94%E8%BE%83/ submd5.py 12345678910111213141516171819202122232425262728# -*- coding: utf-8 -*-import multiprocessingimport hashlibimport randomimport stringimport sysCHARS = string.letters + string.digitsdef cmp_md5(substr, stop_event, str_len, start=0, size=20): global CHARS while not stop_event.is_set(): rnds = ''.join(random.choice(CHARS) for _ in range(size)) md5 = hashlib.md5(rnds) if md5.hexdigest()[start: start+str_len] == substr: print rnds stop_event.set()if __name__ == '__main__': substr = sys.argv[1].strip() start_pos = int(sys.argv[2]) if len(sys.argv) &gt; 1 else 0 str_len = len(substr) cpus = multiprocessing.cpu_count() stop_event = multiprocessing.Event() processes = [multiprocessing.Process(target=cmp_md5, args=(substr, stop_event, str_len, start_pos)) for i in range(cpus)] for p in processes: p.start() for p in processes: p.join() 用法： 1234$ python submd5.py "3d4f4"SponhjOhIZ30IaM1fweb$ python submd5.py "3df4" 2G8tr6VhonA1z3xJdaGBu]]></content>
      <categories>
        <category>CTF比赛</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub hexo建站笔记]]></title>
    <url>%2F2018%2F03%2F11%2FGitHub-hexo%E5%BB%BA%E7%AB%99%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[有用的链接：12https://github.com/iissnan/hexo-theme-next/blob/master/README.cn.mdhttp://theme-next.iissnan.com/getting-started.html 0x01 Cannot GET /tags/执行 1$ hexo new page tags 之后，要修改tags文件下的index.md文件 https://www.zhihu.com/question/29017171 0x02 这里有两篇帮你不需要什么成本，搭建好一个功能完备的博客： 如何搭建一个独立博客——简明Github Pages与Hexo教程 https://www.jianshu.com/p/05289a4bc8b2 hexo 博客小功能添加-评论、相册、字数统计… https://www.jianshu.com/p/f5c184047e72]]></content>
      <categories>
        <category>GitHub hexo建站</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
